#!/bin/sh

#
# rkhunter -- Scan the system for rootkits and other known security issues.
#
# Copyright (c) 2003-2006, Michael Boelen ( michael AT rootkit DOT nl )
#
#     This program is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program; if not, write to the Free Software
#     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
#


#
# Unfortunately we must do some O/S checks at the very beginning.
# Otherwise SunOS will complain about some of the ksh/bash syntax.
#

OPERATING_SYSTEM=`uname 2>/dev/null`

if [ "${OPERATING_SYSTEM}" = "SunOS" ]; then
	if [ -z "$RANDOM" ]; then
		if [ -n "`which bash 2>/dev/null | grep '^/'`" ]; then
			exec bash $0 $*
		else
			exec ksh $0 $*
		fi

		exit 0
	fi
fi

if [ "$1" = "--debug" ]; then
	rm -f /tmp/rkhunter-debug >/dev/null 2>&1
	exec 1>/tmp/rkhunter-debug 2>&1
	set -x
fi

case "${OPERATING_SYSTEM}" in
AIX|OpenBSD|SunOS)
	# What is the default shell?
	if print >/dev/null 2>&1; then
		alias echo='print'
		E=""
		ECHOOPT="--"
		NEWECHOOPT="--"
		MYSHELL=ksh
	else
		E="-e"
		ECHOOPT=""
		NEWECHOOPT="-e"
		MYSHELL=bash
	fi
	;;
*)
	E="-e"
	ECHOOPT=""
	NEWECHOOPT="-e"


	#
	# We want to get the actual shell used by this program, and
	# so we need to test /bin/sh.
	#

	MYSHELL=/bin/sh
	test -h ${MYSHELL} && MYSHELL=`readlink ${MYSHELL} 2>/dev/null`
	MYSHELL=`basename ${MYSHELL} 2>/dev/null`

	if [ -z "${MYSHELL}" ]; then
		MYSHELL=bash
	elif [ "${MYSHELL}" = "dash" -o "${MYSHELL}" = "ash" ]; then
		E=""
		NEWECHOOPT=""
	fi
	;;
esac


######################################################################
#
# Global function definitions
#
######################################################################


display() {

	#
	# This function is used to display text messages on to the
	# users screen, as well as in to the log file. The same
	# message is written to both. However, the screen may have
	# a coloured result (green for good, red for bad, etc), and
	# the log file will have the time prefixed to the message and,
	# optionally, additional information messages after the main
	# message. All the messages are indexed in the language file.
	#
	# Syntax: display --to <destination> --type <type>
	#		  [--screen-indent <n>] [--log-indent <n>] [--nl]
	#		  [--result <result> --color <colour>]
	#		  <message index> [optional message arguments]
	#
	# where the destination can be one of SCREEN, LOG or SCREEN+LOG.
	# The type can be one of PLAIN, INFO or WARNING.
	# The language file will have all the current values.
	#
	# The --screen-indent and --log-indent options are used to
	# forcibly indent a message.
	# The --nl option causes a blank-line to be output before the
	# message.
	#


	#
	# We first initialize some variables and then
	# process the switches used.
	#

	WARN_MSG=0; NL=0; LOGINDENT=0; SCREENINDENT=0
	WRITETO=''; TYPE=''; RESULT=''; COLOR=''; MSG=''
	LINE1=''; LOGLINE1=''; SPACES=''

	DISPLAY_LINE="display $*"

	if [ $# -le 0 ]; then
		echo "Error: Invalid display call - no arguments given"
		return
	fi

	while [ $# -ge 1 ]; do
		case "$1" in
			--to)
				case "$2" in
					SCREEN|LOG|SCREEN+LOG)
						WRITETO=$2
						;;
					*)
						echo "Error: Invalid display destination: $2   Display line: ${DISPLAY_LINE}"
						return
						;;
				esac

				shift
				;;
			--type)
				TYPE=`eval echo "\\$MSG_TYPE_$2"`

				if [ -z "${TYPE}" -a "$2" != "PLAIN" ]; then
					echo "Error: Invalid display type: $2   Display line: ${DISPLAY_LINE}"
					return
				fi

				test "$2" = "WARNING" && WARN_MSG=1

				shift
				;;
			--result)
				RESULT=`eval echo "\\$MSG_RESULT_$2"`

				if [ -z "${RESULT}" ]; then
					echo "Error: Invalid display result: $2   Display line: ${DISPLAY_LINE}"
					return
				fi

				shift
				;;
			--color)
				if [ $COLORS -eq 1 ]; then
					test -n "$2" && COLOR=`eval "echo \\${$2}"`

					if [ -z "${COLOR}" ]; then
						echo "Error: Invalid display color: $2   Display line: ${DISPLAY_LINE}"
						return
					fi
				fi

				shift
				;;
			--log-indent)
				LOGINDENT=$2

				if [ -z "${LOGINDENT}" ]; then
					echo "Error: No --log-indent value given.   Display line: ${DISPLAY_LINE}"
					return
				elif [ -z "`echo ${LOGINDENT} | grep '^[0-9]*$'`" ]; then
					echo "Error: Invalid --log-indent value given: $2   Display line: ${DISPLAY_LINE}"
					return
				fi

				shift
				;;
			--screen-indent)
				SCREENINDENT=$2

				if [ -z "${SCREENINDENT}" ]; then
					echo "Error: No --screen-indent value given.   Display line: ${DISPLAY_LINE}"
					return
				elif [ -z "`echo ${SCREENINDENT} | grep '^[0-9]*$'`" ]; then
					echo "Error: Invalid --screen-indent value given: $2   Display line: ${DISPLAY_LINE}"
					return
				fi

				shift
				;;
			--nl)
				NL=1
				;;
			-*)
				echo "Error: Invalid display option given: $1   Display line: ${DISPLAY_LINE}"
				return
				;;
			*)
				MSG=$1
				shift
				break
				;;
		esac

		shift
	done


	#
	# For simplicity we now set variables as to whether the output
	# goes to the screen and/or the log file. In some cases we do
	# not need to output anything, and so can just return.
	#

	if [ $NOLOG -eq 1 ]; then
		test "${WRITETO}" = "LOG" && return

		test "${WRITETO}" = "SCREEN+LOG" && WRITETO="SCREEN"
	fi

	if [ $NOTTY -eq 1 ]; then
		test "${WRITETO}" = "SCREEN" && return

		test "${WRITETO}" = "SCREEN+LOG" && WRITETO="LOG"
	fi


	if [ "${WRITETO}" = "SCREEN" -o "${WRITETO}" = "SCREEN+LOG" ]; then
		WRITETOTTY=1
	else
		WRITETOTTY=0
	fi

	if [ "${WRITETO}" = "LOG" -o "${WRITETO}" = "SCREEN+LOG" ]; then
		WRITETOLOG=1
	else
		WRITETOLOG=0
	fi


	#
	# Now check that the options we have been given make sense.
	#

	if [ $WRITETOTTY -eq 0 -a $WRITETOLOG -eq 0 ]; then
		echo "Error: Invalid display destination: Display line: ${DISPLAY_LINE}"
		return
	elif [ $WRITETOTTY -eq 1 -a -n "${RESULT}" -a -z "${COLOR}" ]; then
		echo "Error: Invalid display - no color given: Display line: ${DISPLAY_LINE}"
		return
	fi


	#
	# We set the variable LINE1 to contain the first line of the message.
	# For the log file we use the variable LOGLINE1. We also set
	# where the language file is located. If a message cannot be found
	# in the file, then we look in the English file. This will allow RKH
	# to still work even when the language files change.
	#

	LANG_FILE="${DB_PATH}/i18n/${LANGUAGE}"

	if [ -n "${MSG}" ]; then
		LINE1=`grep "^${MSG}:" ${LANG_FILE} 2>/dev/null | head -n 1 | cut -d: -f2-`

		if [ -z "${LINE1}" ]; then
			LANG_FILE="${DB_PATH}/i18n/en"
			LINE1=`grep "^${MSG}:" ${LANG_FILE} 2>/dev/null | head -n 1 | cut -d: -f2-`
		fi

		test -n "${LINE1}" && LINE1=`eval "echo \"${LINE1}\" | sed -e 's/;/\\;/g'"`
	fi


	#
	# At this point LINE1 is the text of the message. We have to
	# see if the message is to be indented, and must prefix the
	# time to log file messages. We must do the log file first
	# because it uses LINE1.
	#

	if [ $WRITETOLOG -eq 1 ]; then
		LOGLINE1=`date '+[%H:%M:%S]'`

		test $NL -eq 1 && echo "${LOGLINE1}" >>${LOGFILE}

		if [ -n "${TYPE}" ]; then
			LOGLINE1="${LOGLINE1} ${TYPE}: ${LINE1}"
		else
			if [ $LOGINDENT -gt 0 ]; then
				SPACES=`echo "${BLANK_LINE}" | cut -c1-$LOGINDENT`
			fi

			LOGLINE1="${LOGLINE1} ${SPACES}${LINE1}"
		fi
	fi

	if [ $WRITETOTTY -eq 1 -a $SCREENINDENT -gt 0 ]; then
		SPACES=`echo "${BLANK_LINE}" | cut -c1-$SCREENINDENT`
		LINE1="${SPACES}${LINE1}"
	fi


	#
	# We now check to see if a result is to be output. If it is,
	# then we need to space-out the line and color the result.
	#
	if [ -n "${RESULT}" ]; then
		if [ $WRITETOTTY -eq 1 ]; then
			LINE1_NUM=`echo "${LINE1}"|wc -c | tr -d ' '`
			NUM_SPACES=`expr 62 - ${LINE1_NUM}`
			LINE1="${LINE1}\033[${NUM_SPACES}C[ ${COLOR}${RESULT}${NORMAL} ]"
		fi

		if [ $WRITETOLOG -eq 1 ]; then
			LOGLINE1_NUM=`echo "${LOGLINE1}"|wc -c | tr -d ' '`
			NUM_SPACES=`expr 62 - ${LOGLINE1_NUM}`
			test $NUM_SPACES -lt 1 && NUM_SPACES=1
			SPACES=`echo "${BLANK_LINE}" | cut -c1-$NUM_SPACES`

			LOGLINE1="${LOGLINE1}${SPACES}[ ${RESULT} ]"
		fi
	elif [ $WRITETOTTY -eq 1 -a -n "${COLOR}" ]; then
		LINE1="${COLOR}${LINE1}${NORMAL}"
	fi


	#
	# We can now output the message. We start with the first line, and
	# then if this is a warning message we write to the log file any
	# additional lines.
	#

	test $WARN_MSG -eq 1 && WARNING_COUNT=`expr ${WARNING_COUNT} + 1`

	if [ $WRITETOTTY -eq 1 ]; then
		test $NL -eq 1 && echo ""
		echo $NEWECHOOPT "${LINE1}"
	fi

	if [ $WRITETOLOG -eq 1 ]; then
		echo $NEWECHOOPT "${LOGLINE1}" >>${LOGFILE}

		if [ $WARN_MSG -eq 1 ]; then
			test $SHOWWARNINGSONLY -eq 1 && echo $NEWECHOOPT "${LOGLINE1}" | cut -d' ' -f2-

			LINE1=1

			grep "^${MSG}:" ${LANG_FILE} 2>/dev/null | cut -d: -f2- | while read LOGLINE1; do
				if [ $LINE1 -eq 1 ]; then
					LINE1=0
					continue
				else
					test $SHOWWARNINGSONLY -eq 1 && echo $NEWECHOOPT "           ${LOGLINE1}" | cut -d' ' -f2-
					echo $NEWECHOOPT "           ${LOGLINE1}" >>${LOGFILE}
				fi
			done
		elif [ $SHOWWARNINGSONLY -eq 1 -a -n "`echo \"${LOGLINE1}\" | egrep '^\[([0-9][0-9]:){2}[0-9][0-9]\]    '`" ]; then
			echo $NEWECHOOPT "${LOGLINE1}" | cut -d' ' -f2-
		fi
	fi

	return
}


keypresspause() {

	#
	# This function will display a prompt message to the user.
	#

	if [ $SKIP_KEY_PRESS -eq 0 -a $QUIET -eq 0 ]; then
		echo ""
		echo "[Press <ENTER> to continue]"
		read a
	fi

	return
}


# Logtext: add text to logfile
logtext() {
	test $NOLOG -eq 1 && return

	# Add date/time to logfile
	if [ "$1" = "--nodate" ]; then
		:
	elif [ "$1" = "--indent" ]; then
		echo -n "           " >>${LOGFILE}
	else
		echo -n "`date '+[%H:%M:%S] '`" >>${LOGFILE}
	fi

	NE1="n"
	[ "$1" = "-n" ] && NE1="y"
	[ "$1" = "-e" ] && NE1="y"

	if [ "$NE1" = "y" ]; then
		if [ "$MYSHELL" = "ksh" ]; then
			[ "$1" = "-n" ] &&  echo -n "$2" >>$LOGFILE || echo $ECHOOPT $2 >>$LOGFILE
		else
			echo $1 "$2" >>$LOGFILE
		fi
	else
		if [ "$1" = "--nodate" -o "$1" = "--indent" ]; then
			echo $ECHOOPT "$2" >>$LOGFILE
		else
			echo $ECHOOPT "$1" >>$LOGFILE
		fi
	fi
}


# Displaytext: display text to STDOUT
displaytext() {
	DODISPLAY=0
	FOUNDWARNING=0

	FOUNDWARNING1=`echo $ECHOOPT $1 | egrep 'BAD|Warning|WARNING'`
	FOUNDWARNING2=`echo $2 | egrep 'BAD|Warning|WARNING'`
	FOUNDWARNING3=`echo $3 | egrep 'BAD|Warning|WARNING'`

	if [ ! "${FOUNDWARNING1}" = "" -o ! "${FOUNDWARNING2}" = "" -o ! "${FOUNDWARNING3}" = "" ]; then
		FOUNDWARNING=1
		WARNING_COUNT=`expr ${WARNING_COUNT} + 1`
	fi

	[ $QUIET -eq 0 -o $FOUNDWARNING -eq 1 ] && DODISPLAY=1

	# Small change below to cater for OpenBSd with ksh.
	if [ "X$1" = "X-n" -o "X$1" = "X-e" ]; then
		if [ $DODISPLAY -eq 1 ]; then
			if [ -n "$PREVIOUSTEXT" ]; then
				echo -n "${PREVIOUSTEXT}"
				PREVIOUSTEXT=""
			fi
			if [ "$MYSHELL" = "ksh" ]; then
				[ "$1" = "-n" ] && echo -n "$2" || echo $ECHOOPT "$2"
			else
				echo $ECHOOPT $1 "$2"
			fi
		else
			[ "$1" = "-n" ] && PREVIOUSTEXT=`echo "$2" | sed -e 's/^ *//'`
		fi
	else
		if [ $DODISPLAY -eq 1 ]; then
			if [ -n "$PREVIOUSTEXT" ]; then
				echo -n "${PREVIOUSTEXT}"
				PREVIOUSTEXT=""
			fi
			echo $ECHOOPT "$1"
		fi
	fi
}


insertlayout() {
	if [ ${CRONJOB} -eq 0 ]; then
		LAYOUT="\033[${jump}C"
	else
		LAYOUT="  "
	fi
}


scanrootkit() {
	if [ "${ROOTKIT_TESTS}" = "" ]; then
		ROOTKIT_TESTS="${SCAN_ROOTKIT}"
	else
		ROOTKIT_TESTS="${ROOTKIT_TESTS}, ${SCAN_ROOTKIT}"
	fi
	SCAN_STATUS=0
	JUMPCOL=`expr ${defaultcolumn} - 12`
	SIZE=`echo \'${SCAN_ROOTKIT}\' | wc -c | tr -d ' '`
	jump=`expr ${JUMPCOL} - ${SIZE}`
	displaytext -n "   Rootkit '${SCAN_ROOTKIT}'... "
	logtext "*** Start scan ${SCAN_ROOTKIT} ***"

	for I in $SCAN_FILES; do
		SCANNED_COUNT=`expr ${SCANNED_COUNT} + 1`
		I=`echo ${I} | tr -s '%' ' '`
		logtext -n "  - File ${I}... "
		if [ -f "${I}" ]; then
			logtext --nodate "WARNING! Exists."
			SCAN_STATUS=1
		else
			logtext --nodate "OK. Not found."
		fi
	done

	for I in $SCAN_DIRS; do
		I=`echo ${I} | tr -s '%' ' '`
		logtext -n "  - Directory ${I}... "
		if [ -d "${I}" ]; then
			logtext --nodate "WARNING! Exists."
			SCAN_STATUS=1
		else
			logtext --nodate "OK. Not found."
		fi
	done

	# Scan ksyms or kallsyms file
	if [ -n "${SCAN_KSYMS}" -a -n "${KSYMS_FILE}" ]; then
		SEARCHTEXT=`grep ${SCAN_KSYMS} ${KSYMS_FILE}`
		if [ -n "${SEARCHTEXT}" ]; then
			logtext "WARNING! Found ${SCAN_KSYMS}"
			SCAN_STATUS=1
		else
			logtext "${KSYMS_FILE} file seems to be clean"
		fi
	fi

	if [ "${SCAN_STATUS}" -eq 1 ]; then
		insertlayout
		displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
		INFECTED_COUNT=`expr ${INFECTED_COUNT} + 1`
		INFECTED_NAMES="${INFECTED_NAMES}${SCAN_ROOTKIT} "
		displaytext "${FOUNDTRACES}"
		WARNING_COUNT=`expr ${WARNING_COUNT} + 1`

		# Run routine
		keypresspause
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
	fi
}


scanrootkit_suckit_extra_checks() {
	if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
		if [ -n "${STAT_CMD}" -a -z "`echo ${STAT_CMD} | grep '\.pl$'`" ]; then
			# Let's check the amount of links /sbin/init has
			unset i;
			i=`${STAT_CMD} -t /sbin/init | cut -d' ' -f9`
			case "${i}" in
			1)
				;;
			*)
				logtext "WARNING! ${SCAN_ROOTKIT} /sbin/init linkage"
				WARNING_COUNT=`expr ${WARNING_COUNT} + 1`
				;;
			esac
			# Let's check xrk or mem hiding
			# Easiest way to define random?
			__RANDOM=`date +%N%s%N`
			umask 027
			for ext in xrk mem; do
				randf="${TMPDIR}/${__RANDOM}.${ext}"
				test -f "${randf}" || \
				( touch ${randf} && test -f "${randf}" && rm -f ${randf} || \
					logtext "WARNING! ${SCAN_ROOTKIT} ${ext} hiding" )
			done

			# Plugin: skdet
			SKDET_CMD=`find_cmd skdet`
			if [ -n "${SKDET_CMD}" ]; then
				# Skdet version
				SKDETVER=`${SKDET_CMD} -v 2>&1 | grep '^skdet.v' | awk -F'.' '{ print $1 }'`
				case "${SKDETVER}" in
					*v0)
						SKDETOPT="-a"
						;;
					*v1)
						SKDETOPT="-c"
						;;
				esac
				RKHTMPVAR=`${SKDET_CMD} ${SKDETOPT} 2>&1 | tr -s " " | grep -i 'invis'`
				if [ -n "${RKHTMPVAR}" ]; then
					WARNING_COUNT=`expr ${WARNING_COUNT} + 1`
				fi
			fi
		else
			logtext "Info: Extended suckit tests skipped, due to missing stat command"
		fi
	else
		logtext "Info: Extended suckit tests skipped for this operating system (not Linux architecture)"
	fi
}


check_required_commands() {

	#
	# This function checks that some required commands are
	# present on the system. The function takes one argument
	# which is a list of directories to look in.
	#

	for CMD in ${REQCMDS}; do
		SEEN=0

		for DIR in $1; do
			test ! -d "${DIR}" && continue

			if [ -f "${DIR}/${CMD}" -a -x "${DIR}/${CMD}" ]; then
				SEEN=1
				break
			fi
		done

		if [ $SEEN -eq 0 ]; then
			echo "The command '$CMD' must be present on the system in order to run rkhunter."
			exit 1
		fi
	done

	return
}


check_commands() {

	#
	# We check for some commands used in the tests. If the command
	# is found then a variable including the command name is set.
	# These commands are not 'required', so nothing happens if the
	# command is not found.
	#

	for CMD in ${CMDLIST}; do
		RKHTMPVAR=`echo ${CMD} | tr '[a-z]' '[A-Z]'`
		RKHTMPVAR="${RKHTMPVAR}_CMD"


		#
		# See if the user has defined the command in
		# the configuration file.
		#

		CFG_CMD=`grep "^${RKHTMPVAR}=" ${CONFIGFILE} | tail -1`

		if [ -n "${CFG_CMD}" ]; then
			CFG_CMD=`echo "${CFG_CMD}" | sed -e "s/${RKHTMPVAR}=//" | sed -e 's/^"\(.*\)"$/\1/' | tr -s ' '`

			if [ -z "${CFG_CMD}" -o "${CFG_CMD}" = " " ]; then
				CFG_CMD=""
			else
				#
				# check that the command is executable.
				#

				MCMD=`echo "${CFG_CMD}" | cut -d' ' -f1`

				if [ -n "`find_cmd ${MCMD}`" ]; then
					eval ${RKHTMPVAR}=\"${CFG_CMD}\"
				else
					CFG_CMD=""
				fi
			fi
		fi


		#
		# If the command has not been predefined, or is not
		# executable, then go find the command to use.
		#

		if [ -z "${CFG_CMD}" ]; then
			eval ${RKHTMPVAR}=`find_cmd ${CMD}`
		fi
	done


	#
	# If we cannot find a stat command, then see if we can use the
	# supplied perl script.
	#

	if [ -z "${STAT_CMD}" -a -n "${PERL_CMD}" ]; then
		MOD_INSTALLED=`${PERL_CMD} ${SCRIPT_PATH}/check_modules.pl File::stat Getopt::Long 2>&1 | grep 'NOT'`

		if [ -z "${MOD_INSTALLED}" ]; then
			STAT_CMD="${PERL_CMD} ${SCRIPT_PATH}/stat.pl"
		fi
	fi

	return
}


get_installdir_option() {

	#
	# This function obtains the RKH installation directory. It must
	# be set by the installer script, and has no default.
	#

	INSTALLDIR=`grep '^INSTALLDIR=' ${CONFIGFILE} | tail -1 | sed -e 's/INSTALLDIR=//' | tr -d '"' | tr -s ' '`

	if [ -z "${INSTALLDIR}" -o "${INSTALLDIR}" = " " ]; then
		echo "Invalid INSTALLDIR configuration option - no installation directory specified."
		exit 1
	elif [ ! -d "${INSTALLDIR}" ]; then
		echo "Installation directory does not exist: ${INSTALLDIR}"
		exit 1
	elif [ ! -r "${INSTALLDIR}" ]; then
		echo "Installation directory is not readable: ${INSTALLDIR}"
		exit 1
	fi

	return
}


get_language_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${LANGUAGE}" ]; then
		LANGUAGE=`echo "${LANGUAGE}" | tr -s ' '`

		if [ "${LANGUAGE}" = " " ]; then
			echo "Invalid --language option - no language given."
			exit 1
		fi
	else
		LANGUAGE=`grep '^LANGUAGE=' ${CONFIGFILE} | tail -1`

		if [ -n "${LANGUAGE}" ]; then
			LANGUAGE=`echo "${LANGUAGE}" | sed -e 's/LANGUAGE=//' | tr -d '"' | tr -s ' '`

			if [ -z "${LANGUAGE}" -o "${LANGUAGE}" = " " ]; then
				echo "Invalid LANGUAGE configuration option - no language specified."
				exit 1
			fi
		fi
	fi

	#
	# Now check that the language is available.
	#

	if [ ! -f "${DB_PATH}/i18n/${LANGUAGE}" ]; then
		echo "The language specified is not available: ${LANGUAGE}"
		echo "Use the '--list languages' option to see the list of available languages."
		exit 1
	fi

	return
}


get_logfile_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${LOGFILE}" ]; then
		LOGFILE=`echo "${LOGFILE}" | tr -s ' '`

		if [ "${LOGFILE}" = " " ]; then
			echo "Invalid --logfile option - no logfile name given."
			exit 1
		fi
	else
		LOGFILE=`grep '^LOGFILE=' ${CONFIGFILE} | tail -1`

		if [ -n "${LOGFILE}" ]; then
			LOGFILE=`echo "${LOGFILE}" | sed -e 's/LOGFILE=//' | tr -d '"' | tr -s ' '`

			if [ -z "${LOGFILE}" -o "${LOGFILE}" = " " ]; then
				echo "Invalid LOGFILE configuration option - no logfile name specified."
				exit 1
			fi
		else
			echo "Default logfile will be used ($DFLT_LOGFILE)."
			LOGFILE=$DFLT_LOGFILE
		fi
	fi

	#
	# Now check that the given option is useable.
	#

	if [ "${LOGFILE}" = "/dev/null" ]; then
		APPEND_LOG=0
	else
		LOGDIR=`echo "${LOGFILE}" | sed -e 's/\/[^/][^/]*$//'`

		if [ -z "`echo ${LOGDIR} | grep '/'`" ]; then
			LOGDIR="."
		fi

		if [ "${LOGDIR}" = "${LOGFILE}" ]; then
			echo "No log filename given: ${LOGFILE}"
			exit 1
		elif [ ! -d "${LOGDIR}" ]; then
			echo "Logfile directory does not exist: ${LOGFILE}"
			exit 1
		elif [ ! -w "${LOGDIR}" ]; then
			echo "Logfile directory is not writable: ${LOGFILE}"
			exit 1
		elif [ ! -r "${LOGDIR}" ]; then
			echo "Logfile directory is not readable: ${LOGFILE}"
			exit 1
		elif [ -h "${LOGFILE}" ]; then
			echo "Logfile is a symbolic link: ${LOGFILE}"
			echo "This is a security problem. The link points to another file, and that file is about to be modified by rkhunter."
			exit 1
		elif [ -e "${LOGFILE}" -a ! -f "${LOGFILE}" ]; then
			echo "Logfile already exists but it is not a file: ${LOGFILE}"
			exit 1
		fi

		#
		# Now check whether we should append to the logfile
		# or overwrite it. We check the configuration file
		# option, if it is given, and ensure that it is valid.
		#

		if [ $APPEND_OPT -eq 0 ]; then
			APPEND_LOG=`grep '^APPEND_LOG=' ${CONFIGFILE} | tail -1`

			if [ -n "${APPEND_LOG}" ]; then
				APPEND_LOG=`echo "${APPEND_LOG}" | sed -e 's/APPEND_LOG=//' | tr -d '"' | tr -s ' '`

				if [ -z "${APPEND_LOG}" -o "${APPEND_LOG}" = " " ]; then
					echo "Invalid APPEND_LOG configuration option - no value specified."
					exit 1
				elif [ "${APPEND_LOG}" != "0" -a "${APPEND_LOG}" != "1" ]; then
					echo "Invalid APPEND_LOG configuration option: ${APPEND_LOG}"
					exit 1
				fi
			else
				APPEND_LOG=0
			fi
		fi
	fi

	return
}


get_tmpdir_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${TMPDIR}" ]; then
		TMPDIR=`echo "${TMPDIR}" | tr -s ' '`

		if [ "${TMPDIR}" = " " ]; then
			echo "Invalid --tmpdir option - no directory name given."
			exit 1
		fi
	else
		TMPDIR=`grep '^TMPDIR=' ${CONFIGFILE} | tail -1`

		if [ -n "${TMPDIR}" ]; then
			TMPDIR=`echo "${TMPDIR}" | sed -e 's/TMPDIR=//' | tr -d '"' | tr -s ' '`

			if [ -z "${TMPDIR}" -o "${TMPDIR}" = " " ]; then
				echo "Invalid TMPDIR configuration option - no directory name specified."
				exit 1
			fi
		else
			TMPDIR="${INSTALLDIR}/lib/rkhunter/tmp"
		fi
	fi

	#
	# Now check that the given option is useable.
	#

	if [ ! -d "${TMPDIR}" ]; then
		echo "Temporary directory does not exist: ${TMPDIR}"
		exit 1
	elif [ ! -w "${TMPDIR}" ]; then
		echo "Temporary directory is not writable: ${TMPDIR}"
		exit 1
	elif [ ! -r "${TMPDIR}" ]; then
		echo "Temporary directory is not readable: ${TMPDIR}"
		exit 1
	elif [ "${TMPDIR}" = "${ROOTDIR}/tmp" -o "${TMPDIR}" = "${ROOTDIR}/var/tmp" ]; then
		echo "Do not use ${TMPDIR} as the temporary directory."
		echo "This directory will be used by rkhunter to contain system files, so it must be secure."
		exit 1
	elif [ "${TMPDIR}" = "${ROOTDIR}/etc" ]; then
		echo "Do not use ${TMPDIR} as the temporary directory."
		echo "This directory will be used by rkhunter to copy and delete certain system files."
		exit 1
	fi

	return
}


get_dbdir_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${DB_PATH}" ]; then
		DB_PATH=`echo "${DB_PATH}" | tr -s ' '`

		if [ "${DB_PATH}" = " " ]; then
			echo "Invalid --dbdir option - no directory name given."
			exit 1
		fi
	else
		DB_PATH=`grep '^DBDIR=' ${CONFIGFILE} | tail -1`

		if [ -n "${DB_PATH}" ]; then
			DB_PATH=`echo "${DB_PATH}" | sed -e 's/DBDIR=//' | tr -d '"' | tr -s ' '`

			if [ -z "${DB_PATH}" -o "${DB_PATH}" = " " ]; then
				echo "Invalid DBDIR configuration option - no directory name specified."
				exit 1
			fi
		else
			DB_PATH="${INSTALLDIR}/lib/rkhunter/db"
		fi
	fi

	#
	# Now check that the given option is useable.
	#

	if [ ! -d "${DB_PATH}" ]; then
		echo "Database directory does not exist: ${DB_PATH}"
		exit 1
	elif [ ! -w "${DB_PATH}" ]; then
		echo "Database directory is not writable: ${DB_PATH}"
		exit 1
	elif [ ! -r "${DB_PATH}" ]; then
		echo "Database directory is not readable: ${DB_PATH}"
		exit 1
	fi

	return
}


add_extra_dirs() {

	#
	# This functions takes care of any additional directories
	# that may exist on some systems. After the function is called
	# the value of EXTRA_DIRS must be added to whatever variable
	# is being used.
	#

	EXTRA_DIRS=""

	if [ "${OPERATING_SYSTEM}" = "SunOS" ]; then
		#
		# Add in some other directories, and those which
		# contain the Sun 'companion' software.
		#

		test -d /usr/sfw && EXTRA_DIRS="${EXTRA_DIRS} /usr/sfw/bin /usr/sfw/sbin /usr/sfw/libexec"

		test -d /opt/sfw && EXTRA_DIRS="${EXTRA_DIRS} /opt/sfw/bin /opt/sfw/sbin /opt/sfw/libexec"

		test -d /usr/xpg4/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/xpg4/bin"

		test -d /usr/ccs/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/ccs/bin"


		#
		# OpenSolaris distributions (e.g. BeleniX) may use
		# other directories.
		#

		test -d /usr/foss && EXTRA_DIRS="${EXTRA_DIRS} /usr/foss/bin /usr/foss/sbin /usr/foss/libexec"
	elif [ "${OPERATING_SYSTEM}" = "NetBSD" ]; then
		test -d /usr/pkg/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/pkg/bin"
		test -d /usr/pkg/sbin && EXTRA_DIRS="${EXTRA_DIRS} /usr/pkg/sbin"
		test -d /usr/pkg/libexec && EXTRA_DIRS="${EXTRA_DIRS} /usr/pkg/libexec"
	elif [ "${OPERATING_SYSTEM}" = "Darwin" ]; then
		#
		# Cater for Fink (Mac OS X) additional software.
		#

		test -d /sw/bin && EXTRA_DIRS="${EXTRA_DIRS} /sw/bin"
		test -d /sw/sbin && EXTRA_DIRS="${EXTRA_DIRS} /sw/sbin"
	fi


	#
	# Finally check if there are any optional
	# bin and sbin directories present.
	#

	test -d /usr/opt/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/opt/bin"
	test -d /usr/opt/sbin && EXTRA_DIRS="${EXTRA_DIRS} /usr/opt/sbin"
	test -d /opt/bin && EXTRA_DIRS="${EXTRA_DIRS} /opt/bin"
	test -d /opt/sbin && EXTRA_DIRS="${EXTRA_DIRS} /opt/sbin"

	return
}


get_bindir_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	USE_DFLT=0

	if [ -n "${BINPATHS}" ]; then
		BINPATHS=`echo "${BINPATHS}" | tr -s ' '`

		if [ "${BINPATHS}" = " " ]; then
			echo "Invalid --bindir option - no directory names given."
			exit 1
		fi
	else
		BINPATHS=`grep '^BINDIR=' ${CONFIGFILE} | tail -1`

		if [ -n "${BINPATHS}" ]; then
			BINPATHS=`echo "${BINPATHS}" | sed -e 's/BINDIR=//' | tr -d '"' | tr -s ' '`

			if [ -z "${BINPATHS}" -o "${BINPATHS}" = " " ]; then
				echo "Invalid BINDIR configuration option - no directory names specified."
				exit 1
			fi
		else
			USE_DFLT=1

			BINPATHS=$DFLT_BINPATHS


			#
			# Under SunOS /bin is a link to /usr/bin, so
			# there is no need to look in it.
			#

			if [ "${OPERATING_SYSTEM}" = "SunOS" -o "${OPERATING_SYSTEM}" = "AIX" ]; then
				if [ -h /bin ]; then
					B=""

					for DIR in ${BINPATHS}; do
						test "${DIR}" != "/bin" && B="${B} ${DIR}"
					done

					BINPATHS=`echo ${B} | sed -e 's/^ *//'`
				fi
			fi


			add_extra_dirs
			BINPATHS="${BINPATHS}${EXTRA_DIRS}"
		fi
	fi


	#
	# This is a simple check that each directory begins with
	# a '.' or '/', and that the directory exists.
	#

	for DIR in ${BINPATHS}; do
		if [ -z "`echo ${DIR} | grep '^[./]'`" ]; then
			echo "Invalid BINDIR directory: ${DIR}"
			exit 1
		elif [ ! -d "${DIR}" -a $USE_DFLT -eq 0 ]; then
			echo "Non-existent BINDIR directory: ${DIR}"
			exit 1
		fi
	done

	return
}


get_scriptdir_option() {

	#
	# Get the value from the configuration file, and do a simple
	# check on whether it is empty or a space.
	#
	# Note: The installer will set this option. As such there
	# is no default.
	#

	SCRIPT_PATH=`grep '^SCRIPTDIR=' ${CONFIGFILE} | tail -1`

	if [ -n "${SCRIPT_PATH}" ]; then
		SCRIPT_PATH=`echo "${SCRIPT_PATH}" | sed -e 's/SCRIPTDIR=//' | tr -d '"' | tr -s ' '`

		if [ -z "${SCRIPT_PATH}" -o "${SCRIPT_PATH}" = " " ]; then
			echo "Invalid SCRIPTDIR configuration option - no directory name specified."
			exit 1
		fi
	else
		echo "The SCRIPTDIR configuration option has not been set by the installer."
		exit 1
	fi

	#
	# Now check that the given option is useable.
	#

	if [ ! -d "${SCRIPT_PATH}" ]; then
		echo "Script directory does not exist: ${SCRIPT_PATH}"
		exit 1
	elif [ ! -r "${SCRIPT_PATH}" ]; then
		echo "Script directory is not readable: ${SCRIPT_PATH}"
		exit 1
	fi

	return
}


find_cmd() {

	#
	# This function performs a search of the PATH and BINPATHS
	# directories looking for the requested command. The full
	# pathname is returned if the command is found.
	#
	# If a full pathname is provided then we simply check that
	# it is executable.
	#

	CMD=$1

	test -z "${CMD}" && return

	if [ -n "`echo ${CMD} | grep '/'`" ]; then
		test -f "${CMD}" -a -x "${CMD}" && echo "${CMD}"
	else
		for CMDDIR in ${SPACEDPATH} ${BINPATHS}; do
			if [ -f "${CMDDIR}/${CMD}" -a -x "${CMDDIR}/${CMD}" ]; then
				echo "${CMDDIR}/${CMD}"
				return
			fi
		done
	fi

	return
}


get_rootdir_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${ROOTDIR}" ]; then
		ROOTDIR=`echo "${ROOTDIR}" | tr -s ' '`

		if [ "${ROOTDIR}" = " " ]; then
			echo "Invalid --rootdir option - no directory name given."
			exit 1
		fi
	else
		ROOTDIR=`grep '^ROOTDIR=' ${CONFIGFILE} | tail -1`

		if [ -n "${ROOTDIR}" ]; then
			ROOTDIR=`echo "${ROOTDIR}" | sed -e 's/ROOTDIR=//' | tr -d '"' | tr -s ' '`

			if [ -z "${ROOTDIR}" -o "${ROOTDIR}" = " " ]; then
				echo "Invalid ROOTDIR configuration option - no directory name specified."
				exit 1
			fi
		fi
	fi

	#
	# Now check that the given option is useable.
	#

	if [ -n "${ROOTDIR}" ]; then
		if [ ! -d "${ROOTDIR}" ]; then
			echo "The root directory does not exist: ${ROOTDIR}"
			exit 1
		elif [ ! -r "${ROOTDIR}" ]; then
			echo "The root directory is not readable: ${ROOTDIR}"
			exit 1
		fi
	fi

	return
}


get_mailonwarn_option() {

	#
	# Get the option from the configuration file, and do a simple
	# check on whether it is empty or a space.
	#

	MAILONWARNING=`grep '^MAIL-ON-WARNING=' ${CONFIGFILE} | tail -1`

	if [ -n "${MAILONWARNING}" ]; then
		MAILONWARNING=`echo "${MAILONWARNING}" | sed -e 's/MAIL-ON-WARNING=//' | tr -d '"' | tr -s ' '`

		if [ -z "${MAILONWARNING}" -o "${MAILONWARNING}" = " " ]; then
			echo "Invalid MAIL-ON-WARNING configuration option - no email address specified."
			exit 1
		fi
	fi


	if [ -n "${MAILONWARNING}" ]; then
		MAIL_CMD=`grep '^MAIL_CMD=' ${CONFIGFILE} | tail -1`

		if [ -n "${MAIL_CMD}" ]; then
			MAIL_CMD=`echo "${MAIL_CMD}" | sed -e 's/MAIL_CMD=//' | sed -e 's/^"\(.*\)"$/\1/' | tr -s ' '`

			if [ -z "${MAIL_CMD}" -o "${MAIL_CMD}" = " " ]; then
				echo "Invalid MAIL_CMD configuration option - no command specified."
				exit 1
			fi
		else
			MAIL_CMD="mail -s \"[rkhunter] Warnings found for \${HOST_NAME}\""
		fi


		#
		# Check that the mail command is executable.
		#

		MCMD=`echo "${MAIL_CMD}" | cut -d' ' -f1`
		MC=`find_cmd ${MCMD}`

		if [ -n "${MC}" ]; then
			#
			# We rebuild the command to use the full pathname.
			#

			MCMD=`echo "${MAIL_CMD}" | cut -d' ' -f2-`

			if [ -z "${MCMD}" -o "${MCMD}" = "${MAIL_CMD}" ]; then
				MAIL_CMD=$MC
			else
				MAIL_CMD="${MC} ${MCMD}"
			fi
		else
			echo "Invalid MAIL_CMD configuration option - command '${MCMD}' is non-existent or not executable."
			exit 1
		fi
	fi

	return
}


get_syslog_option() {

	#
	# First see if we want to use syslog or not from the command-line
	# or configuration file.
	#

	if [ -n "${USE_SYSLOG}" ]; then
		USE_SYSLOG=`echo "${USE_SYSLOG}" | tr -s ' '`

		if [ "${USE_SYSLOG}" = " " ]; then
			echo "Invalid --syslog option - no facility/priority names given."
			exit 1
		fi
	else
		USE_SYSLOG=`grep '^USE_SYSLOG=' ${CONFIGFILE} | tail -1`

		if [ -n "${USE_SYSLOG}" ]; then
			USE_SYSLOG=`echo "${USE_SYSLOG}" | sed -e 's/USE_SYSLOG=//' | tr -d '"' | tr -s ' '`

			if [ -z "${USE_SYSLOG}" -o "${USE_SYSLOG}" = " " ]; then
				echo "Invalid USE_SYSLOG configuration option - no value specified."
				exit 1
			fi
		fi
	fi


	#
	# If we are to use syslog, then get the facility and priority levels.
	# Additionally, test that they are valid.
	#

	if [ -n "${USE_SYSLOG}" ]; then
		USE_SYSLOG=`echo "${USE_SYSLOG}" | tr '[A-Z]' '[a-z]'`

		if [ "${USE_SYSLOG}" = "none" ]; then
			return
		elif [ -z "`echo \"${USE_SYSLOG}\" | grep '^[a-z][a-z0-7]*\.[a-z][a-z]*$'`" ]; then
			echo "Invalid syslog facility/priority value: ${USE_SYSLOG}"
			exit 1
		fi

		FOUND=0

		SYSLOG_F=`echo "${USE_SYSLOG}" | cut -d. -f1`
		SYSLOG_P=`echo "${USE_SYSLOG}" | cut -d. -f2`

		for RKHTMPVAR in auth authpriv cron daemon kern user local0 local1 local2 local3 local4 local5 local6 local7; do
			if [ "${SYSLOG_F}" = "${RKHTMPVAR}" ]; then
				FOUND=1
				break
			fi
		done

		if [ $FOUND -eq 0 ]; then
			echo "Invalid syslog facility name: ${SYSLOG_F}"
			exit 1
		fi


		FOUND=0

		for RKHTMPVAR in debug info notice warning err crit alert emerg; do
			if [ "${SYSLOG_P}" = "${RKHTMPVAR}" ]; then
				FOUND=1
				break
			fi
		done

		if [ $FOUND -eq 0 ]; then
			echo "Invalid syslog priority name: ${SYSLOG_P}"
			exit 1
		fi
	fi

	return
}


get_allow_rootssh_option() {

	#
	# See if the option is specified in the configuration file.
	# If it is then we do a simple check on whether it is empty,
	# a space, or not 0 or 1.
	#

	ALLOW_SSH_ROOT_USER=`grep '^ALLOW_SSH_ROOT_USER=' ${CONFIGFILE} | tail -1`

	if [ -n "${ALLOW_SSH_ROOT_USER}" ]; then
		ALLOW_SSH_ROOT_USER=`echo "${ALLOW_SSH_ROOT_USER}" | sed -e 's/ALLOW_SSH_ROOT_USER=//' | tr -d '"' | tr -s ' '`

		if [ -z "${ALLOW_SSH_ROOT_USER}" -o "${ALLOW_SSH_ROOT_USER}" = " " ]; then
			echo "Invalid ALLOW_SSH_ROOT_USER configuration option - no value specified."
			exit 1
		elif [ "${ALLOW_SSH_ROOT_USER}" != "0" -a "${ALLOW_SSH_ROOT_USER}" != "1" ]; then
			echo "Invalid ALLOW_SSH_ROOT_USER configuration option: ${ALLOW_SSH_ROOT_USER}"
			exit 1
		fi
	else
		ALLOW_SSH_ROOT_USER=0
	fi

	return
}


get_auto_x_option() {

	#
	# For the second colour set we first see if the auto X detect option
	# has been set. If it is set, and X is in use, then the second colour
	# set is used. If X is not in use, or the auto detect option is not
	# set, then we only use the second colour set if the command-line
	# option is used or it is configured in the configuration file.
	#

	if [ $AUTO_X_OPT -eq 0 ]; then
		AUTO_X_DTCT=`grep '^AUTO_X_DETECT=' ${CONFIGFILE} | tail -1`

		if [ -n "${AUTO_X_DTCT}" ]; then
			AUTO_X_DTCT=`echo "${AUTO_X_DTCT}" | sed -e 's/AUTO_X_DETECT=//' | tr -d '"' | tr -s ' '`

			if [ -z "${AUTO_X_DTCT}" -o "${AUTO_X_DTCT}" = " " ]; then
				echo "Invalid AUTO_X_DETECT configuration option - no value specified."
				exit 1
			elif [ "${AUTO_X_DTCT}" != "0" -a "${AUTO_X_DTCT}" != "1" ]; then
				echo "Invalid AUTO_X_DETECT configuration option: ${AUTO_X_DTCT}"
				exit 1
			fi
		else
			AUTO_X_DTCT=0
		fi
	fi


	if [ $AUTO_X_DTCT -eq 1 -a -n "$DISPLAY" ]; then
		CLRSET2=1
	fi


	if [ $CLRSET2 -eq 0 ]; then
		CLRSET2=`grep '^COLOR_SET2=' ${CONFIGFILE} | tail -1`

		if [ -n "${CLRSET2}" ]; then
			CLRSET2=`echo "${CLRSET2}" | sed -e 's/COLOR_SET2=//' | tr -d '"' | tr -s ' '`

			if [ -z "${CLRSET2}" -o "${CLRSET2}" = " " ]; then
				echo "Invalid COLOR_SET2 configuration option - no value specified."
				exit 1
			elif [ "${CLRSET2}" != "0" -a "${CLRSET2}" != "1" ]; then
				echo "Invalid COLOR_SET2 configuration option: ${CLRSET2}"
				exit 1
			fi
		else
			CLRSET2=0
		fi
	fi

	return
}


get_enable_option() {

# jh - add enable count, if one cmd given then don't keypresspause
	#
	# If the option is not specified on the command-line, then
	# get it from the configuration file. We validate the test
	# names given against the list of known test names. By default
	# all tests are enabled.
	#

	if [ $ENDIS_OPT -eq 1 ]; then
		if [ -n "${ENABLE_TESTS}" ]; then
			ENABLE_TESTS=`echo "${ENABLE_TESTS}" | tr ',' ' ' | tr -s ' '`

			if [ "${ENABLE_TESTS}" = " " ]; then
				echo "Invalid --enable option - no test names given."
				exit 1
			fi
		fi
	else
		ENABLE_TESTS=`grep '^ENABLE_TESTS=' ${CONFIGFILE} | tail -1`

		if [ -n "${ENABLE_TESTS}" ]; then
			ENABLE_TESTS=`echo "${ENABLE_TESTS}" | sed -e 's/ENABLE_TESTS=//' | tr -d '"' | tr ',' ' ' | tr -s ' '`

			if [ -z "${ENABLE_TESTS}" -o "${ENABLE_TESTS}" = " " ]; then
				echo "Invalid ENABLE_TESTS configuration option - no test names specified."
				exit 1
			fi
		fi
	fi

	test -z "${ENABLE_TESTS}" && ENABLE_TESTS="all"


	#
	# We now need to look for group names in our list, and expand
	# them to the individual test names. This allows us to then
	# check against specific test names as well as group names.
	# We also need to check if a given test name is part of a group.
	# If it is, then we must add the group name.
	#

	for TEST_NAME in ${ENABLE_TESTS}; do
		if [ "${TEST_NAME}" = "all" ]; then
			ENABLE_TESTS="all"
			break
		fi

		for RKHTMPVAR in ${GROUPED_TESTS}; do
			GROUP_NAME=`echo "${RKHTMPVAR}" | cut -d: -f1`

			if [ -n "`echo \"${RKHTMPVAR}\" | grep ':'`" ]; then
				GROUP_TESTS=`echo "${RKHTMPVAR}" | cut -d: -f2-`
			else
				GROUP_TESTS=""
			fi

			if [ "${TEST_NAME}" = "${GROUP_NAME}" ]; then
				ENABLE_TESTS="${ENABLE_TESTS} `echo \"${GROUP_TESTS}\" | tr ':' ' '`"
				break
			elif [ -z "${GROUP_TESTS}" ]; then
				continue
			elif [ -n "`echo \"${GROUP_TESTS}\" | egrep \"(^|:)${TEST_NAME}(:|$)\"`" ]; then
				ENABLE_TESTS="${ENABLE_TESTS} ${GROUP_NAME}"
			fi
		done
	done


	#
	# Check that the names we have been given are valid.
	#

	for TEST_NAME in ${ENABLE_TESTS}; do
		if [ "${TEST_NAME}" = "none" ]; then
			echo "'none' cannot be used in the enable test list."
			exit 1
		elif [ -z "`echo \"all ${KNOWN_TESTS}\" | egrep \"(^| )${TEST_NAME}( |$)\"`" ]; then
			echo "Unknown enable test name given: ${TEST_NAME}"
			exit 1
		fi
	done

	return
}


get_disable_option() {

	#
	# If the option is not specified on the command-line, then
	# get it from the configuration file. We validate the test
	# names given against the list of known test names. By default
	# no tests are disabled.
	#
	# Note: disabled tests are always compared against the list
	# of enabled tests. Hence, if we used
	#      'rkhunter -c --enable system_commands --disable apps'
	# then only the system command tests are run. Any other test is
	# not run because it is not in the '--enable' list. As such
	# the '--disable' option in the example above is not necessary.
	#

	if [ $ENDIS_OPT -eq 1 ]; then
		if [ -n "${DISABLE_TESTS}" ]; then
			DISABLE_TESTS=`echo "${DISABLE_TESTS}" | tr ',' ' ' | tr -s ' '`

			if [ "${DISABLE_TESTS}" = " " ]; then
				echo "Invalid --disable option - no test names given."
				exit 1
			fi
		fi
	else
		DISABLE_TESTS=`grep '^DISABLE_TESTS=' ${CONFIGFILE} | tail -1`

		if [ -n "${DISABLE_TESTS}" ]; then
			DISABLE_TESTS=`echo "${DISABLE_TESTS}" | sed -e 's/DISABLE_TESTS=//' | tr -d '"' | tr ',' ' ' | tr -s ' '`

			if [ -z "${DISABLE_TESTS}" -o "${DISABLE_TESTS}" = " " ]; then
				echo "Invalid DISABLE_TESTS configuration option - no test names specified."
				exit 1
			fi
		fi
	fi

	test -z "${DISABLE_TESTS}" && DISABLE_TESTS="none"


	#
	# Note that we do not need to check the disabled test names
	# against the group names. If a disabled test name does not appear
	# in the enabled list then it will, by default, be ignored. If
	# a group name appears in the enabled and disabled lists, then
	# it will be disabled.
	#
	# Check that the names we have been given are valid.
	#

	for TEST_NAME in ${DISABLE_TESTS}; do
		if [ "${TEST_NAME}" = "all" ]; then
			echo "'all' cannot be used in the disable test list."
			exit 1
		elif [ "${TEST_NAME}" = "none" ]; then
			DISABLE_TESTS="none"
			break
		elif [ -z "`echo \"all none ${KNOWN_TESTS}\" | egrep \"(^| )${TEST_NAME}( |$)\"`" ]; then
			echo "Unknown disable test name given: ${TEST_NAME}"
			exit 1
		fi
	done

	return
}


get_if_prelinked() {

	#
	# If the system appears to be using prelinking, but no
	# prelink command can be found, then we simply skip the
	# hash check. We do not exit because this is a suspicious
	# circumstance, and it may be better to check the system
	# regardless of the hash check.
	#
	LIBSAFE_TEST1=""
	LIBSAFE_TEST2=""

	if [ -f "${ROOTDIR}/etc/prelink.cache" ]; then
		PRELINK_CMD=`find_cmd prelink`

		# Test (twice) for existance of Libsafe since this seems to
		# riddle prelink test results with "dependency cycle" errors.
		# Don't test for existance of /lib/libsafe since it may be
		# installed elsewhere.
		# If Libsafe is found *and* this is a prelink system, we'll
		# skip the prelink test.
		#
		if [ -f "${ROOTDIR}/etc/ld.so.preload" ]; then
			LIBSAFE_TEST1=`grep libsafe ${ROOTDIR}/etc/ld.so.preload 2>&1`
		fi

		if [ -n "${LDD_CMD}" -a -f "${ROOTDIR}/lib/libdl.so.?" ]; then
			LIBSAFE_TEST2=`${LDD_CMD} ${ROOTDIR}/lib/libdl.so.? | grep libsafe 2>&1`
		fi

		if [ -n "${PRELINK_CMD}" -a -z "${LIBSAFE_TEST1}" -a -z "${LIBSAFE_TEST2}" ]; then
			PRELINKED=1

			RUNCON_CMD=`find_cmd runcon`

			if [ -n "${RUNCON_CMD}" ]; then
				PRELINK_CMD="${RUNCON_CMD} -t unconfined_t -- ${PRELINK_CMD}"
			fi
		elif [ -n "${PRELINK_CMD}" -a -n "${LIBSAFE_TEST1}" -a -n "${LIBSAFE_TEST2}" ]; then
			SKIP_GOODHASH_MSG=6
		else
			SKIP_GOODHASH_MSG=1
		fi
	fi

	return
}


get_hash_function() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${HASH_FUNC}" ]; then
		HASH_FUNC=`echo "${HASH_FUNC}" | tr -s ' '`

		if [ "${HASH_FUNC}" = " " ]; then
			echo "Invalid --hash option - no command given."
			exit 1
		fi
	else
		HASH_FUNC=`grep '^HASH_FUNC=' ${CONFIGFILE} | tail -1`

		if [ -n "${HASH_FUNC}" ]; then
			HASH_FUNC=`echo "${HASH_FUNC}" | sed -e 's/HASH_FUNC=//' | sed -e 's/^"\(.*\)"$/\1/' | tr -s ' '`

			if [ -z "${HASH_FUNC}" -o "${HASH_FUNC}" = " " ]; then
				echo "Invalid HASH_FUNC configuration option - no command specified."
				exit 1
			fi
		fi
	fi


	#
	# At this point we have either been given a hash function
	# command, one of the reserved words 'SHA1' or 'MD5', or
	# nothing. For the reserved words we must find the SHA1 or
	# MD5 command or use the supplied perl scripts.
	#

	if [ -z "${HASH_FUNC}" -o "${HASH_FUNC}" = "SHA1" ]; then
		HF=`find_cmd sha1sum`

		if [ -z "${HF}" ]; then
			HF=`find_cmd sha1`

			if [ "${HF}" = "/usr/bin/sha1" -a "${OPERATING_SYSTEM}" = "NetBSD" ]; then
				HF="${HF} -n"
			fi
		fi

		if [ -z "${HF}" -a -n "${PERL_CMD}" ]; then
			MOD_INSTALLED=`${PERL_CMD} ${SCRIPT_PATH}/check_modules.pl Digest::SHA1 2>&1 | grep 'Digest::SHA1 installed'`

			if [ -n "${MOD_INSTALLED}" ]; then
				HASH_FUNC="${PERL_CMD} ${SCRIPT_PATH}/filehashsha1.pl"
			else
				HASH_FUNC=""
			fi
		else
			HASH_FUNC=$HF
		fi
	fi


	#
	# If we still have no hash function, then look for an MD5 command.
	#

	if [ -z "${HASH_FUNC}" -o "${HASH_FUNC}" = "MD5" ]; then
		HF=`find_cmd md5sum`

		if [ -z "${HF}" ]; then
			HF=`find_cmd md5`

			if [ "${OPERATING_SYSTEM}" = "NetBSD" -a "${HF}" = "/usr/bin/md5" ]; then
				HF="${HF} -n"
			fi
		fi

		if [ -z "${HF}" -a -n "${PERL_CMD}" ]; then
			MOD_INSTALLED=`${PERL_CMD} ${SCRIPT_PATH}/check_modules.pl Digest::MD5 2>&1 | grep 'Digest::MD5 installed'`

			if [ -n "${MOD_INSTALLED}" ]; then
				HASH_FUNC="${PERL_CMD} ${SCRIPT_PATH}/filehashmd5.pl"
			else
				HASH_FUNC=""
			fi
		else
			HASH_FUNC=$HF
		fi
	fi


	#
	# A final check that the command is actually executable.
	# This will ensure that the sha1/md5 perl scripts have been
	# installed correctly, should they be needed.
	#

	if [ -n "${HASH_FUNC}" ]; then
		HCMD=`echo "${HASH_FUNC}" | cut -d' ' -f1`
		HF=`find_cmd ${HCMD}`

		if [ -n "${HF}" ]; then
			#
			# We rebuild the command to use the full pathname.
			#

			HCMD=`echo "${HASH_FUNC}" | cut -d' ' -f2-`

			if [ -z "${HCMD}" -o "${HCMD}" = "${HASH_FUNC}" ]; then
				HASH_FUNC=$HF
			else
				HASH_FUNC="${HF} ${HCMD}"
			fi
		else
			echo "Invalid hash option - command '${HCMD}' is non-existent or not executable."
			exit 1
		fi
	fi

	return
}


get_configfile_options() {

	#
	# We call separate functions to process each option. The option
	# is checked first to see if it has been given on the command-line,
	# and, if not, then if it is specified in the configuration file.
	# Note that some of these functions are in a specific order. If you
	# change them around, then make sure the functions still work
	# correctly.
	#

	get_installdir_option

	get_bindir_option

	get_logfile_option

	get_rootdir_option

	get_tmpdir_option

	get_dbdir_option

	get_language_option

	get_scriptdir_option

	get_mailonwarn_option


	#
	# Now that we have processed BINDIR, we will recheck the
	# required commands.
	#
	# Before proceeding too far we also check that we have certain
	# commands available. Typically these are commands which might
	# not have been installed as part of the core system, but are
	# used by RKH. These commands are not 'required' though.
	#

	check_required_commands "${BINPATHS}"

	check_commands


	#
	# Some options are only required when checking the system.
	#

	if [ $CHECK -eq 1 -o $UPDATE -eq 1 ]; then
		get_auto_x_option
	fi

	if [ $CHECK -eq 1 ]; then
		get_allow_rootssh_option

		get_syslog_option


		#
		# See if we are to only perform specific tests.
		#

		get_enable_option
		get_disable_option

		check_test hashes && GOOD_HASH_ENABLED=1
	fi


	#
	# We only need the hash function option if we are going to
	# be checking the system or updating the hash database.
	#

	if [ $GOOD_HASH_ENABLED -eq 1 -o $HASH_UPDATE -eq 1 ]; then

		#
		# For the file hash check we need to find out if we are
		# a prelinked system, and if so, then find out which
		# hash function to use. We also need to find the 'stat'
		# command.
		#

		get_if_prelinked

		test $SKIP_GOODHASH_MSG -eq 0 && get_hash_function
	fi

	return
}


rkh_dat_set_version() {

	#
	# This function calculates and writes out the 'Version:' value
	# for the rkhunter.dat file. It looks for an old value, and adds
	# one to it. If there is no value then simply start at one.
	#

	TODAY=`date +%Y%m%d`

	OLDVER=`grep -i '^Version:' ${RKHDAT_FILE} 2>/dev/null | tail -1 | cut -d: -f2`

	if [ -n "${OLDVER}" ]; then
		OLDVER=`echo "${OLDVER}" | cut -c9-10`

		if [ "${OLDVER}" = "99" ]; then
			NEWVER="00"
		else
			NEWVER=`expr ${OLDVER} + 1`
			test $NEWVER -lt 10 && NEWVER="0${NEWVER}"
		fi
	else
		NEWVER="00"
	fi

	echo "Version:${TODAY}${NEWVER}" >>${RKHDAT_FILE}

	return
}


rkh_dat_get_os_info() {

	#
	# This function obtains information about the local computer
	# system. This is then written into the rkhunter.dat file
	# using a simple 'keyword:<value>' format. The OSNAME and
	# ARCH values are not important, but are simply used to check
	# whether they have changed since RKH was last run.
	#
	# Obtaining the OSNAME is somewhat tricky. There is no sure
	# way of finding the information, so we have to use some tricks
	# to locate the correct file. First we look for certain specific
	# O/S release files, and then at the /etc/release file, but not
	# if it is a link. Next we look for a generic /etc/*-release
	# file, again not as a link. This should find most O/S versions.
	# Overall this should also save users having to ask us to support
	# their O/S. In other cases, we will have to ask what file does
	# contain their O/S release information.
	#

	ARCH=`uname -m 2>/dev/null`

	REL_FILES="${ROOTDIR}/etc/lsb-release ${ROOTDIR}/etc/debian_version ${ROOTDIR}/etc/slackware-version ${ROOTDIR}/var/ipcop/general-functions.pl ${ROOTDIR}/etc/release ${ROOTDIR}/etc/*-release"

	for FNAME in ${REL_FILES}; do
		if [ -f "${FNAME}" -a ! -h "${FNAME}" ]; then
			RELEASE=$FNAME

			case "${RELEASE}" in
			${ROOTDIR}/etc/lsb-release)
				OSNAME=`cat ${RELEASE} | grep '^DISTRIB_DESCRIPTION=' | sed -e 's/DISTRIB_DESCRIPTION=//' | tr -d '"'`
				;;
			${ROOTDIR}/etc/gentoo-release)
				GENTOO=1
				if [ -h ${ROOTDIR}/etc/make.profile ]; then
					OSNAME="Gentoo `ls -l ${ROOTDIR}/etc/make.profile 2>/dev/null | sed -e 's/^.*\/\([^\/]*\)$/\1/'`"
				else
					OSNAME=`head -n 1 ${RELEASE} | tr -s ' '`
				fi
				;;
			${ROOTDIR}/var/ipcop/general-functions.pl)
				OSNAME=`grep 'version *=' ${RELEASE} | head -n 1`
				;;
			${ROOTDIR}/etc/debian_version)
				OSNAME="Debian `cat ${RELEASE}`"
				;;
			*)
				OSNAME=`head -n 1 ${RELEASE} | tr -s ' '`
				;;
			esac

			test "${OSNAME}" = " " && OSNAME=""


			#
			# If we have a release file but the first line seems
			# to be blank, we take a quick look at the second
			# line.
			#

			if [ -z "${OSNAME}" -a `wc -l ${RELEASE} | awk '{ print $1 }'` -gt 1 ]; then
				OSNAME=`head -n 2 ${RELEASE} | tail -1 | tr -s ' '`
			fi

			test -n "${OSNAME}" && break
		fi
	done


	test -z "${OSNAME}" && RELEASE=""

	case "${OPERATING_SYSTEM}" in
	SunOS)
		ARCH=`uname -p 2>/dev/null`
		;;
	FreeBSD)
		ARCH=`sysctl -n hw.machine_arch 2>/dev/null`
		OSNAME=`uname -v 2>/dev/null | cut -d' ' -f1,2`
		;;
	OpenBSD)
		OSNAME="OpenBSD `uname -r 2>/dev/null`"
		;;
	Darwin)
		OSNAME=`sw_vers 2>/dev/null | grep '^ProductName:' | sed -e 's/ProductName: *//'`
		OSNAME="${OSNAME} `sw_vers 2>/dev/null | grep '^ProductVersion:' | sed -e 's/ProductVersion: *//'`"
#		OSNAME="${OSNAME} `sysctl kern.version 2>/dev/null | sed -e 's/^kern.version = //' | cut -d: -f1`"
		;;
	AIX)
		ARCH=`uname -p 2>/dev/null`
		OSNAME="IBM AIX `oslevel 2>/dev/null`"
		;;
	esac

	return
}


rkh_dat_set_file_hash() {

	#
	# This function determines various bits of information about
	# the files to be checked. The format in the rkhunter.dat file is:
	#
	#     File:<pathname>:<hash value>:<inode>:<permissions>:<uid>:<gid>:
	#          <date/time modified>
	#

	#
	# To save time in the loops below, we determine the exact commands
	# required before entering them.
	#

	FILE_COUNT=0
	DIR_FILE_COUNT=0

	display --to LOG --type PLAIN SETFILEHASH_FILE_START


	if [ -n "`echo ${STAT_CMD} | grep '\.pl$'`" ]; then
		SCMD="${STAT_CMD} --modeoct --raw --mode --ino -uid -gid -Mtime"
	else
		if [ "${OPERATING_SYSTEM}" = "NetBSD" ]; then
			SCMD="${STAT_CMD} -f '%i %Mp%Lp %u %g %m:'"
		else
			SCMD="${STAT_CMD} --format='%i 0%a %u %g %Y:'"
		fi
	fi

	if [ $PRELINKED -eq 0 ]; then
		HCMD=$HASH_FUNC
	else
		if [ -n "`echo ${HASH_FUNC} | grep 'md5'`" ]; then
			HCMD="${PRELINK_CMD} --verify --md5"
		else
			HCMD="${PRELINK_CMD} --verify --sha"
		fi
	fi

	if [ "${OPERATING_SYSTEM}" = "OpenBSD" -a "${HCMD}" = "/bin/md5" ]; then
		HSH_FLD_IDX=4
	else
		HSH_FLD_IDX=1
	fi


	#
	# Now loop through the directories looking for the files.
	#

	for DIR in ${HASHDIRS}; do
		test ! -d "${DIR}" && continue

		DIR_FILE_COUNT=0

		for FNAME in ${HASHFILES}; do
			test ! -f "${DIR}/${FNAME}" -o -h "${DIR}/${FNAME}" && continue

			FILE_COUNT=`expr ${FILE_COUNT} + 1`
			DIR_FILE_COUNT=`expr ${DIR_FILE_COUNT} + 1`

			SYSHASH=`${HCMD} ${DIR}/${FNAME} 2>/dev/null | cut -d' ' -f $HSH_FLD_IDX`

			FDATA=`eval ${SCMD} ${DIR}/${FNAME} 2>/dev/null | tr ' ' ':'`

			echo "File:${DIR}/${FNAME}:${SYSHASH}:${FDATA}" >>${RKHDAT_FILE}
		done

		display --to LOG --type INFO SETFILEHASH_DIR_FILE_COUNT $DIR_FILE_COUNT "${DIR}"
	done

	display --to SCREEN+LOG --type INFO SETFILEHASH_FILE_COUNT $FILE_COUNT

	return
}


get_temp_file() {

	#
	# This function will create an empty, unique temporary file.
	#
	# It takes one argument which is the pathname for the file,
	# excluding the suffix. The function will return the pathname
	# in TEMPFILE.
	#

	TEMPFILE=""

	TEMPFILE_BASE=$1


	if [ -n "${MKTEMP_CMD}" ]; then
		TEMPFILE=`${MKTEMP_CMD} ${TEMPFILE_BASE}.XXXXXX`
	elif [ -n "$RANDOM" ]; then
		TEMPFILE="${TEMPFILE_BASE}.$RANDOM"
	else
		TEMPFILE="${TEMPFILE_BASE}.`date +%N%s%N`"
	fi


	#
	# Remove the file just in case it does already exist!
	#

	rm -f ${TEMPFILE} >/dev/null 2>&1

	return
}


do_hash_update() {

	#
	# This function updates the local hosts rkhunter.dat file
	# with O/S information and file hash values.
	#

	display --to LOG --type INFO --nl HASHUPD_START

	#
	# First we need to get a temporary file name to use.
	#

	get_temp_file "${TMPDIR}/rkhunter.dat"
	RKHDAT_FILE=$TEMPFILE

	display --to LOG --type INFO CREATED_TEMP_FILE "${RKHDAT_FILE}"


	#
	# We now start to write out information about this system
	# to the file. Some information we already have available,
	# but for others we call functions to obtain what is wanted.
	#

	ARCH=""
	OSNAME=""
	RELEASE=""

	rkh_dat_set_version


	display --to LOG --type PLAIN HASHUPD_OSINFO_START

	rkh_dat_get_os_info

	echo "Host:${HOST_NAME}" >>${RKHDAT_FILE}

	if [ -n "${ARCH}" ]; then
		echo "Arch:${ARCH}" >>${RKHDAT_FILE}
		display --to LOG --type INFO HASHUPD_ARCH_FOUND "${ARCH}"
	fi

	if [ -n "${RELEASE}" ]; then
		display --to LOG --type INFO HASHUPD_REL_FILE "${RELEASE}"
	else
		display --to LOG --type INFO HASHUPD_NO_REL_FILE
		display --to LOG --type PLAIN HASHUPD_NO_REL_FILE2 "      `ls -d ${ROOTDIR}/etc/*release* ${ROOTDIR}/etc/*version* 2>/dev/null | tr '\n' ' '`"
	fi

	if [ -n "${OSNAME}" ]; then
		echo "OS:${OSNAME}" >>${RKHDAT_FILE}
		display --to LOG --type INFO HASHUPD_OSNAME_FOUND "${OSNAME}"
	fi

	if [ $PRELINKED -eq 0 ]; then
		echo "Prelinked:No" >>${RKHDAT_FILE}
	else
		echo "Prelinked:Yes" >>${RKHDAT_FILE}
	fi


	rkh_dat_set_file_hash


	#
	# Now put the new rkhunter.dat file in place.
	#

	cp -f ${DB_PATH}/rkhunter.dat ${DB_PATH}/rkhunter.dat.old >/dev/null 2>&1
	cp ${RKHDAT_FILE} ${DB_PATH}/rkhunter.dat >/dev/null 2>&1
	RKHTMPVAR=$?

	if [ $RKHTMPVAR -ne 0 ]; then
		RET_CODE=1
		display --to SCREEN+LOG --type WARNING HASHUPD_ERROR $RKHTMPVAR
	else
		display --to LOG --type INFO HASHUPD_NEW_DAT_FILE
	fi

	rm -f ${RKHDAT_FILE} >/dev/null 2>&1

	return
}


get_next_mirror() {

	#
	# This function will obtain the next mirror in the mirrors file
	# if no mirror is currently being used. It then rotates the
	# mirrors in the mirrors file.
	#


	#
	# Return if there is no mirrors file.
	#

	if [ ! -f "${DB_PATH}/mirrors.dat" ]; then
		display --to LOG --type INFO MIRRORS_NO_FILE "${DB_PATH}/mirrors.dat"
		return
	fi


	#
	# Return if there are no defined mirrors.
	#

	MIRROR=`grep -i '^mirror=http://' ${DB_PATH}/mirrors.dat | head -n 1 | cut -d= -f2`

	if [ -z "${MIRROR}" ]; then
		display --to LOG --type INFO MIRRORS_NO_MIRRORS "${DB_PATH}/mirrors.dat"
		return
	fi


	#
	# Now get the version number of the mirrors file. If the version
	# does not exist or is corrupt, then we reset it to zero. This
	# then allows the file to be updated next time the '--update'
	# option is used.
	#

	MIRRORSVERSION=`egrep -i '^version:[0-9]{10}$' ${DB_PATH}/mirrors.dat | tail -1`

	if [ -z "${MIRRORSVERSION}" ]; then
		display --to LOG --type INFO MIRRORS_NO_VERSION "${DB_PATH}/mirrors.dat"
		MIRRORSVERSION="version:0000000000"
	fi


	#
	# Next get the remaining mirrors.
	#

	OTHERMIRRORS=`grep '^mirror=http://' ${DB_PATH}/mirrors.dat | grep -v ${MIRROR}`


	#
	# We need to get a temporary file name to use.
	#

	get_temp_file "${TMPDIR}/mirrors.dat"
	MIRRORS_FILE=$TEMPFILE

	display --to LOG --type INFO CREATED_TEMP_FILE "${MIRRORS_FILE}"


	#
	# Output to the temporary file the mirrors version, the other
	# mirrors, and finally the mirror we are about to use.
	#

	echo "${MIRRORSVERSION}" >${MIRRORS_FILE}

	for M in ${OTHERMIRRORS}; do
		echo "${M}" >>${MIRRORS_FILE}
	done;

	echo "mirror=${MIRROR}" >>${MIRRORS_FILE}


	#
	# Move the new file into place, and delete the temporary file.
	#

	cat ${MIRRORS_FILE} >${DB_PATH}/mirrors.dat

	rm -f ${MIRRORS_FILE} >/dev/null 2>&1

	display --to LOG --type INFO MIRRORS_ROTATED "${DB_PATH}/mirrors.dat"

	return
}


download_file() {

	# This function downloads a specified file. It takes three parameters:
	#     1=mirror, 2=url, 3=output file
	#
	# The function sets a return code (DNLOADERR).
	#

	#
	# We loop round through the mirrors until the file is downloaded.
	# We do this by first seeing how many mirrors are available. Then
	# we call a function to get the next mirror, which also rotates
	# the mirror file. If a mirror has already been set, then that
	# mirror is used. That way, in effect, once we find a good mirror
	# then it will be used for all the downloads.
	#

	MIRROR=$1
	URL=$2
	OUTPUT_FILE=$3

	DNLOADERR=0
	MIRROR_COUNT=0

	if [ -f "${DB_PATH}/mirrors.dat" ]; then
		MIRROR_COUNT=`grep -i '^mirror=http://' ${DB_PATH}/mirrors.dat | wc -l`
	fi

	test $MIRROR_COUNT -eq 0 && MIRROR_COUNT=1


	while test $MIRROR_COUNT -gt 0; do
		MIRROR_COUNT=`expr $MIRROR_COUNT - 1`

		if [ -z "${MIRROR}" ]; then
			get_next_mirror
			test -z "${MIRROR}" && MIRROR="http://rkhunter.sourceforge.net"
		fi


		#
		# Now we can download the data into the temporary file.
		#

		# uns - WGET_CMD (cmd, version tested, comments):
		#       wget, *, none.
		#       bget, 1.2, appends output.
		#       curl, 7.15.3: none.
		#       links/elinks, 0.4.2, decompresses output.
		#       lynx, 2.8.5dev.7, decompresses output.

		CMD=""
		DNLOADERR=0

		rm -f ${OUTPUT_FILE} >/dev/null 2>&1

		if [ -n "${WGET_CMD}" ]; then
			CMD="${WGET_CMD} -q -O ${OUTPUT_FILE} ${MIRROR}${URL}"
		elif [ -n "${CURL_CMD}" ]; then
			CMD="${CURL_CMD} --fail --output ${OUTPUT_FILE} ${MIRROR}${URL} 2>/dev/null"
		elif [ -n "${BGET_CMD}" ]; then
			CMD="${BGET_CMD} --out ${OUTPUT_FILE} ${MIRROR}${URL} 2>/dev/null"
		elif [ -n "${ELINKS_CMD}" ]; then
			CMD="${ELINKS_CMD} -no-home 1 -source ${MIRROR}${URL} >${OUTPUT_FILE}"
		elif [ -n "${LINKS_CMD}" ]; then
			CMD="${LINKS_CMD} -no-home 1 -source ${MIRROR}${URL} >${OUTPUT_FILE}"
		elif [ -n "${LYNX_CMD}" ]; then
			CMD="${LYNX_CMD} -source ${MIRROR}${URL} >${OUTPUT_FILE}"
		elif [ -n "${GET_CMD}" ]; then
			CMD="${GET_CMD} ${MIRROR}${URL} >${OUTPUT_FILE}"
		fi

		display --to LOG --type INFO DOWNLOAD_CMD "${CMD}"

		eval ${CMD}
		DNLOADERR=$?

		test $DNLOADERR -gt 1 && DNLOADERR=1


		#
		# Some of these commands do not set the return code. As such we
		# have to look in the output file to see if an error occurred.
		# We only do this for version files though.
		#

		if [ $DNLOADERR -eq 0 -a -n "`echo \"${URL}\" | grep '\.ver$'`" ]; then
			if [ -z "`grep '^[.0-9]*$' ${OUTPUT_FILE}`" ]; then
				DNLOADERR=1
			fi
		fi

		test ! -s "${OUTPUT_FILE}" && DNLOADERR=1

		if [ $DNLOADERR -eq 0 ]; then
			break
		elif [ $MIRROR_COUNT -gt 0 ]; then
			MIRROR=""
			display --to LOG --type INFO DOWNLOAD_FAIL $MIRROR_COUNT
		fi
	done

	return $DNLOADERR
}


do_update() {

	#
	# This function checks to see if any of the supplied RKH
	# *.dat files needs updating. If it does, then the file is
	# overwritten with the new version.
	#

	display --to SCREEN+LOG --type PLAIN --nl UPDATE_START


	#
	# First we need to get a temporary file name to use.
	#

	get_temp_file "${TMPDIR}/rkhunter.upd"
	RKHUPD_FILE=$TEMPFILE

	display --to LOG --type INFO CREATED_TEMP_FILE "${RKHUPD_FILE}"


	#
	# Now we loop round through the files we need to check. Each file
	# will use the first mirror, and if necessary loop through the
	# remaining mirrors until the file is downloaded. In theory this
	# could take some time if the mirror sites are all experiencing
	# problems and this is affecting all the files.
	#
	# For each file we look at the current version number. If there
	# is a problem doing this, then we just try and download a new
	# copy of the file. If the version number is okay, then we
	# first download the '.ver' file to find the latest version
	# number. If that is successful, we then update the file if
	# necessary.
	#

	MIRROR=""

	UPDFILE_LIST="mirrors.dat programs_bad.dat programs_good.dat backdoorports.dat"

	for UPDFILE in ${UPDFILE_LIST}; do
		LATEST_VERS=""

		if [ -f "${DB_PATH}/${UPDFILE}" -a -s "${DB_PATH}/${UPDFILE}" ]; then
			PROG_VERS=`egrep -i '^version:[0-9]{10}$' ${DB_PATH}/${UPDFILE} | tail -1 | sed -e 's/version://'`

			if [ -z "${PROG_VERS}" ]; then
				VERSION_FILE=0
				display --to LOG --type INFO UPDATE_FILE_NO_VERS "${UPDFILE}"
			else
				VERSION_FILE=1
			fi
		else
			VERSION_FILE=0
			display --to LOG --type INFO UPDATE_FILE_MISSING "${UPDFILE}"
		fi


		#
		# We now loop round once or twice. If we need a version file,
		# then that is downloaded and the versions compared. If we
		# determine to get the compressed file immediately, or if the
		# versions indicate that an update is available. Then we loop
		# round again to get the file.
		#

		while true; do
			if [ $VERSION_FILE -eq 1 ]; then
				URL="/${UPDFILE}.ver"
			else
				#
				# Note: To avoid a backward incompatability we
				# have to get the actual gzip file from a
				# specific directory which previous versions
				# do not use.
				#

				URL="/1.3/${UPDFILE}.gz"
				RKHUPD_FILE="${RKHUPD_FILE}.gz"
			fi

			download_file "${MIRROR}" "${URL}" "${RKHUPD_FILE}"


			#
			# Now compare the current and downloaded version
			# numbers, and download the new file if necessary.
			#

			if [ $? -eq 0 ]; then
				if [ $VERSION_FILE -eq 1 ]; then
					LATEST_VERS=`cat ${RKHUPD_FILE} 2>/dev/null`

					display --to LOG --type INFO VERSIONCHECK_CURRENT "${PROG_VERS}"
					display --to LOG --type INFO VERSIONCHECK_LATEST "${LATEST_VERS}"

					if [ -z "${PROG_VERS}" -o -z "${LATEST_VERS}" ]; then
						RET_CODE=1

						display --to SCREEN+LOG --type WARNING --screen-indent 2 --color RED --result VCHK_FAILED UPDATE_CHECKING_FILE "${UPDFILE}"

						display --to LOG --type WARNING VERSIONCHECK_CONV_FAIL "${PROG_VERS}" "${LATEST_VERS}"

						break
					elif [ $PROG_VERS -lt $LATEST_VERS ]; then
						test $RET_CODE -eq 0 && RET_CODE=2

						#
						# We now need to download the
						# actual file, and then display
						# the results of that download.
						#

						VERSION_FILE=0

						display --to LOG --type INFO VERSIONCHECK_UPDT_AVAIL
						rm -f ${RKHUPD_FILE} >/dev/null 2>&1

						continue
					else
						display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color GREEN --result NO_UPD UPDATE_CHECKING_FILE "${UPDFILE}"
						break
					fi
				fi


				#
				# Updated files need to be uncompressed.
				#

				if [ $VERSION_FILE -eq 0 ]; then
					${GUNZIP_CMD} ${RKHUPD_FILE} >/dev/null 2>&1

					if [ $? -eq 0 ]; then
						RKHUPD_FILE=`echo "${RKHUPD_FILE}" | sed -e 's/\.gz$//'`
						cat ${RKHUPD_FILE} >${DB_PATH}/${UPDFILE}

						display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color GREEN --result UPD UPDATE_CHECKING_FILE "${UPDFILE}"
					else
						#
						# Make sure that nothing is
						# left lying around. Get rid
						# of both the compressed and
						# uncompressed files.
						#

						rm -f ${RKHUPD_FILE} >/dev/null 2>&1

						display --to SCREEN+LOG --type WARNING --screen-indent 2 --color RED --result UPD_FAILED UPDATE_CHECKING_FILE "${UPDFILE}"
						display --to LOG --type WARNING UPDATE_DECOMP_FAIL "${RKHUPD_FILE}"

						RKHUPD_FILE=`echo "${RKHUPD_FILE}" | sed -e 's/\.gz$//'`
					fi

					break
				fi
			else
				RET_CODE=1

				if [ $VERSION_FILE -eq 1 ]; then
					display --to SCREEN+LOG --type WARNING --screen-indent 2 --color RED --result VCHK_FAILED UPDATE_CHECKING_FILE "${UPDFILE}"
				else
					rm -f ${RKHUPD_FILE} >/dev/null 2>&1
					RKHUPD_FILE=`echo "${RKHUPD_FILE}" | sed -e 's/\.gz$//'`

					display --to SCREEN+LOG --type WARNING --screen-indent 2 --color RED --result UPD_FAILED UPDATE_CHECKING_FILE "${UPDFILE}"
				fi

				break
			fi
		done

		rm -f ${RKHUPD_FILE} >/dev/null 2>&1
	done

	return
}


do_versioncheck() {

	#
	# This function performs a program version check.
	#
	# It will set the return code in some instances:
	#	1 - a download error occurred
	#	2 - no error occurred, but an update is available
	#

	MIRROR=""
	LATESTVERSION=""

	display --to SCREEN+LOG --type PLAIN --nl VERSIONCHECK_START


	#
	# First we need to get a temporary file name to use.
	#

	get_temp_file "${TMPDIR}/rkhunter.vc"
	RKHVC_FILE=$TEMPFILE

	display --to LOG --type INFO CREATED_TEMP_FILE "${RKHVC_FILE}"


	#
	# To get the URL to use we must process this as a configuration
	# file option.
	#

	URL=`grep '^LATESTVERSION=' ${CONFIGFILE} | tail -1 | sed -e 's/LATESTVERSION=//' | tr -d '"' | tr -s ' '`

	if [ -z "`echo \"${URL}\" | grep '^/'`" ]; then
		URL="/rkhunter_latest.dat"
	fi


	#
	# Download the file, and then compare the current value
	# with the downloaded one.
	#

	download_file "${MIRROR}" "${URL}" "${RKHVC_FILE}"

	if [ $? -eq 0 ]; then
		LATESTVERSION=`cat ${RKHVC_FILE} 2>/dev/null`

		#
		# Convert the version strings to zero-spaced numbers.
		# This allows us to numerically compare the versions,
		# even when the numbers go above ten.
		#
		# E.g. '1.2.10' => 10210,   '1.3.2' => 10302.
		#

		PROG_VERS=`echo "${PROGRAM_version}" | cut -d. -f1-3 | sed -e 's/\.\([0-9]\)\./.0\1./' | sed -e 's/\.\([0-9]\)$/.0\1/' | tr -d '.'`
		LATEST_VERS=`echo "${LATESTVERSION}" | cut -d. -f1-3 | sed -e 's/\.\([0-9]\)\./.0\1./' | sed -e 's/\.\([0-9]\)$/.0\1/' | tr -d '.'`

		display --to SCREEN+LOG --type INFO VERSIONCHECK_CURRENT "${PROGRAM_version}"
		display --to SCREEN+LOG --type INFO VERSIONCHECK_LATEST "${LATESTVERSION}"

		if [ -z "${PROG_VERS}" -o -z "${LATEST_VERS}" ]; then
			RET_CODE=1
			display --to SCREEN+LOG --type INFO VERSIONCHECK_CONV_FAIL "${PROG_VERS}" "${LATEST_VERS}"
		elif [ $PROG_VERS -lt $LATEST_VERS ]; then
			test $RET_CODE -eq 0 && RET_CODE=2
			display --to SCREEN --type PLAIN VERSIONCHECK_UPDT_AVAIL
		fi
	else
		RET_CODE=1
		display --to LOG --type INFO VERSIONCHECK_FAIL_ALL
	fi

	rm -f ${RKHVC_FILE} >/dev/null 2>&1

	return
}


do_system_check_initialisation() {

	#
	# This function simply initialises the default rootkit
	# files and directories.
	#


	# 55808 Variant A
	W55808A_FILES="${ROOTDIR}/tmp/.../r
		       ${ROOTDIR}/tmp/.../a"


	# AjaKit
	AJAKIT_FILES="${ROOTDIR}/dev/tux/.addr
		      ${ROOTDIR}/dev/tux/.proc
		      ${ROOTDIR}/dev/tux/.file
		      ${ROOTDIR}/lib/.libgh-gh/cleaner
		      ${ROOTDIR}/lib/.libgh-gh/Patch/patch
		      ${ROOTDIR}/lib/.libgh-gh/sb0k"
	AJAKIT_DIRS="${ROOTDIR}/dev/tux
		     ${ROOTDIR}/lib/.libgh-gh"
	AJAKIT_KSYMS=""


	# aPa Kit
	APAKIT_FILES="${ROOTDIR}/usr/share/.aPa"
	APAKIT_DIRS=""
	APAKIT_KSYMS=""


	# Apache Worm
	APACHEWORM_FILES="${ROOTDIR}/bin/.log"


	# Ambient (ark) Rootkit
	ARK_FILES="${ROOTDIR}/usr/lib/.ark?
		   ${ROOTDIR}/dev/ptyxx/.log
		   ${ROOTDIR}/dev/ptyxx/.file"
	ARK_DIRS="${ROOTDIR}/dev/ptyxx"


	# Balaur Rootkit 2.0 (LRK5 based)
	BALAUR_FILES="${ROOTDIR}/usr/lib/liblog.o"
	BALAUR_DIRS="${ROOTDIR}/usr/lib/.kinetic
		     ${ROOTDIR}/usr/lib/.egcs
		     ${ROOTDIR}/usr/lib/.wormie"
	BALAUR_KSYMS=""


	# Beastkit
	BEASTKIT_FILES="${ROOTDIR}/usr/sbin/arobia
			${ROOTDIR}/usr/sbin/idrun
			${ROOTDIR}/usr/lib/elm/arobia/elm
			${ROOTDIR}/usr/lib/elm/arobia/elm/hk
			${ROOTDIR}/usr/lib/elm/arobia/elm/hk.pub
			${ROOTDIR}/usr/lib/elm/arobia/elm/sc
			${ROOTDIR}/usr/lib/elm/arobia/elm/sd.pp
			${ROOTDIR}/usr/lib/elm/arobia/elm/sdco
			${ROOTDIR}/usr/lib/elm/arobia/elm/srsd"
	BEASTKIT_DIRS="${ROOTDIR}/lib/ldd.so/bktools"


	# beX2
	BEX_FILES=""
	BEX_DIRS="${ROOTDIR}/usr/include/bex"
	BEX_KSYMS=""


	# BOBkit
	BOBKIT_FILES="${ROOTDIR}/usr/sbin/ntpsx
		      ${ROOTDIR}/usr/lib/.../ls
		      ${ROOTDIR}/usr/lib/.../netstat
		      ${ROOTDIR}/usr/lib/.../lsof
		      ${ROOTDIR}/usr/lib/.../bkit-ssh/bkit-shdcfg
		      ${ROOTDIR}/usr/lib/.../bkit-ssh/bkit-shhk
		      ${ROOTDIR}/usr/lib/.../bkit-ssh/bkit-pw
		      ${ROOTDIR}/usr/lib/.../bkit-ssh/bkit-shrs
		      ${ROOTDIR}/usr/lib/.../uconf.inv
		      ${ROOTDIR}/usr/lib/.../psr
		      ${ROOTDIR}/usr/lib/.../find
		      ${ROOTDIR}/usr/lib/.../pstree
		      ${ROOTDIR}/usr/lib/.../slocate
		      ${ROOTDIR}/usr/lib/.../du
		      ${ROOTDIR}/usr/lib/.../top"
	BOBKIT_DIRS="${ROOTDIR}/usr/lib/...
		     ${ROOTDIR}/usr/lib/.../bkit-ssh
		     ${ROOTDIR}/usr/lib/.bkit-
		     ${ROOTDIR}/tmp/.bkp"


	# CiNIK Worm (Slapper.B variant)
	CINIK_DIRS="${ROOTDIR}/tmp/.font-unix/.cinik"
	CINIK_FILES="${ROOTDIR}/tmp/.cinik"


	# Danny-Boy's Abuse Kit
	DANNYBOY_FILES="${ROOTDIR}/dev/mdev
			${ROOTDIR}/usr/lib/libX.a"
	DANNYBOY_DIRS=""
	DANNYBOY_KSYMS=""


	# Devil
	DEVIL_FILES="${ROOTDIR}/var/lib/games/.src
		     ${ROOTDIR}/dev/dsx
		     ${ROOTDIR}/dev/caca"


	# Dica (T0rn variant)
	DICA_FILES="${ROOTDIR}/lib/.sso
		    ${ROOTDIR}/lib/.so
		    ${ROOTDIR}/var/run/...dica/clean
		    ${ROOTDIR}/var/run/...dica/xl
		    ${ROOTDIR}/var/run/...dica/xdr
		    ${ROOTDIR}/var/run/...dica/psg
		    ${ROOTDIR}/var/run/...dica/secure
		    ${ROOTDIR}/var/run/...dica/rdx
		    ${ROOTDIR}/var/run/...dica/va
		    ${ROOTDIR}/var/run/...dica/cl.sh
		    ${ROOTDIR}/usr/bin/.etc"
	DICA_DIRS="${ROOTDIR}/var/run/...dica
		   ${ROOTDIR}/var/run/...dica/mh
		   ${ROOTDIR}/var/run/...dica/scan"
	DICA_KSYMS=""


	# Dreams
	DREAMS_FILES="${ROOTDIR}/dev/ttyoa
		      ${ROOTDIR}/dev/ttyof
		      ${ROOTDIR}/dev/ttyop
		      ${ROOTDIR}/usr/bin/sense
		      ${ROOTDIR}/usr/bin/sl2
		      ${ROOTDIR}/usr/bin/logclear
		      ${ROOTDIR}/usr/bin/(swapd)
		      ${ROOTDIR}/usr/bin/snfs
		      ${ROOTDIR}/usr/lib/libsss"
	DREAMS_DIRS="${ROOTDIR}/dev/ida/.hpd"
	DREAMS_KSYMS=""


	# Duarawkz
	DUARAWKZ_FILES="${ROOTDIR}/usr/bin/duarawkz/loginpass"
	DUARAWKZ_DIRS="${ROOTDIR}/usr/bin/duarawkz"
	DUARAWKZ_KSYMS=""

	# ENYELKM v1.1
	# Installer default.
	ENYELKM_FILES="${ROOTDIR}/etc/.enyelkmHIDE^IT.ko"
	ENYELKM_DIRS=""
	ENYELKM_KSYMS=""

	# Flea Linux rootkit
	FLEA_FILES="${ROOTDIR}/etc/ld.so.hash
		    ${ROOTDIR}/lib/security/.config/ssh/ssh_host_key
		    ${ROOTDIR}/lib/security/.config/ssh/ssh_host_key.pub
		    ${ROOTDIR}/lib/security/.config/ssh/ssh_random_seed
		    ${ROOTDIR}/usr/bin/ssh2d
		    ${ROOTDIR}/usr/lib/ldlibns.so
		    ${ROOTDIR}/usr/lib/ldlibpst.so
		    ${ROOTDIR}/usr/lib/ldlibdu.so
		    ${ROOTDIR}/usr/lib/ldlibct.so"
	FLEA_DIRS="${ROOTDIR}/lib/security/.config/ssh
		   ${ROOTDIR}/dev/..0
		   ${ROOTDIR}/dev/..0/backup"
	FLEA_KSYMS=""


	# FreeBSD Rootkit
	FREEBSD_RK_FILES="${ROOTDIR}/usr/lib/.fx/sched_host.2
			  ${ROOTDIR}/usr/lib/.fx/random_d.2
			  ${ROOTDIR}/usr/lib/.fx/set_pid.2
			  ${ROOTDIR}/usr/lib/.fx/cons.saver
			  ${ROOTDIR}/usr/lib/.fx/adore/adore/adore.ko
			  ${ROOTDIR}/bin/sysback
			  ${ROOTDIR}/usr/local/bin/sysback"
	FREEBSD_RK_DIRS="${ROOTDIR}/usr/lib/.fx
			 ${ROOTDIR}/usr/lib/.fx/adore"


	# Fuckit Rootkit
	FUCKIT_FILES="${ROOTDIR}/dev/proc/fuckit/hax0r
		      ${ROOTDIR}/dev/proc/fuckit/hax0rshell
		      ${ROOTDIR}/dev/proc/fuckit/config/lports
		      ${ROOTDIR}/dev/proc/fuckit/config/rports
		      ${ROOTDIR}/dev/proc/fuckit/config/rkconf
		      ${ROOTDIR}/dev/proc/fuckit/config/password
		      ${ROOTDIR}/dev/proc/fuckit/config/progs
		      ${ROOTDIR}/dev/proc/system-bins/init"


	# GasKit Rootkit
	GASKIT_FILES="${ROOTDIR}/dev/dev/gaskit/sshd/sshdd"
	GASKIT_DIRS="${ROOTDIR}/dev/dev
		     ${ROOTDIR}/dev/dev/gaskit
		     ${ROOTDIR}/dev/dev/gaskit/sshd"


	# Heroin LKM
	HEROIN_FILES=""
	HEROIN_DIRS=""
	HEROIN_KSYMS="heroin"


	# HjC Kit
	HJCKIT_FILES=""
	HJCKIT_DIRS="${ROOTDIR}/dev/.hijackerz"
	HJCKIT_KSYMS=""


	# ignoKit
	IGNOKIT_FILES="${ROOTDIR}/lib/defs/p
		       ${ROOTDIR}/lib/defs/q
		       ${ROOTDIR}/lib/defs/r
		       ${ROOTDIR}/lib/defs/s
		       ${ROOTDIR}/lib/defs/t
		       ${ROOTDIR}/usr/lib/defs/p
		       ${ROOTDIR}/usr/lib/defs/q
		       ${ROOTDIR}/usr/lib/defs/r
		       ${ROOTDIR}/usr/lib/defs/s
		       ${ROOTDIR}/usr/lib/defs/t
		       ${ROOTDIR}/usr/lib/.libigno/pkunsec
		       ${ROOTDIR}/usr/lib/.libigno/.igno/psybnc/psybnc"
	IGNOKIT_DIRS="${ROOTDIR}/usr/lib/.libigno
		      ${ROOTDIR}/usr/lib/.libigno/.igno/"
	IGNOKIT_KSYMS=""


	# ImperalsS-FBRK (FreeBSD Rootkit)
	IMPFRB_DIRS="${ROOTDIR}/dev/fd/.88
		     ${ROOTDIR}/dev/fd/.99"


	# Irix Rootkit (for Irix 6.x)
	IRIXRK_FILES=""
	IRIXRK_DIRS="${ROOTDIR}/dev/pts/01
		     ${ROOTDIR}/dev/pts/01/backup
		     ${ROOTDIR}/dev/pts/01/etc
		     ${ROOTDIR}/dev/pts/01/tmp"
	IRIXRK_KSYMS=""


	# Kitko
	KITKO_FILES=""
	KITKO_DIRS="${ROOTDIR}/usr/src/redhat/SRPMS/..."
	KITKO_KSYMS=""


	# Knark
	KNARK_FILES="${ROOTDIR}/proc/knark/pids"
	KNARK_DIRS="${ROOTDIR}/proc/knark"
	KNARK_KSYMS=""


	# Lion Worm
	LION_FILES="${ROOTDIR}/bin/in.telnetd
		    ${ROOTDIR}/bin/mjy
		    ${ROOTDIR}/usr/man/man1/man1/lib/.lib/mjy
		    ${ROOTDIR}/usr/man/man1/man1/lib/.lib/in.telnetd
		    ${ROOTDIR}/usr/man/man1/man1/lib/.lib/.x
		    ${ROOTDIR}/dev/.lib/lib/scan/1i0n.sh
		    ${ROOTDIR}/dev/.lib/lib/scan/hack.sh
		    ${ROOTDIR}/dev/.lib/lib/scan/bind
		    ${ROOTDIR}/dev/.lib/lib/scan/randb
		    ${ROOTDIR}/dev/.lib/lib/scan/scan.sh
		    ${ROOTDIR}/dev/.lib/lib/scan/pscan
		    ${ROOTDIR}/dev/.lib/lib/scan/star.sh
		    ${ROOTDIR}/dev/.lib/lib/scan/bindx.sh
		    ${ROOTDIR}/dev/.lib/lib/scan/bindname.log
		    ${ROOTDIR}/dev/.lib/lib/1i0n.sh
		    ${ROOTDIR}/dev/.lib/lib/lib/netstat
		    ${ROOTDIR}/dev/.lib/lib/lib/dev/.1addr
		    ${ROOTDIR}/dev/.lib/lib/lib/dev/.1logz
		    ${ROOTDIR}/dev/.lib/lib/lib/dev/.1proc
		    ${ROOTDIR}/dev/.lib/lib/lib/dev/.1file"


	# Lockit (a.k.a. LJK2)
	LOCKIT_FILES="${ROOTDIR}/usr/lib/libmen.oo/.LJK2/ssh_config
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/ssh_host_key
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/ssh_host_key.pub
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/ssh_random_seed*
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/sshd_config
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backdoor/RK1bd
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/du
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/ifconfig
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/inetd.conf
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/locate
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/login
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/ls
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/netstat
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/ps
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/pstree
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/rc.sysinit
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/syslogd
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/tcpd
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/top
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/clean/RK1sauber
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/clean/RK1wted
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/hack/RK1parser
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/hack/RK1sniff
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/hide/.RK1addr
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/hide/.RK1dir
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/hide/.RK1log
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/hide/.RK1proc
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/hide/RK1phidemod.c
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/modules/README.modules
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/modules/RK1hidem.c
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/modules/RK1phide
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/sshconfig/RK1ssh"
	LOCKIT_DIRS="${ROOTDIR}/usr/lib/libmen.oo/.LJK2"
	LOCKIT_KSYMS=""


	# MRK (MiCrobul RootKit?, based on Devil RootKit )
	MRK_FILES="${ROOTDIR}/dev/ida/.inet/pid
		   ${ROOTDIR}/dev/ida/.inet/ssh_host_key
		   ${ROOTDIR}/dev/ida/.inet/ssh_random_seed
		   ${ROOTDIR}/dev/ida/.inet/tcp.log"
	MRK_DIRS="${ROOTDIR}/dev/ida/.inet
		  ${ROOTDIR}/var/spool/cron/.sh"


	# Mood-NT
	# Binary is by default called "mood-nt" but can be anywhere.
	# Here we look for collaterals, from include/prefs.h defaults
	# until sig-based dirscan() is added.
	MOODNT_FILES="${ROOTDIR}/sbin/init__mood-nt-_-_cthulhu
		      ${ROOTDIR}/_cthulhu/mood-nt.init
		      ${ROOTDIR}/_cthulhu/mood-nt.conf
		      ${ROOTDIR}/_cthulhu/mood-nt.sniff"
	MOODNT_DIRS="${ROOTDIR}/_cthulhu"
	MOODNT_KSYMS=""


	# Ni0 Rootkit
	NIO_FILES="${ROOTDIR}/var/lock/subsys/...datafile.../...net...
		   ${ROOTDIR}/var/lock/subsys/...datafile.../...port...
		   ${ROOTDIR}/var/lock/subsys/...datafile.../...ps...
		   ${ROOTDIR}/var/lock/subsys/...datafile.../...file..."
	NIO_DIRS="${ROOTDIR}/tmp/waza
		  ${ROOTDIR}/var/lock/subsys/...datafile...
		  ${ROOTDIR}/usr/sbin/es"
	NIO_KSYMS=""


	# RootKit for SunOS / NSDAP
	NSDAP_FILES="${ROOTDIR}/usr/lib/vold/nsdap/.kit
		     ${ROOTDIR}/usr/lib/vold/nsdap/defines
		     ${ROOTDIR}/usr/lib/vold/nsdap/patcher
		     ${ROOTDIR}/usr/lib/vold/nsdap/pg
		     ${ROOTDIR}/usr/lib/vold/nsdap/cleaner
		     ${ROOTDIR}/usr/lib/vold/nsdap/utime
		     ${ROOTDIR}/usr/lib/vold/nsdap/crypt
		     ${ROOTDIR}/usr/lib/vold/nsdap/findkit
		     ${ROOTDIR}/usr/lib/vold/nsdap/sn2
		     ${ROOTDIR}/usr/lib/vold/nsdap/sniffload
		     ${ROOTDIR}/usr/lib/vold/nsdap/runsniff
		     ${ROOTDIR}/usr/lib/lpset"
	NSDAP_DIRS="${ROOTDIR}/usr/lib/vold/nsdap"
	NSDAP_KSYMS=""


	# Ohhara Rootkit
	OHHARA_FILES="${ROOTDIR}/var/lock/subsys/...datafile.../...datafile.../in.smbd.log"
	OHHARA_DIRS="${ROOTDIR}/var/lock/subsys/...datafile...
		     ${ROOTDIR}/var/lock/subsys/...datafile.../...datafile...
		     ${ROOTDIR}/var/lock/subsys/...datafile.../...datafile.../bin
		     ${ROOTDIR}/var/lock/subsys/...datafile.../...datafile.../usr/bin
		     ${ROOTDIR}/var/lock/subsys/...datafile.../...datafile.../usr/sbin
		     ${ROOTDIR}/var/lock/subsys/...datafile.../...datafile.../lib/security"


	# Optic Kit (Tux variant)
	OPTICKIT_DIRS="${ROOTDIR}/dev/tux
		       ${ROOTDIR}/usr/bin/xchk
		       ${ROOTDIR}/usr/bin/xsf
		       ${ROOTDIR}/usr/bin/ssh2d"


	# Oz Rootkit
	OZ_FILES="${ROOTDIR}/dev/.oz/.nap/rkit/terror"
	OZ_DIRS="${ROOTDIR}/dev/.oz"


	# PHALANX
	PHALANX_FILES="${ROOTDIR}/usr/share/.home.ph1/cb
		       ${ROOTDIR}/etc/host.ph1
		       ${ROOTDIR}/bin/host.ph1
		       ${ROOTDIR}/usr/share/.home.ph1/phalanx"
	PHALANX_DIRS="${ROOTDIR}/usr/share/.home.ph1"
	PHALANX_KSYMS=""


	# Portacelo
	PORTACELO_FILES="${ROOTDIR}/var/lib/.../.ak
			 ${ROOTDIR}/var/lib/.../.hk
			 ${ROOTDIR}/var/lib/.../.rs
			 ${ROOTDIR}/var/lib/.../.p
			 ${ROOTDIR}/var/lib/.../getty
			 ${ROOTDIR}/var/lib/.../lkt.o
			 ${ROOTDIR}/var/lib/.../show
			 ${ROOTDIR}/var/lib/.../nlkt.o
			 ${ROOTDIR}/var/lib/.../ssshrc
			 ${ROOTDIR}/var/lib/.../sssh_equiv
			 ${ROOTDIR}/var/lib/.../sssh_known_hosts
			 ${ROOTDIR}/var/lib/.../sssh_pid ~/.sssh/known_hosts"


	# R3dstorm Toolkit
	REDSTORM_FILES="${ROOTDIR}/var/log/tk02/see_all
			${ROOTDIR}/bin/.../sshd/sbin/sshd1
			${ROOTDIR}/bin/.../hate/sk
			${ROOTDIR}/bin/.../see_all"
	REDSTORM_DIRS="${ROOTDIR}/var/log/tk02
		       ${ROOTDIR}/var/log/tk02/old
		       ${ROOTDIR}/bin/..."
	REDSTORM_KSYMS=""


	# RH-Sharpe's rootkit
	RHSHARPES_FILES="${ROOTDIR}/bin/lps
			 ${ROOTDIR}/usr/bin/lpstree
			 ${ROOTDIR}/usr/bin/ltop
			 ${ROOTDIR}/usr/bin/lkillall
			 ${ROOTDIR}/usr/bin/ldu
			 ${ROOTDIR}/usr/bin/lnetstat
			 ${ROOTDIR}/usr/bin/wp
			 ${ROOTDIR}/usr/bin/shad
			 ${ROOTDIR}/usr/bin/vadim
			 ${ROOTDIR}/usr/bin/slice
			 ${ROOTDIR}/usr/bin/cleaner
			 ${ROOTDIR}/usr/include/rpcsvc/du"
	RHSHARPES_DIRS=""
	RHSHARPES_KSYMS=""


	# RSHA's rootkit
	RSHA_FILES="${ROOTDIR}/bin/kr4p
		    ${ROOTDIR}/usr/bin/n3tstat
		    ${ROOTDIR}/usr/bin/chsh2
		    ${ROOTDIR}/usr/bin/slice2
		    ${ROOTDIR}/usr/src/linux/arch/alpha/lib/.lib/.1proc
		    ${ROOTDIR}/etc/rc.d/arch/alpha/lib/.lib/.1addr"
	RSHA_DIRS="${ROOTDIR}/etc/rc.d/rsha
		   ${ROOTDIR}/etc/rc.d/arch/alpha/lib/.lib"
	RSHA_KSYMS=""


	# Shutdown
	SHUTDOWN_FILES="${ROOTDIR}/usr/man/man5/..%%/.dir/scannah/asus
			${ROOTDIR}/usr/man/man5/..%%/.dir/see
			${ROOTDIR}/usr/man/man5/..%%/.dir/nscd
			${ROOTDIR}/usr/man/man5/..%%/.dir/alpd
			${ROOTDIR}/etc/rc.d/rc.local%%"
	SHUTDOWN_DIRS="${ROOTDIR}/usr/man/man5/..%%/.dir/
		       ${ROOTDIR}/usr/man/man5/..%%/.dir/scannah
		       ${ROOTDIR}/etc/rc.d/rc0.d/..%%/.dir"


	# Scalper (FreeBSD.Scalper.Worm)
	SCALPER_FILES="${ROOTDIR}/tmp/.a
		       ${ROOTDIR}/tmp/.uua"


	# SHV4
	SHV4_FILES="${ROOTDIR}/etc/ld.so.hash
		    ${ROOTDIR}/lib/libext-2.so.7
		    ${ROOTDIR}/lib/lidps1.so
		    ${ROOTDIR}/usr/sbin/xntps"
	SHV4_DIRS="${ROOTDIR}/lib/security/.config
		   ${ROOTDIR}/lib/security/.config/ssh"


	# SHV5
	SHV5_FILES="${ROOTDIR}/etc/sh.conf
		    ${ROOTDIR}/dev/srd0"
	SHV5_DIRS="${ROOTDIR}/usr/lib/libsh"
	SHV5_KSYMS=""


	# Sin Rootkit
	SINROOTKIT_FILES="${ROOTDIR}/dev/.haos/haos1/.f/Denyed
			  ${ROOTDIR}/dev/ttyoa
			  ${ROOTDIR}/dev/ttyof
			  ${ROOTDIR}/dev/ttyop
			  ${ROOTDIR}/dev/ttyos
			  ${ROOTDIR}/usr/lib/.lib
			  ${ROOTDIR}/usr/lib/sn/.X
			  ${ROOTDIR}/usr/lib/sn/.sys
			  ${ROOTDIR}/usr/lib/ld/.X
			  ${ROOTDIR}/usr/man/man1/...
			  ${ROOTDIR}/usr/man/man1/.../.m
			  ${ROOTDIR}/usr/man/man1/.../.w"
	SINROOTKIT_DIRS="${ROOTDIR}/usr/lib/sn
			 ${ROOTDIR}/usr/lib/man1/...
			 ${ROOTDIR}/dev/.haos"


	# Slapper
	SLAPPER_FILES="${ROOTDIR}/tmp/.bugtraq
		       ${ROOTDIR}/tmp/.uubugtraq
		       ${ROOTDIR}/tmp/.bugtraq.c
		       ${ROOTDIR}/tmp/httpd
		       ${ROOTDIR}/tmp/.unlock
		       ${ROOTDIR}/tmp/update
		       ${ROOTDIR}/tmp/.cinik
		       ${ROOTDIR}/tmp/.b"


	# Sneakin Rootkit
	SNEAKIN_DIRS="${ROOTDIR}/tmp/.X11-unix/.../rk"


	# Suckit Rootkit
	SUCKIT_FILES="${ROOTDIR}/sbin/initsk12
		      ${ROOTDIR}/sbin/initxrk
		      ${ROOTDIR}/usr/bin/null
		      ${ROOTDIR}/usr/share/locale/sk/.sk12/sk
		      ${ROOTDIR}/etc/rc.d/rc0.d/S23kmdac
		      ${ROOTDIR}/etc/rc.d/rc1.d/S23kmdac
		      ${ROOTDIR}/etc/rc.d/rc2.d/S23kmdac
		      ${ROOTDIR}/etc/rc.d/rc3.d/S23kmdac
		      ${ROOTDIR}/etc/rc.d/rc4.d/S23kmdac
		      ${ROOTDIR}/etc/rc.d/rc5.d/S23kmdac
		      ${ROOTDIR}/etc/rc.d/rc6.d/S23kmdac"
	SUCKIT_DIRS="${ROOTDIR}/dev/sdhu0/tehdrakg
		     ${ROOTDIR}/etc/.MG
		     ${ROOTDIR}/usr/share/locale/sk/.sk12
		     ${ROOTDIR}/usr/lib/perl5/site_perl/i386-linux/auto/TimeDate/.packlist"


	# SunOS Rootkit
	SUNOSROOTKIT_FILES="${ROOTDIR}/etc/ld.so.hash
			    ${ROOTDIR}/lib/libext-2.so.7
			    ${ROOTDIR}/usr/bin/ssh2d
			    ${ROOTDIR}/bin/xlogin
			    ${ROOTDIR}/usr/lib/crth.o
			    ${ROOTDIR}/usr/lib/crtz.o
			    ${ROOTDIR}/sbin/login
			    ${ROOTDIR}/lib/security/.config/sn
			    ${ROOTDIR}/lib/security/.config/lpsched
			    ${ROOTDIR}/dev/kmod
			    ${ROOTDIR}/dev/dos"


	# Superkit
	SUPERKIT_FILES="${ROOTDIR}/usr/man/.sman/sk"
	SUPERKIT_DIRS=""
	SUPERKIT_KSYMS=""


	# Telnet Backdoor
	TBD_FILES="${ROOTDIR}/usr/lib/.tbd"


	# TeLeKiT
	TELEKIT_FILES="${ROOTDIR}/usr/man/man3/.../TeLeKiT/bin/sniff
		       ${ROOTDIR}/usr/man/man3/.../TeLeKiT/bin/telnetd
		       ${ROOTDIR}/usr/man/man3/.../TeLeKiT/bin/teleulo
		       ${ROOTDIR}/usr/man/man3/.../cl
		       ${ROOTDIR}/dev/ptyr
		       ${ROOTDIR}/dev/ptyp
		       ${ROOTDIR}/dev/ptyq
		       ${ROOTDIR}/dev/hda06
		       ${ROOTDIR}/usr/info/libc1.so"
	TELEKIT_DIRS="${ROOTDIR}/usr/man/man3/...
		      ${ROOTDIR}/usr/man/man3/.../lsniff
		      ${ROOTDIR}/usr/man/man3/.../TeLeKiT"
	TELEKIT_KSYMS=""


	# Torn (and misc)
	TORN_FILES="${ROOTDIR}/dev/.lib/lib/lib/t0rns
		    ${ROOTDIR}/dev/.lib/lib/lib/du
		    ${ROOTDIR}/dev/.lib/lib/lib/ls
		    ${ROOTDIR}/dev/.lib/lib/lib/t0rnsb
		    ${ROOTDIR}/dev/.lib/lib/lib/ps
		    ${ROOTDIR}/dev/.lib/lib/lib/t0rnp
		    ${ROOTDIR}/dev/.lib/lib/lib/find
		    ${ROOTDIR}/dev/.lib/lib/lib/ifconfig
		    ${ROOTDIR}/dev/.lib/lib/lib/pg
		    ${ROOTDIR}/dev/.lib/lib/lib/ssh.tgz
		    ${ROOTDIR}/dev/.lib/lib/lib/top
		    ${ROOTDIR}/dev/.lib/lib/lib/sz
		    ${ROOTDIR}/dev/.lib/lib/lib/login
		    ${ROOTDIR}/dev/.lib/lib/lib/in.fingerd
		    ${ROOTDIR}/dev/.lib/lib/lib/1i0n.sh
		    ${ROOTDIR}/dev/.lib/lib/lib/pstree
		    ${ROOTDIR}/dev/.lib/lib/lib/in.telnetd
		    ${ROOTDIR}/dev/.lib/lib/lib/mjy
		    ${ROOTDIR}/dev/.lib/lib/lib/sush
		    ${ROOTDIR}/dev/.lib/lib/lib/tfn
		    ${ROOTDIR}/dev/.lib/lib/lib/name
		    ${ROOTDIR}/dev/.lib/lib/lib/getip.sh
		    ${ROOTDIR}/usr/info/.torn/sh*
		    ${ROOTDIR}/usr/src/.puta/
		    ${ROOTDIR}/usr/src/.puta/.1addr
		    ${ROOTDIR}/usr/src/.puta/.1file
		    ${ROOTDIR}/usr/src/.puta/.1proc
		    ${ROOTDIR}/usr/src/.puta/.1logz
		    ${ROOTDIR}/usr/info/.t0rn/"
	TORN_DIRS="${ROOTDIR}/dev/.lib/
		   ${ROOTDIR}/dev/.lib/lib/
		   ${ROOTDIR}/dev/.lib/lib/lib/
		   ${ROOTDIR}/dev/.lib/lib/lib/dev/
		   ${ROOTDIR}/dev/.lib/lib/scan/
		   ${ROOTDIR}/usr/src/.puta/
		   ${ROOTDIR}/usr/man/man1/man1/
		   ${ROOTDIR}/usr/man/man1/man1/lib/
		   ${ROOTDIR}/usr/man/man1/man1/lib/.lib/
		   ${ROOTDIR}/usr/man/man1/man1/lib/.lib/.backup/"


	# Trojanit Kit
	TROJANIT_FILES="${ROOTDIR}/bin/.ls
			${ROOTDIR}/bin/.ps
			${ROOTDIR}/bin/.netstat
			${ROOTDIR}/usr/bin/.nop
			${ROOTDIR}/usr/bin/.who"


	# Tuxtendo (Tuxkit)
	TUXTENDO_FILES="${ROOTDIR}/dev/tux/.addr
			${ROOTDIR}/dev/tux/.cron
			${ROOTDIR}/dev/tux/.file
			${ROOTDIR}/dev/tux/.log
			${ROOTDIR}/dev/tux/.proc
			${ROOTDIR}/dev/tux/backup/crontab
			${ROOTDIR}/dev/tux/backup/df
			${ROOTDIR}/dev/tux/backup/dir
			${ROOTDIR}/dev/tux/backup/find
			${ROOTDIR}/dev/tux/backup/ifconfig
			${ROOTDIR}/dev/tux/backup/locate
			${ROOTDIR}/dev/tux/backup/netstat
			${ROOTDIR}/dev/tux/backup/ps
			${ROOTDIR}/dev/tux/backup/pstree
			${ROOTDIR}/dev/tux/backup/syslogd
			${ROOTDIR}/dev/tux/backup/tcpd
			${ROOTDIR}/dev/tux/backup/top
			${ROOTDIR}/dev/tux/backup/updatedb
			${ROOTDIR}/dev/tux/backup/vdir"
	TUXTENDO_DIRS="${ROOTDIR}/dev/tux
		       ${ROOTDIR}/dev/tux/ssh2
		       ${ROOTDIR}/dev/tux/backup"
	TUXTENDO_KSYMS=""


	# URK (Universal Root Kit)
	URK_FILES="${ROOTDIR}/usr/man/man1/xxxxxxbin/find
		   ${ROOTDIR}/usr/man/man1/xxxxxxbin/du
		   ${ROOTDIR}/usr/man/man1/xxxxxxbin/ps
		   ${ROOTDIR}/tmp/conf.inf"
	URK_DIRS="${ROOTDIR}/usr/man/man1/xxxxxxbin"


	# VcKit
	VCKIT_FILES=""
	VCKIT_DIRS="${ROOTDIR}/usr/include/linux/modules/lib.so
		    ${ROOTDIR}/usr/include/linux/modules/lib.so/bin"


	# Volc Rootkit
	VOLC_FILES=""
	VOLC_DIRS="${ROOTDIR}/var/spool/.recent
		   ${ROOTDIR}/var/spool/.recent/.files
		   ${ROOTDIR}/usr/lib/volc
		   ${ROOTDIR}/usr/lib/volc/backup"


	# X-Org SunOS Rootkit
	XORGSUNOS_FILES="${ROOTDIR}/usr/lib/libX.a/bin/tmpfl
			 ${ROOTDIR}/usr/lib/libX.a/bin/rps
			 ${ROOTDIR}/usr/bin/srload
			 ${ROOTDIR}/usr/lib/libX.a/bin/sparcv7/rps
			 ${ROOTDIR}/usr/sbin/modcheck"
	XORGSUNOS_DIRS="${ROOTDIR}/usr/lib/libX.a
			${ROOTDIR}/usr/lib/libX.a/bin
			${ROOTDIR}/usr/lib/libX.a/bin/sparcv7
			${ROOTDIR}/usr/share/man..."


	# zaRwT.KiT
	ZARWT_FILES="${ROOTDIR}/dev/rd/s/sendmeil
		     ${ROOTDIR}/dev/ttyf
		     ${ROOTDIR}/dev/ttyp
		     ${ROOTDIR}/dev/ttyn
		     ${ROOTDIR}/rk/tulz"
	ZARWT_DIRS="${ROOTDIR}/rk
		    ${ROOTDIR}/dev/rd/s"
	ZARWT_LOGS=".zarwt. sendmeil :60922 cky."


	# Miscellaneous login backdoors
	LOGIN_BACKDOOR_FILES="${ROOTDIR}/bin/.login
			      ${ROOTDIR}/sbin/.login"


	# Misc Apache Backdoors
	APACHEBDOORS_STRINGS="gotcha"


	# Suspicious files in /dev
	# v1rootkit does use some files here to hide processes, UIDs and GIDs.
	# Files: /dev/ttyp, /dev/ttypr, /dev/ttypp, /dev/ttypq
	# (Checked: FreeBSD and RedHat doesn't have these files by default)
	# Files: /dev/ptyxx/.list /dev/ptyxx/.proc
	# Files: ${ROOTDIR}/tmp/tr/td:

	SUSPICIOUS1_FILES=".list:Unknown file: .proc:Unknown file:
			   psybnc:IRC%%bouncer: td:Unknown file:
			   ttyp:Unknown file: ttypr:Unknown file:
			   ttypp:Unknown file: ttypq:Unknown file:"


	# Suspicious directories
	SUSPICIOUS1_DIRS="${ROOTDIR}/usr/X11R6/bin/.,/copy/
			  ${ROOTDIR}/dev/rd"


	# Evil strings
	STRINGSCAN="bin:test2:abc:Test
		    bin:init:/dev/proc/fuckit:Fuckit%%Rootkit
		    bin:init:FUCK:Possible%%Suckit%%Rootkit%%found
		    bin:init:backdoor:Possible%%backdoored%%init%%file%%(Suckit)
		    bin:login:vt200:Possible%%Linux%%Rootkit
		    bin:login:/usr/bin/xstat:Possible%%Linux%%Rootkit
		    bin:login:/bin/envpc:Unknown bin:login:l4m3r0x:Unknown
		    bin:login:/usr/lib/.tbd:TBD%%Rootkit
		    bin:ls:/dev/ptyxx/.file:Dica%%(T0rn%%variant)
		    bin:ls:/dev/sgk:Unknown
		    bin:ls:/var/lock/subsys/...datafile...:Ohhara%%Rootkit
		    bin:ls:/usr/lib/.tbd:TBD%%Rootkit
		    bin:netstat:/dev/proc/fuckit:Fuckit%%Rootkit
		    bin:netstat:/lib/.sso:Dica%%(T0rn%%variant)
		    bin:netstat:/var/lock/subsys/...datafile...:Ohhara%%Rootkit
		    bin:netstat:/dev/caca:MRK
		    bin:netstat:/dev/ttyoa:Sin%%Rootkit
		    bin:netstat:syg:Possible%%trojaned%%netstat
		    bin:nscd:sshd_config:Possible%%backdoor%%shell%%installed%%(SSH)
		    bin:ps:/dev/pts/01:SunOS%%Rootkit
		    bin:ps:tw33dl3:SunOS%%Rootkit
		    bin:ps:psniff:SunOS%%Rootkit
		    bin:ps:/var/lock/subsys/...datafile...:Ohhara%%Rootkit%%or%%Ni0%%Rootkit
		    bin:rpc.nfsd:cant%%open%%log:Possible%%sniffer%%installed
		    bin:rpc.nfsd:sniff.pid:Possible%%sniffer%%installed
		    bin:rpc.nfsd:tcp.log:Possible%%sniffer%%installed
		    bin:sshd:/dev/ptyxx:OpenBSD%%Rootkit
		    bin:syslogd:promiscuous:Possible%%sniffer%%installed
		    bin:syslogd:/usr/lib/.tbd:TBD%%Rootkit
		    bin:tcpd:/dev/xdta:Dica%%(T0rn%%variant)
		    bin:top:/usr/lib/.tbd:TBD%%Rootkit
		    bin:xtty:/bin/sh:Possible%%backdoor%%shell%%installed
		    etc:passwd:r00t:Possible%%GasKit
		    etc:passwd:t00r:Possible%%GasKit
		    libs:libproc.so.2.0.7:/dev/proc/fuckit:Fuckit%%Rootkit
		    rc.d:boot:/usr/bin/initrd%%-t1%%-X53%%-p:Dreams%%Rootkit
		    rc.d:functions:/usr/bin/initrd%%-t1%%-X53%%-p:Dreams%%Rootkit
		    rc.inet1:/usr/bin/initrd%%-t1%%-X53%%-p:Dreams%%Rootkit"


	# Slackware /etc/rc.d/sysvinit
	RCSTRINGS="sshdu:Possible%%trojaned%%SSH%%Daemon
		   sshd1:Possible%%trojaned%%SSH%%Daemon
		   linsniffer:Possible%%keyboard%%sniffer%%found
		   startadore:Possible%%Adore%%rootkit%%found
		   ava:Possible%%PID%%hider%%found
		   .lsd:Torn%%based%%part%%found
		   /usr/bin/hdparm%%-t1%%-X53%%-p:MRK%%part%%found"


	# Files
	FILESCAN="file:${ROOTDIR}/dev/sdr0:Possible%%MD5%%hash%%database
		  file:${ROOTDIR}/tmp/.syshackfile:Trojaned%%syslog%%daemon
		  file:${ROOTDIR}/tmp/.bash_history:Possible%%Lite5-r%%rootkit
		  file:${ROOTDIR}/usr/info/.clib:Possible%%backdoor
		  file:${ROOTDIR}/usr/sbin/tcp.log:Possible%%sniffer
		  file:${ROOTDIR}/usr/bin/take/pid:Trojaned%%SSH%%daemon
		  file:${ROOTDIR}/sbin/create:MzOzD%%Local%%backdoor%%found
		  file:${ROOTDIR}/dev/ttypz:Found%%spwn%%login%%backdoor
		  dir:${ROOTDIR}/usr/bin/take:Trojaned%%SSH%%daemon
		  dir:${ROOTDIR}/usr/src/.lib:Unusual%%directory
		  dir:${ROOTDIR}/usr/share/man/man1/.1c:Possible%%Eggdrop%%installed
		  dir:${ROOTDIR}/lib/lblip.tk:Directory%%with%%backdoored%%SSH-configuration
		  dir:${ROOTDIR}/usr/sbin/...:Unusual%%directory
		  dir:${ROOTDIR}/usr/share/.gun:Unusual%%directory"


	# Evil strings for *BSD KLD (Dynamic Kernel Linker modules)
	KLDSTATKEYWORDS="backd00r backdoor"


	LKMSCAN="LuCe%%LKM:LuCe%%LKM-module"
	LKMSTRINGS="pass.log|thc.org:THC%%Vlogger:Keylogger/sniffer"


	RCLOCAL_STRINGS="/usr/bin/rpc.wall:Unknown
			 sshdd:Possible%%GasKit
			 hidef:Possible%%part%%of%%Knark%%found"


	# Integrity tests
	STRINGS_INTEGRITY="${BOBKIT_FILES} ${BOBKIT_DIRS} ${CINIK_FILES}
			   ${CINIK_DIRS} ${DICA_FILES} ${FREEBSD_RK_FILES}
			   ${TBD_FILES} ${TORN_FILES} ${TORN_DIRS}"


	SNIFFER_FILES="${ROOTDIR}/usr/lib/libice.log"


	APACHE_MOD_ROOTME="${ROOTDIR}/usr/local/apache/libexec/mod_rootme.so
			   ${ROOTDIR}/usr/lib/apache/1.3/mod_rootme.so
			   ${ROOTDIR}/usr/lib/apache2/modules/mod_rootme2.so
			   ${ROOTDIR}/usr/local/apache2/modules/mod_rootme2.so"


	HTTPDCONFS="${ROOTDIR}/usr/local/apache/conf/httpd.conf
		    ${ROOTDIR}/usr/local/etc/apache/httpd.conf
		    ${ROOTDIR}/etc/apache/httpd.conf
		    ${ROOTDIR}/etc/httpd/conf/httpd.conf"


	BAD_PROCESSES="31337:Linsniffer"

	return
}


do_strings_check() {

	#
	# This function carries out the 'strings' command check.
	# It passes specific strings through the strings command to
	# see if they are missing. If so, then it can indicate that
	# the command has been modified to hide information.
	#

	if ! `check_test strings`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST strings
		return
	fi


	display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 STRINGS_CHECK_START


	#
	# We only perform the test if we have a 'strings' command.
	#

	if [ -z "${STRINGS_CMD}" ]; then
		display --to SCREEN+LOG --type WARNING --result SKIPPED --color YELLOW --screen-indent 4 STRINGS_CHECK
		return
	fi


	#
	# Otherwise - do the test.
	#

	STRINGSFAILED=0

	#
	# The pathnames to check will have the ROOTDIR at
	# the front. We need to strip this off before passing
	# it through the 'strings' command. If we didn't then
	# we would be looking for the wrong pathname.
	#

	RDIR=`echo "${ROOTDIR}" | sed -e 's/\//\\\\\//g'`

	for STRING in ${STRINGS_INTEGRITY}; do
		STRING=`echo "${STRING}" | sed -e "s/^${RDIR}//"`

		STRINGNAME=`echo "${STRING}" | sed -e 's/\./\\\./g'`
		STRINGFOUND=`echo "${STRING}" | ${STRINGS_CMD} | grep "${STRINGNAME}" | tr -d ' '`

		if [ -z "${STRINGFOUND}" ]; then
			STRINGSFAILED=1
			display --to LOG --type WARNING --result BAD STRINGS_SCANNING_BAD "${STRING}"
		else
			display --to LOG --type PLAIN --result OK STRINGS_SCANNING_OK "${STRING}"
		fi
	done


	if [ $STRINGSFAILED -eq 0 ]; then
		display --to SCREEN --type PLAIN --result OK --color GREEN --screen-indent 4 STRINGS_CHECK
	else
		display --to SCREEN --type PLAIN --result BAD --color RED --screen-indent 4 STRINGS_CHECK
	fi

	return
}


do_shared_libs_check() { 

	#
	# This function checks shared library loading problems.
	# It is part of do_system_commands_checks and should precede or run
	# just after do_strings_check if enabled.
	#

	#
	# Remarks:
	# Oracle-10.1.0.3 on RHEL3 needs /etc/libcwait.so,
	# F-PROT Antivirus for GNU/Linux needs f-prot.so,
	# AVAYA Labs "stack overflow protection" uses libsafe.
	#

	if ! `check_test shared_libs`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST shared_libs
		return
	fi

	display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 SHARED_LIBS_START


	# Library preloading exported variables.

	for RKHTMPVAR in LD_PRELOAD LD_AOUT_PRELOAD LD_ELF_PRELOAD; do
		RKHTMPVAR_RES=`eval echo "\\$${RKHTMPVAR}"`
		if [ -n "${RKHTMPVAR_RES}" ]; then
			display --to LOG --type WARNING --result BAD SHARED_LIBS_VAR_BAD "${RKHTMPVAR}"
		else
			display --to LOG --type PLAIN --result OK SHARED_LIBS_VAR_OK "${RKHTMPVAR}"
		fi
	done


	# Library preload file.

	RKHTMPVAR=${ROOTDIR}/etc/ld.so.preload

	if [ -f ${RKHTMPVAR} ]; then
		display --to LOG --type WARNING --result BAD SHARED_LIBS_PRE_BAD "${RKHTMPVAR}"
	else
		display --to LOG --type PLAIN --result OK SHARED_LIBS_PRE_OK "${RKHTMPVAR}"
	fi


	# LD_LIBRARY_PATH check

	if [ -n "${LDD_CMD}" ]; then
		RKHTMPVAR=`eval echo "\\$${LD_LIBRARY_PATH}"`

		if [ -n "${RKHTMPVAR}" ]; then
			LD_LIBR_FAILED=0
			LD_LIBRARY_PATH_SAVED=${LD_LIBRARY_PATH}
			RKHTMPVAR_BIN="
				${FIND_CMD}
				${PS_CMD}
				${STRINGS_CMD}
				${MD5_CMD}
				${LS_CMD}
				${STAT_CMD}
				"

			for RKHTMPVAR in $RKHTMPVAR_BIN; do
				export LD_LIBRARY_PATH
				RKHTMPVAR_WITH=`${LDD_CMD} $RKHTMPVAR`
				unset LD_LIBRARY_PATH
				RKHTMPVAR_WITHOUT=`${LDD_CMD} $RKHTMPVAR`

				if [ "${RKHTMPVAR_WITH}" != "${RKHTMPVAR_WITHOUT}" ]; then
					# display --to LOG --type WARNING --result BAD SHARED_LIBS_PATH_BAD "${RKHTMPVAR}"
					LD_LIBR_FAILED=1
					# Testing one command should be "evidence" enough.
					break
				fi
			done

			LD_LIBRARY_PATH=${LD_LIBRARY_PATH_SAVED}

			if [ $LD_LIBR_FAILED -eq 0 ]; then
				display --to SCREEN --type PLAIN --result OK --color GREEN --screen-indent 4 SHARED_LIBS_PATH_OK
			else
				display --to SCREEN --type PLAIN --result BAD --color RED --screen-indent 4 SHARED_LIBS_PATH_BAD
			fi
		# else
		# 	Don't mention.
		# 	no LD_LIBRARY_PATH set
		fi
	else
		display --to SCREEN+LOG --type WARNING --result SKIPPED --color YELLOW --screen-indent 4 SHARED_LIBS_PATH_CMD
	fi

	return
}


do_known_good_hash_check() {

	#
	# This function carries out a check of system command property
	# values checked against their previous value, which is stored
	# in the rkhunter.dat file.
	#

	if ! `check_test hashes`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST hashes
		return
	fi


	display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 GOOD_HASH_START


	#
	# If we have to skip the test, then does so and log the reason why.
	#

	if [ $SKIP_GOODHASH_MSG -gt 0 ]; then
		display --to SCREEN+LOG --type WARNING --screen-indent 4 SKIP_GOODHASH_CHECK${SKIP_GOODHASH_MSG}

		if [ $SKIP_GOODHASH_MSG -eq 4 -o $SKIP_GOODHASH_MSG -eq 5 -o $SKIP_GOODHASH_MSG -eq 6 ]; then
			display --to LOG --type WARNING --nl HASHUPD_WARN
		fi

		return
	fi


	#
	# Otherwise, just carry on with the checks.
	#

	if [ -n "`echo ${STAT_CMD} | grep '\.pl$'`" ]; then
		SCMD="${STAT_CMD} --modeoct --raw --mode --ino -uid -gid -Mtime"
	else
		if [ "${OPERATING_SYSTEM}" = "NetBSD" ]; then
			SCMD="${STAT_CMD} -f '%i %Mp%Lp %u %g %m:'"
		else
			SCMD="${STAT_CMD} --format='%i 0%a %u %g %Y:'"
		fi
	fi

	if [ $PRELINKED -eq 0 ]; then
		HCMD=$HASH_FUNC
	else
		if [ -n "`echo ${HASH_FUNC} | grep 'md5'`" ]; then
			HCMD="${PRELINK_CMD} --verify --md5"
		else
			HCMD="${PRELINK_CMD} --verify --sha"
		fi
	fi

	if [ "${OPERATING_SYSTEM}" = "OpenBSD" -a "${HCMD}" = "/bin/md5" ]; then
		HSH_FLD_IDX=4
	else
		HSH_FLD_IDX=1
	fi


	for DIR in ${HASHDIRS}; do
		for FNAME in ${HASHFILES}; do
			HASH_OK=0; MISSING=0

			RKHLINE=`grep "^File:${DIR}/${FNAME}:" ${DB_PATH}/rkhunter.dat`

			if [ -f "${DIR}/${FNAME}" -a ! -h "${DIR}/${FNAME}" ]; then
				if [ -n "${RKHLINE}" ]; then
					HASH_COUNT=`expr ${HASH_COUNT} + 1`

					RKHHASH=`echo ${RKHLINE} | cut -d: -f3`

					if [ -n "${RKHHASH}" ]; then
						SYSHASH=`${HCMD} ${DIR}/${FNAME} 2>/dev/null | cut -d' ' -f $HSH_FLD_IDX`
						FDATA=`eval ${SCMD} ${DIR}/${FNAME} 2>/dev/null | tr ' ' ':'`

						RKHPERM=`echo ${RKHLINE} | cut -d: -f5`
						RKHUID=`echo ${RKHLINE} | cut -d: -f6`
						RKHGID=`echo ${RKHLINE} | cut -d: -f7`

						SYSPERM=`echo ${FDATA} | cut -d: -f2`
						SYSUID=`echo ${FDATA} | cut -d: -f3`
						SYSGID=`echo ${FDATA} | cut -d: -f4`

						#
						# Prelinking will change the inode and DTM of a
						# file. As such, we only check those properties
						# for non-prelinked systems, or if there has been
						# a problem getting the hash value.
						#

						if [ $PRELINKED -eq 0 -o -z "${SYSHASH}" ]; then
							RKHINODE=`echo ${RKHLINE} | cut -d: -f4`
							RKHDTM=`echo ${RKHLINE} | cut -d: -f8`

							SYSINODE=`echo ${FDATA} | cut -d: -f1`
							SYSDTM=`echo ${FDATA} | cut -d: -f5`
						fi


						#
						# We check the file permissions here to see if
						# the 'other' permission contains a 'w'. The check
						# is against the octal value.
						#

						WRITE_PERM=`echo ${SYSPERM} | grep '[2367]$'`


						if [ "${RKHHASH}" = "${SYSHASH}" -a "${RKHINODE}" = "${SYSINODE}" -a "${RKHPERM}" = "${SYSPERM}" -a "${RKHUID}" = "${SYSUID}" -a "${RKHGID}" = "${SYSGID}" -a "${RKHDTM}" = "${SYSDTM}" -a -z "${WRITE_PERM}" ]; then
							HASH_OK=1
						fi
					else
						MISSING=1
						display --to LOG --type WARNING GOOD_HASH_NO_VALUE "${DIR}" "${FNAME}"
					fi
				else
					MISSING=1
					display --to LOG --type WARNING GOOD_HASH_NOT_EXIST "${DIR}" "${FNAME}"
				fi
			else
				if [ -n "${RKHLINE}" ]; then
					MISSING=1
					display --to LOG --type WARNING GOOD_HASH_FILE_NOT_EXIST "${DIR}" "${FNAME}"
				else
					continue
				fi
			fi


			if [ $HASH_OK -eq 0 -a $MISSING -eq 0 ]; then
				for WHITELISTSTRING in `grep '^HASHWHITELIST=' ${CONFIGFILE} | sed -e 's/HASHWHITELIST=//g'`; do
					WHITELISTFILE=`echo ${WHITELISTSTRING} | cut -d: -f1`
					WHITELISTHASH=`echo ${WHITELISTSTRING} | cut -d: -f2`

					if [ "${WHITELISTFILE}" = "${FNAME}" -a "${WHITELISTHASH}" = "${RKHHASH}" ]; then
						HASH_OK=1
						display --to LOG --type INFO GOOD_HASH_WHITELIST "${FNAME}" "${RKHHASH}"
					fi
				done
			fi


			#
			# Now output the results.
			#

			if [ $HASH_OK -eq 1 ]; then
				display --to SCREEN+LOG --type PLAIN --screen-indent 4 --result OK --color GREEN GOOD_HASH_FILENAME "${DIR}" "${FNAME}"
			else
				HASH_DIFFERENT=`expr ${HASH_DIFFERENT} + 1`

				display --to SCREEN+LOG --type PLAIN --screen-indent 4 --result BAD --color RED GOOD_HASH_FILENAME "${DIR}" "${FNAME}"

				if [ $MISSING -eq 0 ]; then
					display --to LOG --type WARNING GOOD_HASH_VALUES_CHANGED
					display --to LOG --type PLAIN --log-indent 9 GOOD_HASH_VALUES_CHANGED2 "${DIR}" "${FNAME}"

					if [ "${SYSHASH}" != "${RKHHASH}" ]; then
						if [ -z "${SYSHASH}" ]; then
							display --to LOG --type PLAIN --log-indent 9 GOOD_HASH_HASH_UNAVAIL
						else
							display --to LOG --type PLAIN --log-indent 9 GOOD_HASH_HASH_CHANGED "${SYSHASH}"
						fi

						display --to LOG --type PLAIN --log-indent 9 GOOD_HASH_DB_CHANGED "${RKHHASH}"
					fi

					if [ "${SYSPERM}" != "${RKHPERM}" -o -n "${WRITE_PERM}" ]; then
						display --to LOG --type PLAIN --log-indent 9 GOOD_HASH_PERM_CHANGED "${SYSPERM}" "${RKHPERM}"
						test -n "${WRITE_PERM}" && display --to LOG --type PLAIN --log-indent 9 GOOD_HASH_WRITE_PERM_SET
					fi

					test "${SYSINODE}" != "${RKHINODE}" && display --to LOG --type PLAIN --log-indent 9 GOOD_HASH_INODE_CHANGED "${SYSINODE}" "${RKHINODE}"
					test "${SYSUID}" != "${RKHUID}" && display --to LOG --type PLAIN --log-indent 9 GOOD_HASH_UID_CHANGED "${SYSUID}" "${RKHUID}"
					test "${SYSGID}" != "${RKHGID}" && display --to LOG --type PLAIN --log-indent 9 GOOD_HASH_GID_CHANGED "${SYSGID}" "${RKHGID}"
					test "${SYSDTM}" != "${RKHDTM}" && display --to LOG --type PLAIN --log-indent 9 GOOD_HASH_DTM_CHANGED "${SYSDTM}" "${RKHDTM}"
				fi
			fi
		done
	done


	if [ $HASH_COUNT -eq 0 ]; then
		display --to SCREEN+LOG --type WARNING --screen-indent 2 GOOD_HASH_NO_HASHES
	fi

	keypresspause

	return
}


do_script_replacement_check() {

# jh - move this up in to the hash check. Rename hash to property.
	#
	# This function carries out a check of the system commands to
	# see if any have been replaced by a script.
	#

	if ! `check_test scripts`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST scripts
		return
	fi


	display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 SCRIPTS_START


	#
	# We only perform the test if we have the 'file' command.
	#

	if [ -z "${FILE_CMD}" ]; then
		display --to SCREEN+LOG --type WARNING --result SKIPPED --color YELLOW --screen-indent 4 SCRIPTS_CHECK_SKIP
		return
	fi


	#
	# Otherwise, just carry on with the checks.
	#

	for DIR in ${HASHDIRS}; do
		for FNAME in ${HASHFILES}; do
			if [ -f "${DIR}/${FNAME}" -a ! -h "${DIR}/${FNAME}" ]; then
				SCRIPT_REPL=`${FILE_CMD} ${DIR}/${FNAME} 2>&1 | egrep -i ' script( |$)'`

				#
				# See if the command is whitelisted.
				#

				if [ -n "${SCRIPT_REPL}" ]; then
					for WHITELISTFILE in `grep '^ALLOWSCRIPTCMD=' ${CONFIGFILE} | sed -e 's/ALLOWSCRIPTCMD=//g'`; do
						if [ "${WHITELISTFILE}" = "${DIR}/${FNAME}" ]; then
							SCRIPT_REPL="whitelisted"
							break
						fi
					done
				fi


				#
				# Now output the result.
				#

				if [ -z "${SCRIPT_REPL}" ]; then
					display --to SCREEN+LOG --type PLAIN --screen-indent 4 --result OK --color GREEN GOOD_HASH_FILENAME "${DIR}" "${FNAME}"
				elif [ "${SCRIPT_REPL}" = "whitelisted" ]; then
					display --to SCREEN+LOG --type PLAIN --screen-indent 4 --result OK --color GREEN GOOD_HASH_FILENAME "${DIR}" "${FNAME}"
					display --to LOG --type INFO SCRIPTS_WHITELIST "${DIR}/${FNAME}"
				else
					display --to SCREEN+LOG --type PLAIN --screen-indent 4 --result BAD --color RED GOOD_HASH_FILENAME "${DIR}" "${FNAME}"
					display --to LOG --type WARNING SCRIPTS_FILE_REPLACED "${DIR}/${FNAME}" "${SCRIPT_REPL}"
				fi
			fi
		done
	done


	keypresspause

	return
}


do_system_commands_checks() {

	#
	# This function carries out a sequence of tests on
	# system commands. These consist of the 'strings' command
	# check, library checks and the file hash check.
	#

	if ! `check_test system_commands`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST system_commands
		return
	fi


	display --to SCREEN+LOG --type PLAIN --color YELLOW --nl CHECK_SYS_COMMANDS


	do_strings_check

	do_shared_libs_check

	do_known_good_hash_check

	do_script_replacement_check

	return
}


do_rootkit_file_dir_checks() {

	#
	# This function performs the rootkit default files
	# and directories checks.
	#

	display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 ROOTKIT_FILES_DIRS_START


	# 55808 Trojan - Variant A

	SCAN_ROOTKIT="55808 Trojan - Variant A"
	SCAN_FILES=${W55808A_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# ADM worm

	SIZE="13"
	jump=`expr ${defaultcolumn} - ${SIZE}`

	displaytext -n "   ADM Worm... "
	insertlayout
	logtext -n "Checking /etc/passwd for presence of ADM worm"
	if [ -f "${ROOTDIR}/etc/passwd" ]; then
		WORM=`grep 'w0rm' ${ROOTDIR}/etc/passwd`
		if [ "${WORM}" = "" ]; then
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			logtext --nodate "OK"
		else
			displaytext $E "${LAYOUT}[ ${RED}BAD${NORMAL} ]"
			logtext --nodate "Warning! Possible ADM w0rm found"
			displaytext "${FOUNDTRACES}"
		fi
	else
		displaytext $E "${LAYOUT}[ ${YELLOW}Skipped${NORMAL} ]"
		logtext --nodate "skipped"
		logtext "ADM worm check skipped because ${ROOTDIR}/etc/passwd does not exist."
	fi

	# AjaKit

	SCAN_ROOTKIT="AjaKit"
	SCAN_FILES=${AJAKIT_FILES}
	SCAN_DIRS=${AJAKIT_DIRS}
	SCAN_KSYMS=${AJAKIT_KSYMS}
	scanrootkit

	# aPa Kit

	SCAN_ROOTKIT="aPa Kit"
	SCAN_FILES=${APAKIT_FILES}
	SCAN_DIRS=${APAKIT_DIRS}
	SCAN_KSYMS=${APAKIT_KSYMS}
	scanrootkit

	# Apache worm

	SCAN_ROOTKIT="Apache Worm"
	SCAN_FILES=${APACHEWORM_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# Ambient (ark) Rootkit

	SCAN_ROOTKIT="Ambient (ark) Rootkit"
	SCAN_FILES=${ARK_FILES}
	SCAN_DIRS=${ARK_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Balaur Rootkit

	SCAN_ROOTKIT="Balaur Rootkit"
	SCAN_FILES=${BALAUR_FILES}
	SCAN_DIRS=${BALAUR_DIRS}
	SCAN_KSYMS=${BALAUR_KSYMS}
	scanrootkit

	# BeastKit

	SCAN_ROOTKIT="BeastKit"
	SCAN_FILES=${BEASTKIT_FILES}
	SCAN_DIRS=${BEASTKIT_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# beX2
	SCAN_ROOTKIT="beX2"
	SCAN_FILES=${BEX_FILES}
	SCAN_DIRS=${BEX_DIRS}
	SCAN_KSYMS=${BEX_KSYMS}
	scanrootkit

	# BOBKit

	SCAN_ROOTKIT="BOBKit"
	SCAN_FILES=${BOBKIT_FILES}
	SCAN_DIRS=${BOBKIT_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# CiNIK Worm (Slapper.B variant)
	SCAN_ROOTKIT="CiNIK Worm (Slapper.B variant)"
	SCAN_FILES=${CINIK_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# Danny-Boy's Abuse Kit

	SCAN_ROOTKIT="Danny-Boy's Abuse Kit"
	SCAN_FILES=${DANNYBOYS_FILES}
	SCAN_DIRS=${DANNYBOYS_DIRS}
	SCAN_KSYMS=${DANNYBOYS_KSYMS}
	scanrootkit

	# Devil RootKit

	SCAN_ROOTKIT="Devil RootKit"
	SCAN_FILES=${DEVIL_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# Dica

	SCAN_ROOTKIT="Dica"
	SCAN_FILES=${DICA_FILES}
	SCAN_DIRS=${DICA_DIRS}
	SCAN_KSYMS=${DICA_KSYMS}
	scanrootkit

	# Dreams RootKit

	SCAN_ROOTKIT="Dreams Rootkit"
	SCAN_FILES=${DREAMS_FILES}
	SCAN_DIRS=${DREAMS_DIRS}
	SCAN_KSYMS=${DREAMS_KSYMS}
	scanrootkit

	# Duarawkz

	SCAN_ROOTKIT="Duarawkz"
	SCAN_FILES=${DUARAWKZ_FILES}
	SCAN_DIRS=${DUARAWKZ_DIRS}
	SCAN_KSYMS=${DUARAWKZ_KSYMS}
	scanrootkit

	# Enye LKM

	SCAN_ROOTKIT="Enye LKM"
	SCAN_FILES=${ENYELKM_FILES}
	SCAN_DIRS=${ENYELKM_DIRS}
	SCAN_KSYMS=${ENYELKM_KSYMS}
	scanrootkit

	# Flea Linux rootkit

	SCAN_ROOTKIT="Flea Linux Rootkit"
	SCAN_FILES=${FLEA_FILES}
	SCAN_DIRS=${FLEA_DIRS}
	SCAN_KSYMS=${FLEA_KSYMS}
	scanrootkit

	# FreeBSD Rootkit

	SCAN_ROOTKIT="FreeBSD Rootkit"
	SCAN_FILES=${FREEBSD_RK_FILES}
	SCAN_DIRS=${FREEBSD_RK_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Fuck`it Rootkit

	SCAN_ROOTKIT="Fuck\`it Rootkit"
	SCAN_FILES=${FUCKIT_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# GasKit

	SCAN_ROOTKIT="GasKit"
	SCAN_FILES=${GASKIT_FILES}
	SCAN_DIRS=${GASKIT_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Heroin

	SCAN_ROOTKIT="Heroin LKM"
	SCAN_FILES=${HEROIN_FILES}
	SCAN_DIRS=${HEROIN_DIRS}
	SCAN_KSYMS=${HEROIN_KSYMS}
	scanrootkit

	# HjC Kit

	SCAN_ROOTKIT="HjC Kit"
	SCAN_FILES=${HJCKIT_FILES}
	SCAN_DIRS=${HJCKIT_DIRS}
	SCAN_KSYMS=${HJCKIT_KSYMS}
	scanrootkit

	# ignoKit

	SCAN_ROOTKIT="ignoKit"
	SCAN_FILES=${IGNOKIT_FILES}
	SCAN_DIRS=${IGNOKIT_DIRS}
	SCAN_KSYMS=${IGNOKIT_KSYMS}
	scanrootkit

	# ImperalsS-FBRK

	SCAN_ROOTKIT="ImperalsS-FBRK"
	SCAN_FILES=""
	SCAN_DIRS=${IMPFRB_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Irix Rootkit

	SCAN_ROOTKIT="Irix Rootkit"
	SCAN_FILES=${IRIXRK_FILES}
	SCAN_DIRS=${IRIXRK_DIRS}
	SCAN_KSYMS=${IRIXRK_KSYMS}
	scanrootkit

	# Kitko

	SCAN_ROOTKIT="Kitko"
	SCAN_FILES=${KITKO_FILES}
	SCAN_DIRS=${KITKO_DIRS}
	SCAN_KSYMS=${KITKO_KSYMS}
	scanrootkit

	# Knark

	SCAN_ROOTKIT="Knark"
	SCAN_FILES=${KNARK_FILES}
	SCAN_DIRS=${KNARK_DIRS}
	SCAN_KSYMS=${KNARK_KSYMS}
	scanrootkit

	# Li0n Worm

	SCAN_ROOTKIT="Li0n Worm"
	SCAN_FILES=${LION_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# Lockit / LJK2

	SCAN_ROOTKIT="Lockit / LJK2"
	SCAN_FILES=${LOCKIT_FILES}
	SCAN_DIRS=${LOCKIT_DIRS}
	SCAN_KSYMS=${LOCKIT_KSYMS}
	scanrootkit

	# Mood-NT

	SCAN_ROOTKIT="Mood-NT"
	SCAN_FILES=${MOODNT_FILES}
	SCAN_DIRS=${MOODNT_DIRS}
	SCAN_KSYMS=${MOODNT_KSYMS}
	scanrootkit

	# MRK (MiCrobul RootKit?)

	SCAN_ROOTKIT="MRK"
	SCAN_FILES=${MRK_FILES}
	SCAN_DIRS=${MRK_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Ni0 Rootkit

	SCAN_ROOTKIT="Ni0 Rootkit"
	SCAN_FILES=${NIO_FILES}
	SCAN_DIRS=${NIO_DIRS}
	SCAN_KSYMS=${NIO_KSYMS}
	scanrootkit

	# RootKit for SunOS / NSDAP

	SCAN_ROOTKIT="RootKit for SunOS / NSDAP"
	SCAN_FILES=${NSDAP_FILES}
	SCAN_DIRS=${NSDAP_DIRS}
	SCAN_KSYMS=${NSDAP_KSYMS}
	scanrootkit

	# Optic Kit Worm

	SCAN_ROOTKIT="Optic Kit (Tux)"
	SCAN_FILES=""
	SCAN_DIRS=${OPTICKIT_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Oz Rootkit

	SCAN_ROOTKIT="Oz Rootkit"
	SCAN_FILES=${OZ_FILES}
	SCAN_DIRS=${OZ_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Phalanx

	SCAN_ROOTKIT="Phalanx"
	SCAN_FILES=${PHALANX_FILES}
	SCAN_DIRS="${PHALANX_DIRS}"
	SCAN_KSYMS="${PHALANX_KSYMS}"
	scanrootkit

	if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
		STATUS=0
		SIZE=28

		logtext "Debug: Phalanx (strings)"
		displaytext -n "   Rootkit 'Phalanx' (strings)"

		# Search for Phalanx in /bin/hostname
		if [ -f "${ROOTDIR}/bin/hostname" ]; then
			if `grep -q 'phalanx' ${ROOTDIR}/bin/hostname >/dev/null 2>&1`; then
				STATUS=1
			fi
		fi

		if [ ${STATUS} -eq 0 ]; then
			jump=`expr ${defaultcolumn} - ${SIZE}`
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		else
			jump=`expr ${defaultcolumn} - ${SIZE}`
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
			displaytext "${FOUNDTRACES}"
		fi
	fi

	# Portacelo

	SCAN_ROOTKIT="Portacelo"
	SCAN_FILES=${PORTACELO_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# R3dstorm Toolkit

	SCAN_ROOTKIT="R3dstorm Toolkit"
	SCAN_FILES=${REDSTORM_FILES}
	SCAN_DIRS=${REDSTORM_DIRS}
	SCAN_KSYMS=${REDSTORM_KSYMS}
	scanrootkit

	# RH-Sharpe's rootkit

	SCAN_ROOTKIT="RH-Sharpe's rootkit"
	SCAN_FILES=${RHSHARPES_FILES}
	SCAN_DIRS=${RHSHARPES_DIRS}
	SCAN_KSYMS=${RHSHARPES_KSYMS}
	scanrootkit

	# RSHA's rootkit

	SCAN_ROOTKIT="RSHA's rootkit"
	SCAN_FILES=${RSHA_FILES}
	SCAN_DIRS=${RSHA_DIRS}
	SCAN_KSYMS=${RSHA_KSYMS}
	scanrootkit

	# Sebek LKM (Honeypot)

	STATUS=0
	SIZE=13

	logtext "Debug: Sebek LKM"
	displaytext -n "   Sebek LKM..."

	# Search for signs of Sebek in ksyms and kallsyms files
	if [ -n "${KSYMS_FILE}" ]; then
		if `egrep -i 'adore|sebek' ${KSYMS_FILE} >/dev/null 2>&1`; then
			STATUS=1
		fi
	fi

	if [ ${STATUS} -eq 0 ]; then
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
	else
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
		displaytext "${FOUNDTRACES}"
	fi

	# Scalper Worm

	SCAN_ROOTKIT="Scalper Worm"
	SCAN_FILES=${SCALPER_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# Shutdown

	SCAN_ROOTKIT="Shutdown"
	SCAN_FILES=${SHUTDOWN_FILES}
	SCAN_DIRS=${SHUTDOWN_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# SHV4 Rootkit

	SCAN_ROOTKIT="SHV4"
	SCAN_FILES=${SHV4_FILES}
	SCAN_DIRS=${SHV4_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# SHV5 Rootkit

	SCAN_ROOTKIT="SHV5"
	SCAN_FILES=${SHV5_FILES}
	SCAN_DIRS=${SHV5_DIRS}
	SCAN_KSYMS=${SHV5_KSYMS}
	scanrootkit

	# Sin Rootkit

	SCAN_ROOTKIT="Sin Rootkit"
	SCAN_FILES=${SINROOTKIT_FILES}
	SCAN_DIRS=${SINROOTKIT_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Slapper

	SCAN_ROOTKIT="Slapper"
	SCAN_FILES=${SLAPPER_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# Sneakin Rootkit

	SCAN_ROOTKIT="Sneakin Rootkit"
	SCAN_FILES=""
	SCAN_DIRS=${SNEAKIN_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Suckit Rootkit

	SCAN_ROOTKIT="Suckit Rootkit"
	SCAN_FILES=${SUCKIT_FILES}
	SCAN_DIRS=${SUCKIT_DIRS}
	SCAN_KSYMS=""
	scanrootkit
	scanrootkit_suckit_extra_checks

	# SunOS Rootkit

	SCAN_ROOTKIT="SunOS Rootkit"
	SCAN_FILES=${SUNOSROOTKIT_FILES}
	SCAN_DIRS=${SUNOSROOTKIT_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Superkit

	SCAN_ROOTKIT="Superkit"
	SCAN_FILES=${SUPERKIT_FILES}
	SCAN_DIRS=${SUPERKIT_DIRS}
	SCAN_KSYMS=${SUPERKIT_KSYMS}
	scanrootkit

	# TBD (Telnet BackDoor)

	SCAN_ROOTKIT="TBD (Telnet BackDoor)"
	SCAN_FILES=${TBD_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# TeLeKiT

	SCAN_ROOTKIT="TeLeKiT"
	SCAN_FILES=${TELEKIT_FILES}
	SCAN_DIRS=${TELEKIT_DIRS}
	SCAN_KSYMS=${TELEKIT_KSYMS}
	scanrootkit


	# T0rn Rootkit

	SCAN_ROOTKIT="T0rn Rootkit"
	SCAN_FILES=${TORN_FILES}
	SCAN_DIRS=${TORN_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Trojanit Kit

	SCAN_ROOTKIT="Trojanit Kit"
	SCAN_FILES=${TROJANIT_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# Tuxtendo

	SCAN_ROOTKIT="Tuxtendo"
	SCAN_FILES=${TUXTENDO_FILES}
	SCAN_DIRS=${TUXTENDO_DIRS}
	SCAN_KSYMS=${TUXTENDO_KSYMS}
	scanrootkit

	# URK (Universal Root Kit)

	SCAN_ROOTKIT="URK"
	SCAN_FILES=${URK_FILES}
	SCAN_DIRS=${URK_DIRS}
	SCAN_KSYMS=${URK_KSYMS}
	scanrootkit

	# VcKit

	SCAN_ROOTKIT="VcKit"
	SCAN_FILES=${VCKIT_FILES}
	SCAN_DIRS=${VCKIT_DIRS}
	SCAN_KSYMS=${VCKIT_KSYMS}
	scanrootkit

	# Volc Rootkit

	SCAN_ROOTKIT="Volc Rootkit"
	SCAN_FILES=${VOLC_FILES}
	SCAN_DIRS=${VOLC_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# X-Org SunOS Rootkit

	SCAN_ROOTKIT="X-Org SunOS Rootkit"
	SCAN_FILES=${XORGSUNOS_FILES}
	SCAN_DIRS=${XORGSUNOS_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# zaRwT.KiT

	SCAN_ROOTKIT="zaRwT.KiT Rootkit"
	SCAN_FILES=${ZARWT_FILES}
	SCAN_DIRS=${ZARWT_DIRS}
	SCAN_KSYMS=""
	scanrootkit


	keypresspause

	return
}


do_malware_checks() {

	#
	# This function performs malware checks.
	#

	display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 ROOTKIT_MALWARE_START


	SIZE=35
	displaytext -n "   Scanning for known rootkit strings"
	logtext "[Start string tests]"

	if [ -n "${STRINGS_CMD}" ]; then
		FOUND=0
		for I in ${STRINGSCAN}; do
			TYPE=`echo $I | cut -d: -f1`
			FILE=`echo $I | cut -d: -f2 | sed -e 's/%%/ /g'`
			FILESTRING=`echo $I | cut -d: -f3 | sed -e 's/%%/ /g'`
			INFO=`echo $I | cut -d: -f4 | sed -e 's/%%/ /g'`
			FOUNDFILE=0
			case "${TYPE}" in
			bin)
				for I in ${BINPATHS}; do
					FILENAME="${I}/${FILE}"
					if [ -f "$FILENAME" ]; then
						FSTRING=`echo "${FILESTRING}" | sed -e 's/\./\\\./g'`
						FOUNDSTRING=`${STRINGS_CMD} $FILENAME | grep "${FSTRING}"`
						if [ "${FOUNDSTRING}" = "" ]; then
							logtext "${FILENAME} clean (string: $FILESTRING)"
						else
							logtext "Warning: ${FILENAME} NOT clean (string: $FILESTRING)"
							FOUND=1
						fi
					fi
				done
				;;
			esac
		done

		if [ ${FOUND} -eq 1 ]; then
			jump=`expr ${defaultcolumn} - ${SIZE}`
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}BAD${NORMAL} ]"
			displaytext "Warning: Found unexpected strings in some files! Check the logfile for more details"
			logtext "Warning: Found unexpected strings in some files!"
		else
			jump=`expr ${defaultcolumn} - ${SIZE}`
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			logtext "All files are OK"
		fi
	else
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${YELLOW}Skipped${NORMAL} ]"
		logtext "Skipped stringtest (rootkit strings), due to missing 'strings' command"
	fi

	logtext "[End string tests]"

	SIZE=33
	displaytext -n "   Scanning for known rootkit files"

	for I in ${FILESCAN}; do
		TYPE=`echo $I | cut -d: -f1`
		FILE=`echo $I | cut -d: -f2`
		INFO=`echo $I | cut -d: -f3`
		FOUNDFILE=0
		FILE=`echo ${FILE} | sed -e 's/%%/ /g'`
		INFO=`echo ${INFO} | sed -e 's/%%/ /g'`

		logtext -n "Scanning for presence of ${FILE} (${TYPE})... "
		case "${TYPE}" in
		dir)
			if [ -d "${FILE}" ]; then
				FOUNDFILE=1
				logtext --nodate "WARNING! Found possible bad directory"
			else
				logtext --nodate "OK (not found)"
			fi
			;;
		file)
			if [ -f "{$FILE}" ]; then
				FOUNDFILE=1
				logtext --nodate "WARNING! Found possible bad file"
			else
				logtext --nodate "OK (not found)"
			fi
			;;
		esac
	done

	if [ ${FOUNDFILE} -eq 0 ]; then
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
	else
		INFECTED_COUNT=`expr ${INFECTED_COUNT} + 1`
		INFECTED_NAMES="${INFECTED_NAMES} / ${INFO} "
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
		displaytext "
		-------------------------------------------------------------------------
		Warning found file '${FILE}'
		Information: ${INFO}
		-------------------------------------------------------------------------
		"
	fi

	logtext "-------------------------- Open files tests ---------------------------"

	SUSP_FILES_INFO="
adore.o:Adore%%LKM%%rootkit
mod_rootme.so:Apache%%mod_rootme%%backdoor
phide_mod.o:PID%%hider%%LKM
lbk.ko:LBK%%FreeBSD%%kernel%%module
vlogger.o:THC-Vlogger%%kernel%%module
cleaner.o:Cleaner%%kernel%%module
mod_klgr.o:klgr,%%keyboard%%logger%%(kernel%%module)
hydra:THC-Hydra%%(password%%capture)
hydra.restore:THC-Hydra%%(password%%capture)
"

	displaytext -n "   Testing running processes... "
	logtext -n "Scanning running processes... "
	SIZE="30"
	jump=`expr ${defaultcolumn} - ${SIZE}`

	if [ -n "${LSOF_CMD}" ]; then
		SUSP_FILES="backdoor"
		# Add more suspicious files to the check
		for I in ${SUSP_FILES_INFO}; do
			FILENAME=`echo ${I} | cut -d: -f1 | sed -e 's/\./\\\./g'`
			SUSP_FILES="${SUSP_FILES}|${FILENAME}"
		done
		SEARCHFILES=`${LSOF_CMD} -F n -w | sort | uniq | grep '^n/' | sed -e 's/^n//' | egrep "/(${SUSP_FILES})$"`
		if [ ! "${SEARCHFILES}" = "" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}BAD${NORMAL} ]"
			logtext --nodate "Bad"
			logtext "Warning! Found possible harmful files. Please inspect"
			logtext "Warning! Output of test: ${SEARCHFILES}"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			logtext --nodate "OK"
		fi
		SUSP_FILES=`echo "${SUSP_FILES}" | sed -e 's/\\\././g'`
		logtext "Scanned for '${SUSP_FILES}'"
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${YELLOW}Skipped${NORMAL} ]"
		logtext --nodate "Skipped"
	fi

	UNHIDE_CMD=`find_cmd unhide`
	if [ -n "${UNHIDE_CMD}" ]; then
		logtext -n "Scanning hidden processes... "
		SIZE="30"
		jump=`expr ${defaultcolumn} - ${SIZE}`

		UNHIDEPROCS=`${UNHIDE_CMD} sys | grep '^F' | awk -F':' '{ print $2 }'`
		if [ -n "${UNHIDEPROCS}" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}BAD${NORMAL} ]"
			logtext --nodate "Bad"
			logtext "Warning! Hidden PIDs found: ${UNHIDEPROCS}"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			logtext --nodate "OK"
		fi

		logtext "Scanned for hidden processes"
	fi


	if `check_test deleted_files`; then
		displaytext -n "   Checking processes for deleted files... "
		logtext -n "Scanning processes for deleted files... "
		SIZE="41"
		jump=`expr ${defaultcolumn} - ${SIZE}`

		if [ -n "${LSOF_CMD}" ]; then
			STATUS=0
			WHITEPROC=""; BLACKPROC=""
			SEARCHFILES=`${LSOF_CMD} -n -l -w | grep '(dele' | head -n 1`
			if [ ! "${SEARCHFILES}" = "" ]; then
				PMATCH=1; PIDLIST=""
				OLDIFS=$IFS
				IFS="
"
				for line in `${LSOF_CMD} -n -l -w | grep '(dele'`; do
					lproc=`echo $line | awk '{ print $1 }'`
					lpid=`echo $line | awk '{ print $2 }'`
					l8=`echo $line | awk '{ print $8 }'`
					lfile=`echo $line | awk '{ print $9 }'`
					for i in $PIDLIST; do
						i=`echo $i | cut -d' ' -f1`
						if [ $lpid -eq $i ]; then
							PMATCH=0
						fi
					done
					if [ $PMATCH -eq 1 ]; then
						if [ -n "${READLINK_CMD}" ]; then
							if [ "${OPERATING_SYSTEM}" != "SunOS" -o -h /proc/${lpid}/exe ]; then
								lproc=`${READLINK_CMD} /proc/${lpid}/exe`
							fi
						fi
						# If $lfile is not a pathname then look at $l8
						if [ -z "`echo ${lfile} | grep '^/'`" ]; then
							if [ -n "`echo ${l8} | grep '^/'`" ]; then
								lfile=$l8
							fi
						fi
						# Remove anything after the pathname
						if [ -n "`echo ${lfile} | grep '^/'`" ]; then
							lfile=`echo ${lfile} | cut -d' ' -f1`
						fi
						ALLOWPROCDELFILES=`grep '^ALLOWPROCDELFILE=' ${CONFIGFILE} | sed -e 's/ALLOWPROCDELFILE=//g'`
						FMATCH=1
						for i in $ALLOWPROCDELFILES; do
							if [ "$lproc" = "$i" ]; then
								FMATCH=0; break
							fi
						done
						if [ -z "${READLINK_CMD}" ]; then
							lproc="\"$lproc\""
						fi
						if [ $FMATCH -eq 0 ]; then
							if [ -z "`echo ${WHITEPROC} | egrep \"${lproc}( |$)\"`" ]; then
								WHITEPROC="${WHITEPROC} ${lproc}"
							fi
						else
							STATUS=1
							BLACKPROC="${BLACKPROC}\\n${lproc} ${lpid} ${lfile}"
						fi
					fi
					PIDLIST="$lpid $PIDLIST"
				done
				IFS=$OLDIFS
			fi

			insertlayout

			if [ $STATUS -eq 0 ]; then
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
				logtext --nodate "OK"
			else
				displaytext $E "${LAYOUT}[ ${RED}BAD${NORMAL} ]"
				logtext --nodate "Bad"
				logtext "Warning! Found deleted files in use. Please inspect:"

				echo $E $BLACKPROC \
				| while read lproc lpid lfile; do
					if [ -n "$lproc" ]; then
						logtext "Warning! Process ${lproc} (${lpid}) used deleted file ${lfile}"
						displaytext "Warning! Process ${lproc} (${lpid}) used deleted file ${lfile}"
					fi
				done
			fi

			for lproc in $WHITEPROC; do
				logtext "Found process ${lproc} on whitelist"
			done

			logtext "Scanned for deleted files"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${YELLOW}Skipped${NORMAL} ]"
			logtext --nodate "Skipped"
		fi
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST deleted_files
	fi # end CHKDEL


	logtext "----------------------- Login backdoors check -------------------------"


	# Miscellaneous Login backdoors

	STATUS=0
	SIZE=30

	displaytext -n "   Miscellaneous Login backdoors"

	for I in ${LOGIN_BACKDOORS_FILES}; do
		if [ -d "${I}" ]; then
			STATUS=1
			logtext "${I} found! Possible part of a rootkit/trojan."
		else
			logtext "${I} clean"
		fi
	done

	if [ ${STATUS} -eq 0 ]; then
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
	else
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
	fi


	STATUS=0
	SIZE=26

	displaytext -n "   Miscellaneous directories"

	for I in ${SUSPICIOUS1_DIRS}; do
		logtext -n "Checking ${I}... "
		if [ -f "${I}" ]; then
			STATUS=1
			logtext --nodate "[ WARNING! ] Possible part of a rootkit/trojan."
		else
			logtext --nodate "[ OK ] Not found"
		fi
	done

	if [ ${STATUS} -eq 0 ]; then
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
	else
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
	fi

	# Software related files

	STATUS=0
	SIZE=23
	FOUND=0

	displaytext -n "   Software related files"
	logtext "Scanning for software related files and intrusions..."

	TRIPWIREFILE="${ROOTDIR}/var/lib/tripwire/`uname -n 2>/dev/null`.twd"

	if [ -f "${TRIPWIREFILE}" ]; then
		FOUND=1
		if [ -z "`grep 'Tripwire segment-faulted !' ${TRIPWIREFILE}`" ]; then
			jump=`expr ${defaultcolumn} - ${SIZE}`
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		else
			jump=`expr ${defaultcolumn} - ${SIZE}`
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}BAD${NORMAL} ]"
			logtext "The file ${TRIPWIREFILE} contains a very suspicious text string, which"
			logtext "can indicate the presence of the SHV5 rootkit."
		fi
	fi

	# No traces found
	if [ ${FOUND} -eq 0 ]; then
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
	fi



	# Sniffer logs

	STATUS=0
	SIZE=13

	displaytext -n "   Sniffer logs"

	for I in ${SNIFFER_FILES}; do
		logtext -n "Checking ${I}... "
		if [ -f "${I}" ]; then
			STATUS=1
			logtext --nodate "[ WARNING! ] Possible sniffer log found."
		else
			logtext --nodate "[ OK ] Not found"
		fi
	done

	if [ ${STATUS} -eq 0 ]; then
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
	else
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
	fi

	keypresspause

	displaytext ""
	displaytext "* Trojan specific characteristics${NORMAL}"

	displaytext "   shv4"

	SIZE="32"
	jump=`expr ${defaultcolumn} - ${SIZE}`
	if [ "${OPERATING_SYSTEM}" = "AIX" ]; then
		RCFILE="/etc/inittab"
	else
		RCFILE="/etc/rc.d/rc.sysinit"
	fi
	displaytext -n "     Checking ${RCFILE}"
	if [ -f "${RCFILE}" ]; then
		# Insert end-of-line
		displaytext ""
		SIZE="11"
		jump=`expr ${defaultcolumn} - ${SIZE}`

		displaytext -n "       Test 1"
		if [ -n "`grep 'in\.inetd' ${RCFILE}`" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}Clean${NORMAL} ]"
		fi

		displaytext -n "       Test 2"
		if [ -n "`grep 'bin/xchk' ${RCFILE}`" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (possible Optic Kit / Tuxkit) ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}Clean${NORMAL} ]"
		fi

		displaytext -n "       Test 3"
		if [ -n "`grep 'bin/xsf' ${RCFILE}`" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (possible Optic Kit / Tuxkit) ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}Clean${NORMAL} ]"
		fi
		
		if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
			displaytext -n "       Test 4"
			if [ -n "`grep '.*#<HIDE_.*>' ${RCFILE}`" ]; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (possible ENYELKM) ]"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}Clean${NORMAL} ]"
			fi
		fi
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}Not found${NORMAL} ]"
	fi

	SIZE="27"
	jump=`expr ${defaultcolumn} - ${SIZE}`
	displaytext -n "     Checking /etc/inetd.conf"

	if [ -f "${ROOTDIR}/etc/inetd.conf" ]; then
		FOUND=0

		grep '/bin/csh' ${ROOTDIR}/etc/inetd.conf >/dev/null && FOUND=1
		grep '/bin/bash' ${ROOTDIR}/etc/inetd.conf >/dev/null && FOUND=1
		grep '/bin/tcsh' ${ROOTDIR}/etc/inetd.conf >/dev/null && FOUND=1
		grep '/bin/ksh' ${ROOTDIR}/etc/inetd.conf >/dev/null && FOUND=1
		grep '/bin/sh' ${ROOTDIR}/etc/inetd.conf >/dev/null && FOUND=1
		grep '/bin/ash' ${ROOTDIR}/etc/inetd.conf >/dev/null && FOUND=1
		grep '/bin/zsh' ${ROOTDIR}/etc/inetd.conf >/dev/null && FOUND=1
		grep 'in\.cfinger' ${ROOTDIR}/etc/inetd.conf >/dev/null && FOUND=1

		if [ $FOUND -eq 1 ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
			logtext "Possible bad string found in ${ROOTDIR}/etc/inetd.conf. Please check this file manually."
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}Clean${NORMAL} ]"
		fi
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}Not found${NORMAL} ]"
	fi


	SIZE="28"
	jump=`expr ${defaultcolumn} - ${SIZE}`
	displaytext -n "     Checking /etc/xinetd.conf"

	# Only check when operating system is Linux and we have a xinetd configuration
	if [ "${OPERATING_SYSTEM}" = "Linux" -a -f "${ROOTDIR}/etc/xinetd.conf" ]; then
		FOUND=0
		logtext "Operating system is Linux and /etc/xinetd.conf found. Starting xinetd configuration scan..."

		incl=`grep 'includedir' ${ROOTDIR}/etc/xinetd.conf | cut -d' ' -f2-`
		if [ -n "$incl" ]; then
			I=`find ${ROOTDIR}${incl}/ -type f`
			WARNINGMSG=""
			for J in ${I}; do
				svc=`grep ".*service." ${J} | grep -v '^#' | cut -d' ' -f2-`
				FOUNDSERVICES=`grep ".*disable.*=.*yes" ${J} | grep -v '#'`
				if [ "${FOUNDSERVICES}" = "" ]; then
					logtext "Info: Service ${J} enabled"
				fi
			done
		fi
		if [ ${FOUND} -eq 0 ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}Clean${NORMAL} ]"
			logtext "xinetd.conf seems to be clean"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
			displaytext "${WARNINGMSG}"
			logtext "There were warnings found while testing xinetd.conf"
		fi

		logtext "End of xinetd configuration scan"
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}Skipped${NORMAL} ]"
		logtext "Skipped xinetd tests (not Linux or file doesn't exists)"
	fi


	displaytext ""
	displaytext "* OS dependent tests${NORMAL}"

	case "${OPERATING_SYSTEM}" in
	*BSD)
		displaytext "   ${WHITE}*BSD${NORMAL}"

		logtext "--------------------- Netstat / Sockstat checks -----------------------"

		SIZE=40
		jump=`expr ${defaultcolumn} - ${SIZE}`

		displaytext -n "     Comparing output sockstat and netstat"
		logtext -n "Comparing output of sockstat and netstat... "

		SOCKSTAT_CMD=`find_cmd sockstat`

		if [ -n "${SOCKSTAT_CMD}" -a -n "${NETSTAT_CMD}" -a -n "${SORT_CMD}" -a -n "${UNIQ_CMD}" ]; then
			SOCKSTAT=`${SOCKSTAT_CMD} -n | grep '\*[:.]\*' | cut -c1-55 | grep '\*[:.]' | cut -c39-47 | grep -v '\*' | tr -d ' ' | ${SORT_CMD} | ${UNIQ_CMD}`
			NETSTAT=`${NETSTAT_CMD} -an | egrep -v 'TIME_WAIT|ESTABLISHED|SYN_SENT|CLOSE_WAIT|LAST_ACK|SYN_RECV|CLOSING' | cut -c1-44 | grep '\*\.' | cut -c24-32 | grep -v '\*' | tr -d ' ' | tr -d '\t' | ${SORT_CMD} | ${UNIQ_CMD}`

			if [ "${SOCKSTAT}" = "${NETSTAT}" ]; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
				logtext --nodate "OK"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
				logtext --nodate "WARNING!"
				logtext "Sockstat tested output: ${SOCKSTAT}"
				logtext "Netstat tested output: ${NETSTAT}"
			fi
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${YELLOW}Skipped${NORMAL} ]"
			logtext --nodate "Skipped"
			test -z "${SOCKSTAT_CMD}" && logtext "No sockstat command found"
			test -z "${NETSTAT_CMD}" && logtext "No netstat command found"
			test -z "${SORT_CMD}" && logtext "No sort command found"
			test -z "${UNIQ_CMD}" && logtext "No uniq command found"
		fi

		displaytext ""
		logtext ""
		;;
	esac


	if [ "${OPERATING_SYSTEM}" = "FreeBSD" ]; then
		displaytext "   ${WHITE}FreeBSD${NORMAL}"

		SIZE=38
		jump=`expr ${defaultcolumn} - ${SIZE}`
		displaytext -n "     Checking presence of KLD signatures"
		logtext -n "Checking presence of KLD signatures "
		STATUS=0
		KLDSTAT_CMD=`find_cmd kldstat`

		if [ -n "${KLDSTAT_CMD}" ]; then
			for I in ${KLDSTATKEYWORDS}; do
				FNAME=`echo "${I}" | sed -e 's/\./\\\./g'`
				PRESENCE=`${KLDSTAT_CMD} -v | grep "${FNAME}"`
				if [ -n "${PRESENCE}" ]; then
					STATUS=1
					FOUNDKEYS="${FOUNDKEYS}${I} "
				fi
			done

			if [ "${STATUS}" -eq 1 ]; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (found terms: ${FOUNDKEYS}) ]"
				logtext --nodate "WARNING!"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
				logtext --nodate "OK"
			fi
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${YELLOW}Skipped${NORMAL} ]"
			logtext --nodate "Skipped"
			logtext "No kldstat command found"
		fi

		logtext "---------------------- Packages database check ------------------------"


		PKGDB_CMD=`find_cmd pkgdb`
		SIZE=29
		jump=`expr ${defaultcolumn} - ${SIZE}`
		displaytext -n "     Checking packages database"
		logtext -n "Checking packages database "

		if [ -n "${PKGDB_CMD}" ]; then
			RESULT=`${PKGDB_CMD} -Fa -v | grep 'Skipped\.'`

			if [ -z "${RESULT}" ]; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
				logtext --nodate "OK"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${YELLOW}Warning${NORMAL} ]"
				logtext --nodate "Warning"
				logtext "Your package databases seems to have inconsistenties. Please run pkgdb -F to"
				logtext "do manual checking. Although this isn't a security issue, you need to be sure"
				logtext "your applications are using the correct dependencies"
			fi
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${YELLOW}Skipped${NORMAL} ]"
			logtext --nodate "Skipped"
			logtext "No pkgdb command found"
		fi
	fi


	if [ ${OPERATING_SYSTEM} = "Linux" ]; then
		temp1=""; temp2=""
		displaytext ""
		displaytext "   ${WHITE}Linux${NORMAL}"

		SIZE=37
		jump=`expr ${defaultcolumn} - ${SIZE}`

		displaytext -n "     Checking loaded kernel modules... "

		temp1=""; temp2=""

		KERNELVERSION=`uname -r | cut -d. -f1,2`

		# Is /proc/modules file available?

		if [ -f "${ROOTDIR}/proc/modules" -a -n "${LSMOD_CMD}" ]; then
			if [ "${KERNELVERSION}" = "2.2" -o "${KERNELVERSION}" = "2.4" ]; then
				# show information found in /proc/modules (Linux-only) and get rid of the spaces
				temp1=`cat ${ROOTDIR}/proc/modules | sort | tr -d ' '`

				# show output from lsmod. Throw away spaces, because they don't match the content
				# of /proc/modules
				temp2=`${LSMOD_CMD} | grep -v 'Size  Used by' | sort | tr -d ' '`
			elif [ "${KERNELVERSION}" = "2.6" ]; then
				temp1=`cat ${ROOTDIR}/proc/modules | sort | tr -s ' ' | cut -d' ' -f1`
				temp2=`${LSMOD_CMD} | grep -v 'Size  Used by' | sort | tr -s ' ' | cut -d' ' -f1`
			fi
		fi

		if [ -n "${temp1}" ]; then
			if [ "${temp1}" = "${temp2}" ]; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (found difference in output) ]"
			fi
		else
			displaytext "${WHITE}Skipped!${NORMAL}"
			if [ -n "${LSMOD_CMD}" ]; then
				logtext "Info: no /proc/modules found. Lsmod test skipped"
			else
				logtext "Info: no 'lsmod' command found. Lsmod test skipped"
			fi
		fi



		logtext "--------------------------- File attributes ---------------------------"

		SIZE=27
		displaytext -n "     Checking file attributes"
# jh - this test needs to go into the hash/property test - for Linux OS only
		jump=`expr ${defaultcolumn} - ${SIZE}`

		FOUND=0

		if [ -n "${LSATTR_CMD}" ]; then
			for I in ${BINPATHS}; do
				logtext "Checking $I file attributes"
				if [ -d "${I}" ]; then
					for J in `ls ${I}`; do
						LSAT=`${LSATTR_CMD} ${I}/${J} 2>/dev/null | cut -d' ' -f1 | grep 'i'`
						if [ -n "${LSAT}" ]; then
							FOUND=1
							logtext "Found 'immutable' binary (${I}/${J})"
						fi
					done
				fi
			done
			if [ ${FOUND} -eq 0 ]; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${YELLOW}Special attributes found!${NORMAL} ]"
				logtext "Found special attributes on some binaries! This can be performed by security software OR"
				logtext "by a rootkit. Please inspect these files and try to find the reason of this immutable flag."
				logtext "See 'man chattr' for more information about this attributes."
			fi
		else
			insertlayout
			displaytext $E "   ${file}${LAYOUT}[ ${WHITE}Skipped!${NORMAL} ]"
		fi


		logtext "----------------------------- LKM modules -----------------------------"

		LKM_BADNAMES="
adore.o
cleaner.o
flkm.o
phide_mod.o
vlogger.o
"

		LKMPATH="/lib/modules/`uname -r 2>/dev/null`"
		FOUND=0


		SIZE=27
		displaytext -n "     Checking LKM module path"
		jump=`expr ${defaultcolumn} - ${SIZE}`

		if [ -d "${LKMPATH}" -a -n "${FIND_CMD}" ]; then
			for J in `${FIND_CMD} ${LKMPATH} -name "*.o" -print`; do
				for I in ${LKM_BADNAMES}; do
					FNAME=`echo "${I}" | sed -e 's/\./\\\./g'`
					if [ ! "`echo ${J} | grep \"/${FNAME}\$\"`" = "" ]; then
						logtext "Warning, possible malicious LKM (filename: ${J} string: ${I}) installed!"
						FOUND=1
					#else
					#	logtext "Checking ${I} in ${J}... Not found"
					fi
				done
			done

			if [ ${FOUND} -eq 0 ]; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
			fi
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${WHITE}Skipped!${NORMAL} ]"
			if [ -n "${FIND_CMD}" ]; then
				logtext "LKM module filename check skipped, because path (${LKMPATH}) doesn't exist"
			else
				logtext "LKM module filename check skipped, because 'find' command doesn't exist"
			fi
		fi

		# End Linux tests
	fi


	keypresspause

	return
}


do_rootkit_checks() {

	#
	# This function carries out a sequence of tests for rootkits.
	# This consists of the default files and directories check,
	# and checks for malware.
	#

	if ! `check_test rootkits`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST rootkits
		return
	fi


	display --to SCREEN+LOG --type PLAIN --color YELLOW --nl CHECK_ROOTKITS


	do_rootkit_file_dir_checks

	do_malware_checks


	return
}


do_network_port_checks() {

	#
	# This function will check the network ports to see
	# if any known backdoor ports are being used.
	#

	#
	# We must check to see who can perform this test.
	#

	case "${OPERATING_SYSTEM}" in
	*BSD|Linux|AIX|SunOS|Darwin)
		;;
	*)
		return
		;;
	esac

	#
	# Systems with a modified kernel must also skip this test.
	#

	test $GRSECINSTALLED -eq 1 && return


	#
	# Now do the test.
	#

	display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 NETWORK_PORTS_START

	if [ ! -f "${DB_PATH}/backdoorports.dat" -o ! -s "${DB_PATH}/backdoorports.dat" ]; then
		display --to SCREEN+LOG --type WARNING --screen-indent 4 NETWORK_PORTS_FILE_MISSING
		return
	fi


	OLDIFS=$IFS
	IFS="
"

	for LINE in `cat ${DB_PATH}/backdoorports.dat`; do
		if [ -n "`echo \"${LINE}\" | egrep -i '^#|version'`" ]; then
			continue
		elif [ -z "${LINE}" ]; then
			continue
		fi

		PORT=`echo "${LINE}" | cut -d: -f1`
		DESCRIPTION=`echo ${LINE} | cut -d: -f2`
		PROTO=`echo ${LINE} | cut -d: -f3 | tr '[a-z]' '[A-Z]'`

		if [ -n "`echo \"${PORT}\" | grep -v '^[0-9]'`" ]; then
			echo "Error: Invalid port in backdoorports.dat: $LINE"
			continue
		elif [ "${PROTO}" != "UDP" -a "${PROTO}" != "TCP" ]; then
			echo "Error: Invalid protocol in backdoorports.dat: $LINE"
			continue
		fi

		case "${OPERATING_SYSTEM}" in
		Linux)
			FOUND=`${NETSTAT_CMD} -an | grep -i "^${PROTO}.*:${PORT} "`
			;;
		*BSD|Darwin)
			FOUND=`${NETSTAT_CMD} -an | grep -i "^${PROTO}.*\.${PORT} "`
			;;
		AIX|SunOS)
			if [ "${PROTO}" = "UDP" ]; then
				FOUND=`${NETSTAT_CMD} -an | grep "\.${PORT} "`
			elif [ "${PROTO}" = "TCP" ]; then
				FOUND=`${NETSTAT_CMD} -an | egrep 'BOUND|ESTABLISH|LISTEN' | grep "\.${PORT} "`
			fi
			;;
		esac


		#
		# Display the result.
		#

		if [ -z "${FOUND}" ]; then
			display --to SCREEN+LOG --type PLAIN --screen-indent 4 --result OK --color GREEN NETWORK_PORTS "${PROTO}" "${PORT}"
		else
			display --to SCREEN+LOG --type PLAIN --screen-indent 4 --result BAD --color RED NETWORK_PORTS "${PROTO}" "${PORT}"
			display --to LOG --type WARNING NETWORK_PORTS_FOUND "${PROTO}" "${PORT}" "${DESCRIPTION}"
		fi
	done

	IFS=$OLDIFS

	return
}


do_network_interface_checks() {

	#
	# This function will check the network interfaces to see
	# if any are in promiscuous mode. It will also check to see
	# if there are any applications running which are capturing
	# network interface packets.
	#

	display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 NETWORK_INTERFACE_START


	PROMISCSCAN1=""; PROMISCSCAN2=""

	if [ "${OPERATING_SYSTEM}" = "OpenBSD" -o "${OPERATING_SYSTEM}" = "AIX" ]; then
		PROMISCSCAN1=`${IFCONFIG_CMD} -a 2>/dev/null | grep -v 'pflog' | grep 'PROMISC'`
	elif [ "${OPERATING_SYSTEM}" = "SunOS" -o "${OPERATING_SYSTEM}" = "NetBSD" ]; then
		PROMISCSCAN1=`${IFCONFIG_CMD} -a 2>/dev/null | grep 'PROMISC'`
	else
		PROMISCSCAN1=`${IFCONFIG_CMD} 2>/dev/null | grep 'PROMISC'`
	fi

	if [ "${OPERATING_SYSTEM}" = "Linux" -a -n "${IP_CMD}" ]; then
		PROMISCSCAN2=`${IP_CMD} -s link | grep 'PROMISC'`
	fi


	#
	# Now show the results of the interface check.
	#

	if [ "${PROMISCSCAN1}" = "" -a "${PROMISCSCAN2}" = "" ]; then
		display --to SCREEN+LOG --type PLAIN --color GREEN --result OK --screen-indent 4 NETWORK_PROMISC_CHECK
	else
		display --to SCREEN+LOG --type PLAIN --color RED --result BAD --screen-indent 4 NETWORK_PROMISC_CHECK


		display --to LOG --type WARNING --log-indent 9 NETWORK_PROMISC_IF

		display --to LOG --type PLAIN --log-indent 9 NETWORK_PROMISC_IF_1 "${PROMISCSCAN1}"

		if [ "${OPERATING_SYSTEM}" = "Linux" -a -n "${PROMISCSCAN2}" ]; then
			PROMISCSCAN2=`echo "${PROMISCSCAN2}" | cut -d: -f2`

			for IFACE in ${PROMISCSCAN2}; do
				display --to LOG --type PLAIN --log-indent 9 NETWORK_PROMISC_IF_2 "${IFACE}"
			done
		fi
	fi


	#
	# For the packet capturing check, we must first see if we
	# are able to run the test. We let the user know if the test
	# was disabled, or if the lsof command is not present.
	#

	test "${OPERATING_SYSTEM}" != "Linux" && return

	test ! -f "${ROOTDIR}/proc/net/packet" && return

	if ! `check_test packet_cap_apps`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST packet_cap_apps
		return
	elif [ -z "${LSOF_CMD}" ]; then
		display --to SCREEN+LOG --type WARNING --color YELLOW --result SKIPPED --screen-indent 4 NETWORK_PACKET_CAP_CHECK
		return
	fi


	#
	# Now run the test.
	#

	STATUS=0
	WHITEPROC=""; BLACKPROC=""

	LIBPCAPRES=`egrep -v '^sk|888e' ${ROOTDIR}/proc/net/packet | cut -c1`

	if [ -n "${LIBPCAPRES}" ]; then
		for INODE in `egrep -v '^sk|888e' ${ROOTDIR}/proc/net/packet | awk '{print $9}'`; do
			for PID in `${LSOF_CMD} -lMnP | grep "$INODE" | awk '{print $2}'`; do
				if [ -n "${READLINK_CMD}" ]; then
					NAME=`${READLINK_CMD} -f ${ROOTDIR}/proc/$PID/exe`
				else
					NAME=`grep '^Name:.' ${ROOTDIR}/proc/$PID/status | sed -e 's/^Name:.//'`
				fi

				AMATCH=1
				ALLOWPROCLISTENERS=`grep '^ALLOWPROCLISTEN=' ${CONFIGFILE} | sed -e 's/ALLOWPROCLISTEN=//g'`

				for RKHTMPVAR in $ALLOWPROCLISTENERS; do
					if [ "${NAME}" = "${RKHTMPVAR}" ]; then
						AMATCH=0; break
					fi
				done

				if [ $AMATCH -eq 0 ]; then
					FNAME=`echo "${NAME}" | sed -e 's/\./\\\./g'`
					if [ -z "`echo ${WHITEPROC} | egrep \"${FNAME}( |$)\"`" ]; then
						WHITEPROC="${WHITEPROC} ${NAME}"
					fi
				else
					STATUS=1
					BLACKPROC="${BLACKPROC}\\n${NAME} ${PID}"
				fi
			done
		done
	fi


	#
	# Now display the results.
	#

	if [ $STATUS -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --color GREEN --result OK --screen-indent 4 NETWORK_PACKET_CAP_CHECK
	else
		display --to SCREEN+LOG --type PLAIN --color RED --result BAD --screen-indent 4 NETWORK_PACKET_CAP_CHECK

		echo ${NEWECHOOPT} $BLACKPROC | \
		while read NAME PID; do
			test -n "${NAME}" && display --to LOG --type WARNING NETWORK_PACKET_CAP_FOUND "${NAME}" "${PID}"
		done
	fi

	for NAME in $WHITEPROC; do
		display --to LOG --type INFO NETWORK_PACKET_CAP_WHITE "${NAME}"
	done

	return
}


do_network_checks() {

	#
	# This function carries out some network checks. This consists
	# of port checks, and some interface checks.
	#

	if ! `check_test network`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST network
		return
	fi


	display --to SCREEN+LOG --type PLAIN --color YELLOW --nl CHECK_NETWORK


	do_network_port_checks

	do_network_interface_checks

	keypresspause

	return
}


do_local_host_checks() {

	#
	# This function carries out a sequence of tests on the local
	# host.
	#

	if ! `check_test local_host`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST local_host
		return
	fi


	display --to SCREEN+LOG --type PLAIN --color YELLOW --nl CHECK_LOCALHOST


	displaytext "* Allround tests${NORMAL}"

	displaytext -n "   Checking hostname... "
	if [ "${HOST_NAME}" = "" ]; then
		displaytext "${RED}Warning. ${NORMAL}Found empty hostname. Some programs don't like this."
	else
		displaytext "${GREEN}Found. ${NORMAL}Hostname is ${HOST_NAME}"
	fi


	FOUND=0
	SIZE=49
	jump=`expr ${defaultcolumn} - ${SIZE}`
	displaytext -n "   Checking for passwordless user accounts... "
	logtext "Checking for passwordless user accounts... "
	if [ -f "${ROOTDIR}/etc/shadow" ]; then
		for I in `cat ${ROOTDIR}/etc/shadow`; do
			USER=`echo "${I}" | cut -d: -f1`
			PASSWORD=`echo "${I}" | cut -d: -f2`
			# Exclude NIS-user (+::::::)
			if [ ! "${USER}" = "+" -a "x${PASSWORD}x" = "xx" ]; then
				FOUND=1
				logtext "Warning! Found passwordless account (${USER})"
				logtext "Check this account and give it a password."
			fi
		done
		if [ ${FOUND} -eq 0 ]; then
			displaytext "${GREEN}OK${NORMAL}"
		else
			displaytext "${RED}Warning!${NORMAL}"
			displaytext "Found passwordless user account. Check the logfile for more information"
			logtext --nodate "OK"
		fi
	else
		insertlayout
		displaytext "${WHITE}Skipped${NORMAL}"
		logtext --nodate "Skipped"
		logtext "Skipped test because /etc/shadow doesn't exist"
	fi



	if `check_test passwd`; then
		displaytext -n "   Checking for differences in user accounts... "
		if [ -f "${ROOTDIR}/etc/passwd" ]; then
			if [ -f "${TMPDIR}/passwd" ]; then
				differences=`diff ${ROOTDIR}/etc/passwd ${TMPDIR}/passwd 2>/dev/null | grep ':'`
				if [ "${differences}" = "" ]; then
					displaytext "${GREEN}OK. ${NORMAL}No differences."
				else
					diffadded=`echo "${differences}" | grep '<'`
					diffremoved=`echo "${differences}" | grep '>'`
					displaytext "${RED}Found differences${NORMAL}"
					displaytext "   Info: "
					displaytext "----------------------"
					displaytext "${differences}"
					displaytext "----------------------"
					if [ ! "${diffadded}" = "" ]; then
						displaytext "   Info: Some items have been added (items marked with '<')"
					fi
					if [ ! "${diffremoved}" = "" ]; then
						displaytext "   Info: Some items have been removed (items marked with '>')"
					fi
				fi
				rm -f ${TMPDIR}/passwd >/dev/null 2>&1
			else
				jump=44
				displaytext $E "${LAYOUT}[ ${YELLOW}NA${NORMAL} ]"
			fi
			cp ${ROOTDIR}/etc/passwd ${TMPDIR}/passwd
		else
			displaytext "${RED}Error. ${NORMAL}Cannot find /etc/passwd"
			logtext "Can't find /etc/passwd file?!?"
		fi

		displaytext -n "   Checking for differences in user groups... "
		if [ -f "${ROOTDIR}/etc/group" ]; then
			if [ -f "${TMPDIR}/group" ]; then
				differences=`diff ${ROOTDIR}/etc/group ${TMPDIR}/group | grep ':'`
				if [ "${differences}" = "" ]; then
					displaytext "${GREEN}OK. ${NORMAL}No differences."
				else
					diffadded=`echo "${differences}" | grep '<'`
					diffremoved=`echo "${differences}" | grep '>'`
					displaytext "${RED}Found differences${NORMAL}"
					displaytext "   Info: "
					displaytext "----------------------"
					displaytext "${differences}"
					displaytext "----------------------"
					if [ ! "${diffadded}" = "" ]; then
						displaytext "   Info: Some items have been added (items marked with '<')"
					fi
					if [ ! "${diffremoved}" = "" ]; then
						displaytext "   Info: Some items have been removed (items marked with '>')"
					fi
				fi
				rm -f ${TMPDIR}/group >/dev/null 2>&1
			else
				displaytext "${YELLOW}Creating file ${NORMAL}It seems this is your first time."
			fi
			cp ${ROOTDIR}/etc/group ${TMPDIR}/group
		else
			displaytext "${RED}Error. ${NORMAL}Cannot find /etc/group"
			logtext "Can't find /etc/group file?!?"
		fi
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST passwd
	fi


	SIZE=42
	jump=`expr ${defaultcolumn} - ${SIZE}`
	displaytext "   Checking boot.local/rc.local file... "

	# Gentoo: /etc/conf.d/local.start
	RCLOCATIONS="${ROOTDIR}/etc/rc.local ${ROOTDIR}/etc/rc.d/rc.local ${ROOTDIR}/usr/local/etc/rc.local ${ROOTDIR}/usr/local/etc/rc.d/rc.local ${ROOTDIR}/etc/conf.d/local.start ${ROOTDIR}/etc/init.d/boot.local"
	FOUNDRCSIGN=0

	for FILE in ${RCLOCATIONS}; do
		FILELENGTH=`echo ${FILE} | wc -c | tr -d ' '`
		SIZE=4
		jump=`expr ${defaultcolumn} - ${SIZE} - ${FILELENGTH}`

		displaytext -n "     - ${FILE}"
		if [ -f "${FILE}" ]; then
			for J in ${RCLOCAL_STRINGS}; do
				STRING=`echo ${J} | cut -d: -f1 | sed -e 's/\./\\\./g'`
				FOUND=`grep "${STRING}" ${FILE}`
				if [ ! "${FOUND}" = "" ]; then
					FOUNDRCSIGN=1
					logtext "Warning! Found unusual string in ${FILE}"
				fi
			done

			if [ "${FOUNDRCSIGN}" -eq 1 ]; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (found unusual signs) ]"
				logtext "Warning! Found unusual string in rc.local/boot.local file"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			fi
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}Not found${NORMAL} ]"
		fi
	done

	FOUNDRCSIGN=0
	COUNTER=0

	SIZE=24
	jump=`expr ${defaultcolumn} - ${SIZE}`
	displaytext -n "   Checking rc.d files... "

	if [ -d "${ROOTDIR}/etc/rc.d" ]; then
		# Insert end-of-line
		displaytext ""
		displaytext -n "     Processing"
		for I in `find ${ROOTDIR}/etc/rc.d/*`; do
			# Only check files, not directories
			if [ -f "${I}" ]; then
				COUNTER=`expr ${COUNTER} + 1`
				if [ ${COUNTER} -eq 40 ]; then
					displaytext "."
					displaytext -n "               "
					COUNTER=0
				else
					displaytext -n "."
				fi
				for J in ${RCLOCAL_STRINGS}; do
					STRING=`echo ${J} | cut -d: -f1 | sed -e 's/\./\\\./g'`
					FOUND=`grep "${STRING}" ${I}`
					if [ ! "${FOUND}" = "" ]; then
						FOUNDRCSIGN=1
					fi
				done
			fi
		done

		# Insert end-of-line
		displaytext ""
		displaytext -n "   Result rc.d files check"
		if [ "${FOUNDRCSIGN}" -eq 1 ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (found unusual things) ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		fi
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}Not found${NORMAL} ]"
	fi

	if [ -f "${ROOTDIR}/etc/conf.d/local.start" ]; then
		SIZE=37
		jump=`expr ${defaultcolumn} - ${SIZE}`
		displaytext -n "   Checking Gentoo local.start file... "
		logtext "Found ${ROOTDIR}/etc/conf.d/local.start file (Gentoo)"

		INSPECTLINES=`grep -v '^#' ${ROOTDIR}/etc/conf.d/local.start | grep -v '^$'`

		for J in ${RCLOCAL_STRINGS}; do
			STRING=`echo ${J} | cut -d: -f1 | sed -e 's/\./\\\./g'`
			FOUND=`echo ${INSPECTLINES} | grep "${STRING}"`
			if [ ! "${FOUND}" = "" ]; then
				FOUNDRCSIGN=1
				logtext "Found ${FOUND} while checking ${ROOTDIR}/etc/conf.d/local.start"
			fi
		done

		if [ "${FOUNDRCSIGN}" -eq 1 ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		fi
	fi


	logtext "---------------------------- History files ----------------------------"

	SIZE=15
	displaytext "   Checking history files"
	jump=`expr ${defaultcolumn} - ${SIZE}`

	displaytext -n "     Bourne Shell"

	if [ -f "${ROOTDIR}/root/.bash_history" ]; then
		ATTRIBUTE=`ls -l ${ROOTDIR}/root/.bash_history | cut -c1`
		if [ "${ATTRIBUTE}" = "l" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (redirection found) ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		fi
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}Not Found${NORMAL} ]"
	fi



	logtext "------------------------- Security advisories -------------------------"

	SIZE=30
	jump=`expr ${defaultcolumn} - ${SIZE}`


	displaytext "* Check: Groups and Accounts${NORMAL}"
	displaytext -n "   Searching for ${ROOTDIR}/etc/passwd... "
	if [ -f "${ROOTDIR}/etc/passwd" ]; then
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}Found${NORMAL} ]"
		displaytext -n "   Checking users with UID '0' (root)... "

		SIZE=39
		jump=`expr ${defaultcolumn} - ${SIZE}`

		users_with_uid0=`grep -v '^:0:0:::' ${ROOTDIR}/etc/passwd | grep ':0:' | cut -d: -f1,3 | grep '0' | grep -v 'root:0'`
		if [ "${users_with_uid0}" = "" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${YELLOW}Warning!${NORMAL} (some users in root group) ]"
			displaytext "    info: ${users_with_uid0}"
		fi

	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${RED}Not Found${NORMAL} ]"
	fi

	displaytext "";
	displaytext "* Check: SSH${NORMAL}"

	SIZE=39
	jump=`expr ${defaultcolumn} - ${SIZE}`

	displaytext "   Searching for sshd_config... "
	SSHDCONFIG_PLACES="${ROOTDIR}/etc ${ROOTDIR}/etc/ssh ${ROOTDIR}/usr/local/etc ${ROOTDIR}/usr/local/etc/ssh"
	for I in ${SSHDCONFIG_PLACES}; do
		if [ -f "${I}/sshd_config" ]; then
			FOUND=0
			displaytext "   Found ${I}/sshd_config"
			displaytext -n "   Checking for allowed root login... "
			permitrootlogin=`grep 'PermitRootLogin' ${I}/sshd_config | grep -v '#'`
			if [ "${permitrootlogin}" = "PermitRootLogin yes" ]; then
				FOUND=1
				logtext "Info: Found 'PermitRootLogin yes'. Unsafe for production servers..."
				logtext "Tip: Change the option in your configuration file (${I}/sshd_config)."
				logtext "     Use normal user accounts and 'su' to obtain root permissions."
			else
				permitrootlogin2=`egrep 'PermitRootLogin (no|without-password)' ${I}/sshd_config | grep -v '#'`
				if [ "${permitrootlogin2}" = "PermitRootLogin no" -o "${permitrootlogin2}" = "PermitRootLogin without-password" ]; then
					FOUND=0
					logtext "Info: Found 'PermitRootLogin no' or 'PermitRootLogin without-password' in SSH configuration file ${I}/sshd_config"
				else
					permitrootlogin2=`grep 'PermitRootLogin forced-commands-only' ${I}/sshd_config | grep -v '#'`
					if [ "${permitrootlogin2}" = "PermitRootLogin forced-commands-only" ]; then
						FOUND=1
						logtext "Info: Found 'PermitRootLogin forced-commands-only'"
					else
						permitrootlogin3=`grep '#PermitRootLogin yes' ${I}/sshd_config`
						if [ -n "${permitrootlogin3}" ]; then
							FOUND=1
							logtext "Info: Found no PermitRootLogin value in file ${I}/sshd_config. Default value is 'yes'."
						else
							FOUND=0
							logtext "Unknown PermitRootLogin value found in file ${I}/sshd_config"
						fi
					fi
				fi
			fi

			if [ ${FOUND} -eq 1 ]; then
				if [ $ALLOW_SSH_ROOT_USER -eq 0 ]; then
					displaytext "${RED}Warning${NORMAL} Root login possible. Possible risk!"
					if [ -z "${permitrootlogin}" ]; then
						displaytext "    info: No 'PermitRootLogin' entry found in file ${I}/sshd_config"
					else
						displaytext "    info: \"${permitrootlogin}\" found in file ${I}/sshd_config"
					fi
					displaytext "    Hint: Check the logfile for more information about this issue"
					logtext "Warning: root login possible. Change for your safety the 'PermitRootLogin'"
					logtext "entry in the SSH configuration file ${I}/sshd_config to 'no', and use 'su -' to become root. "
				else
					logtext "Remote root login permitted, but allowed by using explicit option"
					SIZE=36
					jump=`expr ${defaultcolumn} - ${SIZE}`
					insertlayout
					displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (Remote root login permitted by explicit option) ]"
				fi
			else
				SIZE=36
				jump=`expr ${defaultcolumn} - ${SIZE}`
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (Remote root login disabled) ]"
			fi

			displaytext -n "   Checking for allowed protocols... "

			protocols=`grep 'Protocol 2' ${I}/sshd_config | grep -v '#'`
			if [ "${protocols}" = "Protocol 2" ]; then
				SIZE=35
				jump=`expr ${defaultcolumn} - ${SIZE}`
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (Only SSH2 allowed) ]"
			else
				if [ "${protocols}" = "Protocol 2,1" -o "${protocols}" = "Protocol 1,2" -o "${protocols}" = "Protocol 1" ]; then
					SIZE=35
					jump=`expr ${defaultcolumn} - ${SIZE}`
					insertlayout
					if [ "${ALLOW_SSH_PROT_V1}" = "0" ]; then
						displaytext $E "${LAYOUT}[ ${YELLOW}Warning${NORMAL} ]"
						displaytext "    info: Users can use SSH1-protocol (Check the logfile for more information)."
						logtext "Hint: Change the 'Protocol xxx' line into 'Protocol 2'"
					else
						displaytext $E "${LAYOUT}[ ${OK}OK${NORMAL} (SSH1-protocol permitted by explicit option) ]"
						logtext "Info: found SSH1-protocol permitted by explicit option."
					fi	
				else
					SIZE=35
					jump=`expr ${defaultcolumn} - ${SIZE}`
					insertlayout
					protocols=`grep '#Protocol' ${I}/sshd_config`
					if [ "${protocols}" = "#Protocol 2,1" -o "${protocols}" = "#Protocol 1,2" ]; then
						FOUND=1
						logtext "Found default option Protocol 2,1"
					fi
					if [ "${protocols}" = "#Protocol 1" ]; then
						FOUND=1
						logtext "Found default option Protocol 1"
					fi

					if [ ${FOUND} -eq 0 ];then
						displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (Only SSH2 allowed) ]"
						displaytext "    info: found no option, most times default value is used."
					else
						if [ "${ALLOW_SSH_PROT_V1}" = "0" ]; then
							displaytext $E "${LAYOUT}[ ${YELLOW}Warning${NORMAL} (SSH1-protocol allowed) ]"
							logtext "Warning: SSH version 1 possible allowed!"
							logtext "Hint: Change the 'Protocol xxx' line into 'Protocol 2'"
						else
							displaytext $E "${LAYOUT}[ ${OK}OK${NORMAL} (SSH1-protocol permitted by explicit option) ]"
							logtext "Info: found SSH1-protocol permitted by explicit option."
						fi
					fi
				fi
			fi
		fi
	done


	displaytext ""
	displaytext "* Check: Events and Logging${NORMAL}"
	displaytext -n "   Search for syslog configuration... "

	SIZE=36
	jump=`expr ${defaultcolumn} - ${SIZE}`


	if [ -f "${ROOTDIR}/etc/syslog.conf" -o -f "${ROOTDIR}/etc/syslog-ng/syslog-ng.conf" ]; then
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		SIZE=38
		jump=`expr ${defaultcolumn} - ${SIZE}`

		displaytext -n "   Checking for running syslog slave... "

		case "${OPERATING_SYSTEM}" in
		SunOS)
			syslogisrunning=`ps -ef | grep 'syslogd' | grep -v 'grep'`
			syslogngisrunning=`ps -ef | grep 'syslog-ng' | grep -v 'grep'`
			;;
		*)
			syslogisrunning=`ps ax | egrep 'syslogd|syslog-ng|metalog' | grep -v 'grep'`
			#syslogngisrunning=`ps ax | grep syslog-ng | grep -v "grep"`
			;;
		esac

		if [ ! "${syslogisrunning}" = "" -o ! "${syslogngisrunning}" = "" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
			displaytext "    Info: Cannot find syslog/syslog-ng daemon"
		fi

		SIZE=42
		jump=`expr ${defaultcolumn} - ${SIZE}`

		displaytext -n "   Checking for logging to remote system... "

		# First do syslog
		if [ -f "${ROOTDIR}/etc/syslog.conf" ]; then
			logtoremote=`grep '@' ${ROOTDIR}/etc/syslog.conf | grep -v '#'`
		else
			# Second try syslog-ng
			if [ -f "${ROOTDIR}/etc/syslog-ng/syslog-ng.conf" ]; then
				# Yes, we found the configuration file
				# Gready regex necessary due to allowed formatting (indentation, destination names, destinations)
				# As result logtxt below may contain partial lines.
				logtoremote=`egrep -iA1 '^destination.*{' ${ROOTDIR}/etc/syslog-ng/syslog-ng.conf | egrep '(udp|tcp).*\(' | grep -v '/'`
			else
				displaytext $E "${LAYOUT}[ ${YELLOW}NA${NORMAL} ]"
				displaytext "Warning: Cannot find syslog-ng configuration file"
				logtext "Info: Cannot find syslog-ng configuration file"
			fi
		fi

		if [ "${logtoremote}" = "" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (no remote logging) ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (remote logging) ]"
			displaytext "    info: ${logtoremote}"
			logtext "Info: line found with logging to remote host ($logtoremote)"
		fi
	fi


	displaytext ""
	displaytext "* Filesystem checks${NORMAL}"
	displaytext -n "   Checking /dev for suspicious files... "

	if [ -d "${ROOTDIR}/dev" ]; then
		# FreeBSD (5): character special, symbolic link to,directory
		# Linux (Debian): block special, socket, fifo (named pipe)
		SPECIALFILES=`file "${ROOTDIR}/dev/"* | egrep -v 'character special|block special|socket|fifo \(named pipe\)|symbolic link to|empty|directory|MAKEDEV'`

		SIZE=39
		jump=`expr ${defaultcolumn} - ${SIZE}`

		if [ "${SPECIALFILES}" = "" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (unusual files found) ]"
			displaytext "---------------------------------------------"
			displaytext "Unusual files:"
			displaytext "${SPECIALFILES}"
			displaytext "---------------------------------------------"
		fi
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${YELLOW}NA${NORMAL} ]"
	fi

	SIZE=29

	displaytext -n "   Scanning for hidden files..."

	SEARCHINDIRS="${ROOTDIR}/dev ${ROOTDIR}/bin ${ROOTDIR}/usr ${ROOTDIR}/usr/man ${ROOTDIR}/usr/share/man ${ROOTDIR}/usr/man/man1 ${ROOTDIR}/usr/share/man/man1 ${ROOTDIR}/usr/man/man8 ${ROOTDIR}/usr/share/man/man8 ${ROOTDIR}/usr/bin ${ROOTDIR}/usr/sbin ${ROOTDIR}/sbin ${ROOTDIR}/etc"
	# Only reset status once
	STATUS=0

	if [ -z "${LS_CMD}" ]; then
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${YELLOW}Skipped${NORMAL} ]"
		logtext "Scanning for hidden files... Skipped"
		logtext "Test skipped because no \"ls\" command is present."
	else
		for I in ${SEARCHINDIRS}; do
			# Initialize directory
			HIDDENDIRS=""

			logtext "Start scanning for hidden files in ${I}..."

			if [ -d "${I}" ]; then
				HIDDENDIRS=`${LS_CMD} -A1d ${I}/.* | egrep -v '\/\.\.?$'`
				logtext "Value of hiddendirs: ${HIDDENDIRS}"
			fi

			if [ -n "${HIDDENDIRS}" ]; then
				ALLHIDDENDIRS="${HIDDENDIRS} ${ALLHIDDENDIRS}"
				STATUS=1
			fi

			logtext "End of scanning ${I}"
		done

		if [ ${STATUS} -eq 0 ]; then
			jump=`expr ${defaultcolumn} - ${SIZE}`
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		else
			# Reset state
			STATUS=0
			for I in ${ALLHIDDENDIRS}; do
				if [ ${OPERATING_SYSTEM} = "AIX" -o ${OPERATING_SYSTEM} = "SunOS" ] ; then
					FILETYPE=`file ${I}|awk '{print $2}'`
				else
					FILETYPE=`file -b ${I}`
				fi

				# Ignore some filetypes, because they are harmless
				case "${FILETYPE}" in
				"character special (8/0)" | "character special (254/0)" | "empty")
					logtext "Hidden file/dir ${I} [${FILETYPE}] seems to be OK"
					;;
				"TDB database"*)
					logtext "Hidden file/dir ${I} [${FILETYPE}] seems to be OK"
					;;
				*)
					# Ignore Gentoo's zero-sized files (extra check for future use)
					if [ ! ${GENTOO} -eq 1 -a ! "${I}" = ".keep" -a ! -z ${I} ]; then
						SEARCHDIR=0
						if [ "${FILETYPE}" = "directory" ]; then
							for ALLOWHIDDENDIRS in `grep '^ALLOWHIDDENDIR=' ${CONFIGFILE} | sed -e 's/ALLOWHIDDENDIR=//g'`; do
								if [ "${ROOTDIR}${ALLOWHIDDENDIRS}" = "${I}" ]; then
									SEARCHDIR=1
									logtext "Found hidden directory ${I} on whitelist"
								fi
							done
						else
							for ALLOWHIDDENFILES in `grep '^ALLOWHIDDENFILE=' ${CONFIGFILE} | sed -e 's/ALLOWHIDDENFILE=//g'`; do
								if [ "${ROOTDIR}${ALLOWHIDDENFILES}" = "${I}" ]; then
									SEARCHDIR=1
									logtext "Found hidden file ${I} on whitelist"
								fi
							done
						fi

						# Is it a directory and is it on the whitelist?
						# searchdir: 0 = NOT on list, 1 = on list
						if [ ${SEARCHDIR} -eq 0 ]; then
							STATUS=1
							HIDDENFILES="${HIDDENFILES} ${I} (${FILETYPE}) "
							logtext "Added ${I} (${FILETYPE}) to list of unknown hidden files/dirs"
						fi
					fi
					;;
				esac
			done

			if [ ${STATUS} -eq 1 ]; then
				jump=`expr ${defaultcolumn} - ${SIZE}`
				insertlayout
				displaytext $E "${LAYOUT}[ ${YELLOW}Warning!${NORMAL} ]"
				logtext "WARNING, found: ${HIDDENFILES}"

				displaytext "---------------"
				displaytext "${ALLHIDDENDIRS}"
				displaytext "---------------"

				displaytext "Please inspect: ${HIDDENFILES}"
			else
				jump=`expr ${defaultcolumn} - ${SIZE}`
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			fi
		fi
	fi

	keypresspause


	return
}


do_app_checks() {

	#
	# This function carries out a sequence of application checks.
	#

	if ! `check_test apps`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST apps
		return
	fi


	display --to SCREEN+LOG --type PLAIN --color YELLOW --nl CHECK_APPS




	displaytext "* Application scan"

	FOUNDSTRING=0
	SIZE=32
	displaytext -n "   Checking Apache2 modules... "
	jump=`expr ${defaultcolumn} - ${SIZE}`

	if [ -d "${ROOTDIR}/etc/apache2/mods-enabled" ]; then
		SEARCHSTRING=`ls ${ROOTDIR}/etc/apache2/mods-enabled/* | egrep 'mod_rootme2?\.so'`
		logtext -n "Checking Apache2 modules in ${ROOTDIR}/etc/apache2/mods-enabled... "
		if [ -n "${SEARCHSTRING}" ]; then
			logtext --nodate "Warning! Possible bad module found."
			FOUNDSTRING=1
		else
			logtext --nodate "OK"
		fi

		if [ ${FOUNDSTRING} -eq 1 ]; then
			insertlayout
			displaytext $E "   ${LAYOUT}[ ${RED}BAD${NORMAL} ]"
		else
			insertlayout
			displaytext $E "   ${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		fi
	else
		insertlayout
		displaytext $E "   ${LAYOUT}[ ${GREEN}Not found${NORMAL} ]"
	fi

	FOUNDSTRING=0

	SIZE=37
	displaytext "   Checking Apache configuration... "

	for I in ${HTTPDCONFS}; do
		FILELENGTH=`echo ${I} | wc -c | tr -d ' '`
		SIZE=4
		jump=`expr ${defaultcolumn} - ${SIZE} - ${FILELENGTH}`

		displaytext -n "     - ${I}"
		if [ -f "${I}" ]; then
			SEARCHSTRING=`egrep 'mod_rootme2?\.so' ${I}`
			test -n "${SEARCHSTRING}" && FOUNDSTRING=1

			if [ ${FOUNDSTRING} -eq 1 ]; then
				insertlayout
				displaytext $E "   ${LAYOUT}[ ${RED}BAD${NORMAL} ]"
			else
				insertlayout
				displaytext $E "   ${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			fi
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}Not found${NORMAL} ]"
		fi
	done

	logtext "---------------------- Application version check ----------------------"

	if [ $APPS_CHECK_ENABLED -eq 1 ]; then
		displaytext ""
		displaytext "* Application version scan"

		#BINPATHS="/bin /sbin /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin /usr/local/libexec /usr/libexec"

		if [ "${OPERATING_SYSTEM}" = "AIX" ]; then
			SCANFILES="
exim:Exim%%MTA:
httpd:Apache:
openssl:OpenSSL:
php:PHP:
procmail:Procmail%%MTA:
proftpd:ProFTPd:
sshd:OpenSSH:
"
		else
			SCANFILES="
exim:Exim%%MTA:
gpg:GnuPG:
httpd:Apache:
named:Bind%%DNS:
openssl:OpenSSL:
php:PHP:
procmail:Procmail%%MTA:
proftpd:ProFTPd:
sshd:OpenSSH:
"
		fi

		LINUX_KERNELS="
vulnerable:%2.4.22%2.4.23%
nonvulnerable:%2.4.24%
"

		FOUND=0
		FOUNDUNKNOWN=0

		for J in ${SCANFILES}; do
			APPLICATION=`echo ${J} | cut -d: -f1`
			APPLICATIONNAME=`echo ${J} | cut -d: -f2`
			VULNERABLE=`cat ${DB_PATH}/programs_bad.dat | cut -d: -f2`
			NONVULNERABLE=`cat ${DB_PATH}/programs_good.dat | cut -d: -f2`
			logtext "----------------------------------------------------------"
			logtext "Scanning ${APPLICATIONNAME}..."

			FILEFOUND=0
			for I in ${BINPATHS}; do
				if [ -f "${I}/${APPLICATION}" ]; then
					FILEFOUND=1
					VERSION=""
					case "${APPLICATION}" in
					exim)
						VERSION=`${I}/exim -bV | grep 'Exim version' | awk '{ print $3 }'`
						;;
					gpg)
						VERSION=`${I}/gpg --version --homedir / | grep 'GnuPG' | awk '{ print $3 }'`
						;;
					httpd)
						VERSION=`${I}/httpd -v | grep 'Apache' | cut -d' ' -f3 | cut -d'/' -f2`
						;;
					named)
						VERSION=`${I}/named -v | grep 'named' | grep -v '/' | awk '{ print $2 }'`
						if [ ! "`echo ${VERSION} | grep '-'`" = "" ]; then
							VERSION=`echo ${VERSION} | cut -d'-' -f1`
						fi
						TEST=`${I}/named -v | grep 'named'`
						logtext "Debug: ${TEST}"
						if [ "${VERSION}" = "" ]; then
							VERSION=`${I}/named -v | awk '{ print $2 }'`
						fi
						;;
					openssl)
						VERSION=`${I}/openssl version | head -n 1 | cut -d' ' -f2`
						;;
					php)
						# Strip off any additions (like Debian using version 4.3.10-8)
						VERSION=`${I}/php -v | head -n 1 | awk '{ print $2 }' | cut -d'-' -f1`
						;;
					procmail)
						VERSION=`${I}/procmail -v 2>&1  | grep 'procmail v' | awk '{ print $2 }' | tr -d 'v'`
						;;
					proftpd)
						VERSION=`${I}/proftpd -v 2>&1 | awk '{ print $4 }'`
						;;
					squid)
						VERSION=`${I}/squid -v | grep 'Squid Cache' | awk '{ print $4 }'`
						;;
					sshd)
						VERSION=`${I}/sshd -t -d 2>&1 | head -n 1 | awk '{ print $4 }' | cut -d'_' -f2`
						if [ ! "`echo "${VERSION}" | grep '+'`" = "" ]; then
							VERSION=`echo "${VERSION}" | cut -d'+' -f1`
						fi
						;;
					*)
						displaytext "Unknown"
						VERSION="NA"
						;;
					esac

					logtext "${I}/${APPLICATION} found"

					VERSION=`echo ${VERSION} | tr -d '\r'`

					if [ "${VERSION}" = "" ]; then
						logtext "No version found of application ${APPLICATION}"
						APPLICATIONNAME=`echo ${APPLICATIONNAME} | tr -s '%' ' '`
						displaytext -n "   - ${APPLICATIONNAME} [unknown] "

						JUMPCOL=`expr ${defaultcolumn} - 12`
						SIZE=`echo \'${APPLICATIONNAME} [unknown]\' | wc -c | tr -d ' '`
						jump=`expr ${JUMPCOL} - ${SIZE} + 11`
						insertlayout
						displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
					else
						APPLICATIONNAME=`echo ${APPLICATIONNAME} | tr -s '%' ' '`
						displaytext -n "   - ${APPLICATIONNAME} ${VERSION} "

						JUMPCOL=`expr ${defaultcolumn} - 12`
						SIZE=`echo \'${APPLICATIONNAME} ${VERSION}\' | wc -c | tr -d ' '`
						jump=`expr ${JUMPCOL} - ${SIZE} + 11`
						insertlayout

						RE_VERSION=`echo "${VERSION}" | sed -e 's/\./\\\./g'`
						ISVULNERABLE=`echo ${VULNERABLE} | grep "%${RE_VERSION}%"`
						if [ "${ISVULNERABLE}" = "" ]; then
							ISNONVULNERABLE=`echo ${NONVULNERABLE} | grep "%${RE_VERSION}%"`
							if [ "${ISNONVULNERABLE}" = "" ]; then
								logtext "No information available. Unknown version number"
								displaytext $E "${LAYOUT}[ ${YELLOW}Unknown${NORMAL} ]"
								FOUNDUNKNOWN=1
							else
								logtext "Version ${VERSION} is available in non-vulnerable group and seems to be OK!"
								displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
							fi
						else
							logtext "Version ${VERSION} seems to be vulnerable (if unpatched)!"
							if [ ${USE_PATCHED_SOFTWARE} -eq 1 ]; then
								displaytext $E "${LAYOUT}[ ${YELLOW}Old or patched version${NORMAL} ]"
							else
								displaytext $E "${LAYOUT}[ ${RED}Vulnerable${NORMAL} ]"
							fi
							FOUND=1
							VULNERABLE_ITEM_COUNT=`expr ${VULNERABLE_ITEM_COUNT} + 1`
						fi
					fi
				fi
			done

			if [ ${FILEFOUND} -eq 0 ]; then
				logtext "Application not found"
			fi
		done


		displaytext ""
		if [ $FOUNDUNKNOWN -eq 1 ]; then
			displaytext "Your system contains some unknown version numbers. Please run Rootkit Hunter"
			displaytext "with the --update parameter or contact us through the Rootkit Hunter mailing list"
			displaytext "at rkhunter-users@lists.sourceforge.net"
		fi

	fi


	return
}


display_check_summary() {

	displaytext ""; displaytext ""
	displaytext "---------------------------- Scan results ----------------------------"

	displaytext ""
	displaytext "${YELLOW}Hash scan${NORMAL}"
	if [ $GOOD_HASH_ENABLED -eq 1 ]; then
		displaytext "Scanned files: ${HASH_COUNT}"
		displaytext -n "Incorrect hash checksums: "
		if [ "${HASH_DIFFERENT}" -eq 0 ]; then
			displaytext -n "${GREEN}"
		else
			displaytext -n "${RED}"
		fi
		displaytext "${HASH_DIFFERENT}${NORMAL}"
	else
		displaytext "Skipped"
		logtext "Hash scan skipped"
	fi

	displaytext ""
	displaytext "${YELLOW}File scan${NORMAL}"
	displaytext "Scanned files: ${SCANNED_COUNT}"
	displaytext -n "Possible infected files: "
	if [ "${INFECTED_COUNT}" -eq 0 ]; then
		displaytext -n "${GREEN}"
	else
		displaytext -n "${RED}"
	fi
	displaytext "${INFECTED_COUNT}${NORMAL}"
	logtext "Rootkits scanned for: ${ROOTKIT_TESTS}"
	if [ ! "${INFECTED_NAMES}" = "" ]; then
		displaytext "Possible rootkits: ${INFECTED_NAMES}"
	fi

	displaytext ""
	displaytext "${YELLOW}Application scan${NORMAL}"
	if [ $APPS_CHECK_ENABLED -eq 1 ]; then
		logtext "${VULNERABLE_ITEM_COUNT} vulnerable applications found"
		displaytext -n "Vulnerable applications: "
		if [ "${VULNERABLE_ITEM_COUNT}" -eq 0 ]; then
			displaytext -n "${GREEN}"
		else
			displaytext -n "${RED}"
		fi
		displaytext ${VULNERABLE_ITEM_COUNT}${NORMAL}
	else
		displaytext "Skipped"
		logtext "Application scan skipped"
	fi

	displaytext ""
	test $BEGINTIME -ne 0 && displaytext "Scanning took ${TOTALTIME}."

	if [ "${REPORTMODE}" -eq 0 ]; then
		if [ $NOLOG -eq 0 ]; then
			displaytext ""
			displaytext "Scan results written to logfile ($LOGFILE)"
		fi

		displaytext ""
		displaytext "-----------------------------------------------------------------------"
		displaytext ""
		displaytext "Do you have some problems, undetected rootkits, false positives, ideas"
	    displaytext "or suggestions? Please e-mail us through the Rootkit Hunter mailing list"
	    displaytext "at rkhunter-users@lists.sourceforge.net"
		displaytext ""
		displaytext "-----------------------------------------------------------------------"

	else

		# Force output (because we are in quiet mode)
		echo ""
		echo "* Hash scan"
		if [ $GOOD_HASH_ENABLED -eq 1 ]; then
			echo "Hash compared            : ${HASH_COUNT}"
			echo "Incorrect hash checksums : ${HASH_DIFFERENT}"
		else
			echo "Skipped"
		fi
		echo ""
		echo "* File scan"
		echo "Scanned files: ${SCANNED_COUNT}"
		echo "Possible infected files: ${INFECTED_COUNT}"
		echo ""
		echo "* Rootkits"
		echo "Possible rootkits: ${INFECTED_NAMES}"
		echo ""
		echo "* Application scan"
		if [ $APPS_CHECK_ENABLED -eq 1 ]; then
			echo "Vulnerable applications: ${VULNERABLE_ITEM_COUNT}"
		else
			echo "Skipped"
		fi
		echo ""
		test $BEGINTIME -ne 0 && displaytext "Scanning took ${TOTALTIME}."
		echo ""
		echo "*important*"
		echo "Scan your system manually sometimes with full output enabled!"

		displaytext ""
		displaytext "-----------------------------------------------------------------------"
		displaytext ""
		displaytext "Do you have some problems, undetected rootkits, false positives, ideas"
	    displaytext "or suggestions? Please e-mail us through the Rootkit Hunter mailing list"
	    displaytext "at rkhunter-users@lists.sourceforge.net"
		displaytext ""
		displaytext "-----------------------------------------------------------------------"

	fi

	return
}


display_warnings() {

	echo "-----------------------------------------------------------------"
	echo ""
	echo "Found warnings:"
	egrep 'Warning|WARNING|BAD|Bad|Vulnerable' $LOGFILE
	echo ""
	echo "-----------------------------------------------------------------"
	echo ""
	echo "If you are unsure about the results above, please contact the"
	echo "Rootkit Hunter team through the Rootkit Hunter mailing list"
	echo "at rkhunter-users@lists.sourceforge.net"

	return
}


do_system_check() {

	#
	# This function performs the various rootkit and security checks
	# for the program. We start by initialising variables used for
	# the rootkit checks.
	#

	display --to LOG --type PLAIN --nl CHECK_START

	do_system_check_initialisation


	#
	# Record the start time if we can. The total time taken for
	# scanning will only be calculated and displayed if the
	# start time can be set.
	#

	BEGINTIME=0
	ENDTIME=0

	if [ -n "$SECONDS" ]; then
		BEGINTIME=$SECONDS
	elif [ -n "${PERL_CMD}" ]; then
		BEGINTIME=`${PERL_CMD} -e 'printf "%d\n", time;'`
	fi


	#
	# Send a start message to syslog if the user requested that.
	#

	if [ -n "${USE_SYSLOG}" ]; then
		${LOGGER_CMD} -t "${PROGRAM_NAME}" -p ${USE_SYSLOG} "Rootkit hunter check started (version ${PROGRAM_version})"
	fi


	#
	# We must reset the warning counter here. It is incremented in
	# the display function, and so could easily be non-zero by the
	# time we get here.
	#

	WARNING_COUNT=0


	#
	# We start with checks of some of the commands (binaries) and 
	# libraries on the system, to make sure that they have not
	# been tampered with.
	#

	do_system_commands_checks


	#
	# Next are the rootkit checks.
	#

	do_rootkit_checks


	#
	# Next are some network port, and interface checks.
	#

	do_network_checks


	#
	# Next are checks of the files for the local host.
	#

	do_local_host_checks


	#
	# Next are checks on specific applications.
	#

	do_app_checks


	#
	# Now record the end time.
	#

	if [ $BEGINTIME -ne 0 ]; then
		if [ -n "$SECONDS" ]; then
			ENDTIME=$SECONDS
		else
			ENDTIME=`${PERL_CMD} -e 'printf "%d\n", time;'`
		fi

		TOTALTIME=`expr ${ENDTIME} - ${BEGINTIME}`
		TOTALMINS=`expr ${TOTALTIME} / 60`
		TOTALSECS=`expr ${TOTALTIME} % 60`

		if [ $TOTALMINS -gt 0 ]; then
			if [ $TOTALMINS -eq 1 ]; then
				TOTALTIME="${TOTALMINS} minute and "
			else
				TOTALTIME="${TOTALMINS} minutes and "
			fi
		else
			TOTALTIME=""
		fi

		if [ $TOTALSECS -eq 1 ]; then
			TOTALTIME="${TOTALTIME}${TOTALSECS} second"
		else
			TOTALTIME="${TOTALTIME}${TOTALSECS} seconds"
		fi
	fi


	#
	# Display the summary of the results.
	#

	display_check_summary


	#
	# Send a finish message to syslog if the user requested that.
	#

	if [ -n "${USE_SYSLOG}" ]; then
		${LOGGER_CMD} -t "${PROGRAM_NAME}" -p ${USE_SYSLOG} "Scanning took ${TOTALTIME}"
	fi


	#
	# If the user asked to see the logfile, then show it.
	#

	test $CATLOGFILE -eq 1 && cat ${LOGFILE}


	#
	# If some warning or error has been seen, then make sure the
	# user is told about it. We also set the return code, to allow
	# the user to detect it being non-zero.
	#

	if [ $WARNING_COUNT -gt 0 ]; then
		test $SHOWWARNINGSONLY -eq 1 && display_warnings


		if [ -n "${USE_SYSLOG}" ]; then
			${LOGGER_CMD} -t "${PROGRAM_NAME}" -p ${USE_SYSLOG} "Please inspect this machine, because it may be infected"
		fi


		if [ -n "${MAILONWARNING}" ]; then
			eval "echo 'Please inspect this machine, because it may be infected' | ${MAIL_CMD} ${MAILONWARNING}"
		fi


		if [ $QUIET -eq 1 ]; then
			display --to SCREEN --type PLAIN CHECK_ERRS_FOUND

			if [ $NOLOG -eq 1 ]; then
				display --to SCREEN --type PLAIN CHECK_ERRS_FOUND_RERUN
			else
				display --to SCREEN --type PLAIN CHECKS_ERRS_FOUND_CHK_LOG "${LOGFILE}"
			fi
		fi

		RET_CODE=1
	fi

	return
}


check_os_info() {

	#
	# This function checks the current O/S information against
	# that stored in the rkhunter.dat file. Any change could
	# mean that file hash checks will give several false-positive
	# answers. As such we warn users that a change has occurred.
	#

	#
	# First check if the host name has changed.
	#

	FOUND=0

	display --to LOG --type PLAIN --nl OSINFO_START


	OLD_HOST=`grep '^Host:' ${DB_PATH}/rkhunter.dat | cut -d: -f2-`

	if [ "${HOST_NAME}" != "${OLD_HOST}" ]; then
		FOUND=1
		display --to LOG --type WARNING OSINFO_HOST_CHANGE1
		display --to LOG --type PLAIN --log-indent 9 OSINFO_HOST_CHANGE2 "${OLD_HOST}" "${HOST_NAME}"
	fi


	#
	# Next check if the O/S name has changed.
	#

	OLD_OSNAME=`grep '^OS:' ${DB_PATH}/rkhunter.dat | cut -d: -f2-`

	if [ "${OSNAME}" != "${OLD_OSNAME}" ]; then
		FOUND=1
		display --to LOG --type WARNING OSINFO_OSVER_CHANGE1
		display --to LOG --type PLAIN --log-indent 9 OSINFO_OSVER_CHANGE2 "${OLD_OSNAME}" "${OSNAME}"
	fi


	#
	# Check if the prelinking status has changed.
	#

	if [ -z "`grep '^Prelinked:Yes' ${DB_PATH}/rkhunter.dat`" ]; then
		OLD_PRELINK=0
	else
		OLD_PRELINK=1
	fi

	if [ $PRELINKED -ne $OLD_PRELINK ]; then
		FOUND=1
		if [ $PRELINKED -eq 1 ]; then
			display --to LOG --type WARNING OSINFO_PRELINK_CHANGE ''
		else
			display --to LOG --type WARNING OSINFO_PRELINK_CHANGE 'not '
		fi
	fi


	#
	# Check if the system architecture has changed. We treat
	# the i386-type architectures as the same. We also treat
	# the sun-type archictures the same as 'sparc'.
	#

	OLD_ARCH=`grep '^Arch:' ${DB_PATH}/rkhunter.dat | cut -d: -f2-`

	if [ -n "`echo ${OLD_ARCH} | grep 'i[0-9]86'`" ]; then
		OLD_ARCH_TYPE="i386"
	elif [ -n "`echo ${OLD_ARCH} | grep 'sun[0-9][a-z]'`" -o -n "`echo ${OLD_ARCH} | grep 'sparc'`" ]; then
		OLD_ARCH_TYPE="sparc"
	else
		OLD_ARCH_TYPE=$OLD_ARCH
	fi

	if [ -n "`echo ${ARCH} | grep 'i[0-9]86'`" ]; then
		ARCH_TYPE="i386"
	elif [ -n "`echo ${ARCH} | grep 'sun[0-9][a-z]'`" -o -n "`echo ${ARCH} | grep 'sparc'`" ]; then
		ARCH_TYPE="sparc"
	else
		ARCH_TYPE=$ARCH
	fi

	if [ "${OLD_ARCH_TYPE}" != "${ARCH_TYPE}" ]; then
		FOUND=1
		display --to LOG --type WARNING OSINFO_ARCH_CHANGE1
		display --to LOG --type PLAIN --log-indent 9 OSINFO_ARCH_CHANGE2 "${OLD_ARCH}" "${ARCH}"
	fi


	if [ $FOUND -eq 1 ]; then
		display --to LOG --type PLAIN --log-indent 9 OSINFO_MSG1
		display --to LOG --type PLAIN --log-indent 9 OSINFO_MSG2
		display --to LOG --type WARNING --nl HASHUPD_WARN
	else
		display --to LOG --type INFO OSINFO_END
	fi

	return
}


set_hash_dirs_files() {

	#
	# This function sets up the list of directories we look in,
	# and the list of files we look for, in order to perform
	# the file hash checks.
	#

	HASHDIRS="${ROOTDIR}/bin ${ROOTDIR}/sbin ${ROOTDIR}/usr/bin ${ROOTDIR}/usr/sbin ${ROOTDIR}/usr/local/bin ${ROOTDIR}/usr/local/sbin"

	HASHFILES="adduser amd basename cat chattr checkproc chkconfig chmod
	    chown chroot cron csh date depmod df dirname dmesg du echo ed egrep
	    env fgrep file find grep groupadd groupdel groupmod groups grpck
	    head id ifconfig ifdown ifstatus ifup inetd init insmod ip kallsyms
	    kill killall ksyms kudzu last lastlog less locate logger login ls
	    lsattr lsmod lynx md5 md5sum mlocate modinfo modload modprobe
	    modstat modunload more mount netstat newgrp newsyslog nologin
	    passwd ps pstree pwck rmmod runlevel sh sha1 sha1sum size slocate
	    sockstat sort stat strace strings su sudo sulogin sysctl syslogd
	    systat tail tcpd test top touch uname useradd userdel usermod users
	    vipw vmstat w watch wc wget whatis whereis which who whoami xinetd"


	#
	# Under SunOS /bin is a link to /usr/bin, so there is no need
	# to look in it. Also add in some extra commands to check.
	#

	if [ "${OPERATING_SYSTEM}" = "SunOS" ]; then
		if [ -h ${ROOTDIR}/bin ]; then
			B=""

			for DIR in ${HASHDIRS}; do
				test "${DIR}" != "${ROOTDIR}/bin" && B="${B} ${DIR}"
			done

			HASHDIRS=`echo ${B} | sed -e 's/^ *//'`
		fi

		HASHFILES="${HASHFILES} gbasename gcat gchmod gchown gdate
		    gdirname gecho gfind gfile ggroups ghead gid glocate
		    gmd5sum gsize gtail gtest gtouch guname gusers truss"
	elif [ "${OPERATING_SYSTEM}" = "FreeBSD" ]; then
		HASHFILES="${HASHFILES} kldload kldstat kldunload"
	fi


	add_extra_dirs
	HASHDIRS="${HASHDIRS}${EXTRA_DIRS}"

	return
}


check_test() {

	#
	# This function will test if a given test name is enabled
	# or not. It returns 0 if the test is to be executed, and
	# 1 if it is not.
	#

	if [ "${ENABLE_TESTS}" = "all" -o -n "`echo \"${ENABLE_TESTS}\" | egrep \"(^| )${1}( |$)\"`" ]; then
		if [ "${DISABLE_TESTS}" = "none" -o -z "`echo \"${DISABLE_TESTS}\" | egrep \"(^| )${1}( |$)\"`" ]; then
			return 0
		fi
	fi

	return 1
}


display_tests() {

	#
	# This function is used to simply output all the available
	# tests and test group names. If a group name itself contains
	# a group name, then that second group name is omitted. It
	# could be confusing if it was included.
	#

	KNOWN_TESTS="all none ${KNOWN_TESTS}"

	SORT_CMD=`find_cmd sort`

	if [ -n "${SORT_CMD}" ]; then
		KNOWN_TESTS=`echo "${KNOWN_TESTS}" | tr ' ' '\n' | sort | tr '\n' ' '`
		GROUPED_TESTS=`echo "${GROUPED_TESTS}" | tr ' ' '\n' | sort | tr '\n' ' '`
	fi


	echo "Available test names:"

	while true; do
		STR=`echo ${KNOWN_TESTS} | cut -d' ' -f1-6`

		if [ -n "`echo \"${KNOWN_TESTS}\" | grep ' '`" ]; then
			KNOWN_TESTS=`echo ${KNOWN_TESTS} | cut -d' ' -f7-`
		else
			break
		fi

		echo "    ${STR}"
	done


	echo ""
	echo "Grouped test names:"

	#
	# Sort out the maximum group name length, so we can do some
	# simple formatting of the output.
	#

	MAX=0

	for STR in ${GROUPED_TESTS}; do
		LEN=`echo "${STR}" | cut -d: -f1 | wc -c | tr -d ' '`
		test $LEN -gt $MAX && MAX=$LEN
	done


	#
	# Now loop through the group names.
	#

	for STR in ${GROUPED_TESTS}; do
		TEST_NAMES=""
		GROUP_NAME=`echo "${STR}" | cut -d: -f1`

		#
		# Add on spaces to expand the group name to the maximum.
		#

		LEN=`echo "${GROUP_NAME}" | wc -c | tr -d ' '`
		LEN=`expr $MAX - $LEN`

		if [ $LEN -gt 0 ]; then
			GROUP_NAME="${GROUP_NAME} `echo \"${BLANK_LINE}\" | cut -d' ' -f1-$LEN`"
		fi


		#
		# Check through the list of tests for this group name.
		# If the test name is a group name itself, then go to
		# the next test name, otherwise add it to our list of
		# test names.
		#

		for TEST in `echo "${STR}" | cut -d: -f2- | tr ':' ' '`; do
			RKHTMPVAR=`echo "${GROUPED_TESTS}" | egrep "(^| )${TEST}:"`

			if [ -n "${RKHTMPVAR}" ]; then
				continue
			else
				TEST_NAMES="${TEST_NAMES}:${TEST}"
			fi
		done


		#
		# Finally, sort our list of test names and display them.
		#

		TEST_NAMES=`echo "${TEST_NAMES}" | sed -e 's/^://'`

		if [ -n "${SORT_CMD}" ]; then
			TEST_NAMES=`echo "${TEST_NAMES}" | tr ':' '\n' | sort | tr '\n' ' '`
		else
			TEST_NAMES=`echo "${TEST_NAMES}" | tr ':' ' '`
		fi

		echo "    ${GROUP_NAME} => ${TEST_NAMES}"
	done

	return
}


display_languages() {

	#
	# This function is used to simply output all the available
	# languages in a basic format of 10 per line.
	#

	TITLE=1

	SORT_CMD=`find_cmd sort`

	if [ -n "${SORT_CMD}" ]; then
		KNOWN_LANGS=`echo "${KNOWN_LANGS}" | tr ' ' '\n' | sort | tr '\n' ' '`
	fi


	while true; do
		STR=`echo ${KNOWN_LANGS} | cut -d' ' -f1-10`

		if [ -n "`echo \"${KNOWN_LANGS}\" | grep ' '`" ]; then
			KNOWN_LANGS=`echo ${KNOWN_LANGS} | cut -d' ' -f11-`
		else
			break
		fi

		if [ $TITLE -eq 1 ]; then
			TITLE=0
			echo "Available languages (ISO code): ${STR}"
		else
			echo "                                ${STR}"
		fi
	done

	return
}


help() {

	#
	# This function outputs the help menu.
	#

	echo ""
	echo "Usage: rkhunter (--check | --cronjob | --update | --hashupd |"
	echo "                 --versioncheck | --version | --help) [option]..."
	echo ""

	echo "Current options are:"
	echo "       --append-log                    Append to the logfile, do not overwrite"
	echo "       --bindir <bindir>...            Use <bindir> instead of default"
	echo "                                       command directories"
	echo "   -c, --check                         Check the local system"
	echo "       --color-set2                    Use second color set for output"
	echo "       --configfile <file>             Use specified configuration file"
	echo "       --cronjob                       Run as a cronjob"
	echo "                                       (implies -c, -sk and --nocolors options)"
	echo "       --dbdir <dir>                   Use specified database directory"
	echo "       --debug                         Debug mode"
	echo "                                       (Do not use unless asked to do so)"
	echo "       --disable <test>[,<test>...]    Disable specific tests"
	echo "                                       (Default is to disable no tests)"
	echo "       --display-logfile               Display the logfile at the end"
	echo "       --enable  <test>[,<test>...]    Enable specific tests"
	echo "                                       (Default is to enable all tests)"
	echo "       --hash                          Specify the hash function to use"
	echo "       --hashupd                       Update the local file hash database"
	echo "   -h, --help                          Display this help menu, then exit"
	echo "       --language <language>           Specify the language (ISO code) to use"
	echo "                                       (Default is English)"
	echo "       --list [tests | languages]      List the available test names or"
	echo "                                       languages"
	echo "   -l, --logfile [logfile]             Write to a logfile"
	echo "                                       (default is $DFLT_LOGFILE)"
	echo "       --noappend-log                  Do not append to the logfile, overwrite it"
	echo "       --nocolors                      Use black and white output"
	echo "       --nolog                         Do not write to a logfile"
	echo "   -q, --quiet                         Quiet mode (only show warnings)"
	echo "       --report-mode                   Only show interesting information"
	echo "       --report-warnings-only          Show only warnings (less output than"
	echo "                                       --report-mode more than --quiet)"
	echo "   -r, --rootdir <rootdir>             Use <rootdir> instead of '/'"
	echo "  -sk, --skip-keypress                 Don't wait for a keypress after each test"
	echo "       --syslog [facility.priority]    Log check start and finish times to syslog"
	echo "                                       (Default level is $SYSLOG_DFLT_PRIO)"
	echo "       --tmpdir <tempdir>              Use specified temporary directory"
	echo "       --update                        Check for updates to database files"
	echo "   -V, --version                       Display the version number, then exit"
	echo "       --versioncheck                  Check for latest version of program"
	echo "   -x                                  Do not automatically detect if X is in use"
	echo "   -X                                  Automatically detect if X is in use"
	echo ""

	return
}


######################################################################
#
# Initialisation
#
######################################################################


#
# First we initialise variables used throughout the program.
#

PROGRAM_NAME="Rootkit Hunter"
PROGRAM_version="1.2.9"
PROGRAM_copyright_owner="Michael Boelen"
PROGRAM_copyright="Copyright (c) 2003-2006, ${PROGRAM_copyright_owner}"
PROGRAM_license="
${PROGRAM_NAME} ${PROGRAM_version}, ${PROGRAM_copyright}

Under active development by the ${PROGRAM_NAME} project team. For reporting
bugs, updates, patches, comments and questions please go to: http://rkhunter.sourceforge.net

${PROGRAM_NAME} comes with ABSOLUTELY NO WARRANTY. This is free software,
and you are welcome to redistribute it under the terms of the GNU General
Public License. See LICENSE for details.
"

# Set to run as a cronjob.
CRONJOB=0
CHECK=0

# Set to display the logfile at the end.
CATLOGFILE=0

NOLOG=0
LOGFILE=""
DFLT_LOGFILE="/var/log/rkhunter.log"

# Set to have the logfile appended to rather than overwritten.
APPEND_LOG=0
APPEND_OPT=0

# Set to have rkhunter start/finish messages, and warnings,
# logged to syslog. The priority/severity can be set on the
# command-line or in the configuration file.
USE_SYSLOG=""
SYSLOG_DFLT_PRIO="authpriv.notice"

DFLT_BINPATHS="/bin /usr/bin /sbin /usr/sbin /usr/local/bin /usr/local/sbin /usr/libexec /usr/local/libexec"

HASH_FUNC=""
HASHDIRS=""
HASHFILES=""

PRELINKED=0
PRELINK_CMD=''

UPDATE=0
HASH_UPDATE=0
VERSIONCHECK=0

# By default use coloured output.
COLORS=1
CLRSET2=0

# Set to automatically detect if X is in use, and
# hence use the second colour set.
AUTO_X_DTCT=0
AUTO_X_OPT=0

# Perform the application check.
APPS_CHECK_ENABLED=0
VULNERABLE_ITEM_COUNT=0

PREVIOUSTEXT=""

# Set to be quiet. No output, but the return code will be set.
QUIET=0

# Set to only show warnings.
SHOWWARNINGSONLY=0

# This will be set if the known good hash check is to be performed.
GOOD_HASH_ENABLED=0
SKIP_GOODHASH_MSG=0

# Users can reset this to a new root directory.
ROOTDIR=""

# Set to use report mode (do not show footer and make a 'professional' report)
REPORTMODE=0

# Default 'id' command. Solaris will reset this.
ID_CMD="id"

# Set if we don't want to wait for a keypress after each test.
SKIP_KEY_PRESS=0

# Is the Gentoo operating system?
GENTOO=0

# This can be set in the configuration file to allow SSH root login.
ALLOW_SSH_ROOT_USER=0

INFECTED_COUNT=0
INFECTED_NAMES=""
SCANNED_COUNT=0
HASH_COUNT=0
HASH_DIFFERENT=0

# This will be set if a warning message is logged.
WARNING_COUNT=0

FOUNDFILE=0
FOUNDRCSIGNS=0

# Set if grsec is installed.
GRSECINSTALLED=0

# Default display column width
defaultcolumn=60

# Initialise default status.
STATUS=0

# Ksyms or kallsyms file used in some checks.
KSYMS_FILE=""

# Record for logging the command-line being used.
CMD_LINE="$0 $*"

# Create a spaced-separated PATH variable.
SPACEDPATH=`echo ${PATH} | tr ':' ' ' 2>/dev/null`

# List of commands used during RKH. If a command does not exist, then
# the code may use an alternative method.
CMDLIST="diff file find ifconfig ip ldd ls lsattr lsmod lsof mktemp netstat perl ps readlink sort stat strings uniq"

# Commands that are required to exist for RKH to run.
REQCMDS="awk cut date egrep grep head sed tail tr uname wc"

# List of commands used to download files from the web. This list is 
# used by the '--update' and '--versioncheck' options. Preferred commands
# are listed first.
WEBCMDLIST="wget curl elinks links lynx bget GET"

HOST_NAME=`hostname 2>/dev/null`

if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
	USE_PATCHED_SOFTWARE=1
else
	USE_PATCHED_SOFTWARE=0
fi

# This is the return code for the program actions - update, check, etc.
# Its value will either be 0 (no error) or 1 (an error occurred).
# The '--versioncheck' option may set the return code to 2 to indicate
# that an update is available.
RET_CODE=0

# Set the default language to English.
LANGUAGE=en

# A space-separated list of languages we recognise.
KNOWN_LANGS=en

# A space-separated list of test names we recognise.
#
KNOWN_TESTS="strings hashes scripts deleted_files packet_cap_apps apps rootkits local_host network passwd system_commands shared_libs"

# A space-separated list of test 'group names'. This list allows test
# names to be grouped together. For example, 'system_commands' can include
# the specific tests of 'strings' and 'hashes'. Both test
# group names, and specific test names, can be used with the test
# enable/disable options. In this list group names are colon-separated
# from the specific test names.
#
GROUPED_TESTS="system_commands:strings:hashes:scripts:shared_libs
               network:packet_cap_apps
               local_host:passwd"

# The program defaults of which tests to perform will be set later.
ENABLE_TESTS=""
DISABLE_TESTS=""

# See if the command-line options --enable or --disable have been used.
ENDIS_OPT=0

# Space-filled line used for the display function.
BLANK_LINE="                                                              "

# Initially say that we are connected to a terminal.
NOTTY=0


######################################################################
#
# Command-line option processing
#
######################################################################


#
# Display the help menu if no options were given.
#

if [ $# -eq 0 ]; then
	help
	exit 0
fi


#
# Check the command-line options. If set, these will override the
# configuration file options.
#

while [ $# -ge 1 ]; do
	case "$1" in
	--append-log | --appendlog)
		APPEND_LOG=1
		APPEND_OPT=1
		;;
	--bindir)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			BINPATHS="$1"
			;;
		esac
		;;
	-c | --check | --checkall)
		CHECK=1
		;;
	--configfile)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			CONFIGFILE="$1"
			;;
		esac
		;;
	--cronjob)
		CHECK=1
		CRONJOB=1
		COLORS=0
		SKIP_KEY_PRESS=1
		;;
	--cs2 | --colorset2 | --color-set2)
		CLRSET2=1
		;;
	--dbdir)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			DB_PATH="$1"
			;;
		esac
		;;
	--debug)
		SKIP_KEY_PRESS=1
		;;
	--display-logfile | --displaylogfile | --display-log | --displaylog)
		CATLOGFILE=1
		;;
	--disable)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			CHECK=1
			ENDIS_OPT=1
			DISABLE_TESTS=$1
			;;
		esac
		;;
	--enable)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			CHECK=1
			ENDIS_OPT=1
			ENABLE_TESTS=$1
			;;
		esac
		;;
	--hash)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			HASH_FUNC="$1"
			;;
		esac
		;;
	--hashupd | --hash-update | --hashupdate)
		HASH_UPDATE=1
		;;
	-h | --help)
		help
		exit 0
		;;
	-l | --log | --logfile | --createlogfile | --createlog | --create-log | --create-logfile)
		LOGFILE="${DFLT_LOGFILE}"

		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			LOGFILE="$1"
			;;
		esac
		;;
	--lang | --language)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			LANGUAGE="$1"
			;;
		esac
		;;
	--list)
		case "$2" in
		test|tests|check|checks)
			display_tests
			;;
		lang|langs|language|languages)
			display_languages
			;;
		"")
			display_tests
			echo ""
			display_languages
			;;
		*)
			echo "Invalid --list option specified: $2"
			;;
		esac
		exit 0
		;;
	--noappend-log | --no-append-log | --noappendlog)
		APPEND_LOG=0
		APPEND_OPT=1
		;;
	--nocolors | --no-colors | --nocolor | --no-color)
		COLORS=0
		;;
	--nolog | --no-log)
		LOGFILE="/dev/null"
		;;
	-q | --quiet)
		QUIET=1
		;;
	--report-mode | --reportmode)
		QUIET=1
		REPORTMODE=1
		;;
	--report-warnings-only | --rwo | --show-warnings-only | --swo)
		QUIET=1
		SHOWWARNINGSONLY=1
		;;
	-r | --rootdir)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			ROOTDIR="$1"
			;;
		esac
		;;
	--skip-keypress | --skipkeypress | -sk | --sk)
		SKIP_KEY_PRESS=1
		;;
	--syslog)
		USE_SYSLOG="${SYSLOG_DFLT_PRIO}"

		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			USE_SYSLOG="$1"
			;;
		esac
		;;
	--tmpdir)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			TMPDIR="$1"
			;;
		esac
		;;
	--update)
		UPDATE=1
		;;
	-V | --version)
		echo $ECHOOPT "${PROGRAM_NAME} ${PROGRAM_version}"
		exit 0
		;;
	--versioncheck)
		VERSIONCHECK=1
		;;
	-x)
		AUTO_X_OPT=1
		AUTO_X_DTCT=0
		;;
	-X)
		AUTO_X_OPT=1
		AUTO_X_DTCT=1
		;;
	*)
		echo "Invalid option specified: $1"
		exit 1
		;;
	esac

	shift
done


#
# We check that we are root. If we are not, then only the
# help and version command-line options are valid.
#

test "${OPERATING_SYSTEM}" = "SunOS" && ID_CMD="/usr/xpg4/bin/id"

if [ "`${ID_CMD} -u 2>/dev/null`" != "0" ]; then
	echo "You must be the root user to run this program."
	exit 1
fi


#
# Before going too much further we need to ensure that some basic
# commands are present on the system. We cannot do this using
# the BINDIR option because that requires processing the configuration
# file, which in turn requires the commands we want to check on. As
# such we use the default command directory list. We do not assign
# these commands to variables, but will do for other commands which we
# look for later on.
#

check_required_commands "${SPACEDPATH} ${DFLT_BINPATHS}"


######################################################################
#
# Configuration file processing
#
######################################################################


#
# Now we check for the configuration file, and then check the various
# options within it.
#

if [ -z "${CONFIGFILE}" ]; then
	if [ -f /etc/rkhunter.conf ]; then
		CONFIGFILE="/etc/rkhunter.conf"
	else
		CONFIGFILE="/usr/local/etc/rkhunter.conf"
	fi
fi

if [ ! -f "${CONFIGFILE}" ]; then
	echo "Unable to find configuration file: ${CONFIGFILE}"
	exit 1
elif [ ! -r "${CONFIGFILE}" ]; then
	echo "Configuration file is not readable: ${CONFIGFILE}"
	exit 1
fi


get_configfile_options


######################################################################
#
# Option processing
#
######################################################################


#
# Next we check some of the options to make sure we can proceed. We
# also set up some final variables based on the combination of options
# we have been given.
#

if [ $CHECK -eq 1 ]; then

	#
	# If the logfile has been disabled, then we cannot let the program
	# run when certain options are used. If we did, the user would see
	# no output and might assume that all was well.
	#

	if [ "${LOGFILE}" = "/dev/null" ]; then
		if [ $SHOWWARNINGSONLY -eq 1 ]; then
			echo "The logfile has been disabled - unable to report warnings."
			exit 1
		elif [ $CATLOGFILE -eq 1 ]; then
			echo "The logfile has been disabled - unable to display the log file."
			exit 1
		fi
	fi


	#
	# To perform the hash check requires a valid hash function command.
	# If required we simply tell the user that no hash function can be
	# found. If one is found, then set up the necessary hash directories
	# and file names.
	#

	if [ $GOOD_HASH_ENABLED -eq 1 ]; then
		if [ -z "${HASH_FUNC}" ]; then
			SKIP_GOODHASH_MSG=2
		else
			set_hash_dirs_files
		fi
	fi


	#
	# To perform the script replacement check requires the list
	# of hash directories and file names.
	#

	check_test scripts && set_hash_dirs_files


	#
	# Check if we have a ksyms or kallsyms file.
	#

	if [ -f "${ROOTDIR}/proc/ksyms" ]; then
		KSYMS_FILE="${ROOTDIR}/proc/ksyms"
	elif [ -f "${ROOTDIR}/proc/kallsyms" ]; then
		KSYMS_FILE="${ROOTDIR}/proc/kallsyms"
	fi


	check_test apps && APPS_CHECK_ENABLED=1
fi


if [ $CHECK -eq 1 -o $UPDATE -eq 1 ]; then
	#
	# Set up the colors to be used.
	#

	if [ $COLORS -eq 1 ]; then
		NORMAL="[0;39m"		# Foreground colour to default

		if [ $CLRSET2 -eq 0 ]; then
			RED="[1;31m"		# Bright red
			GREEN="[1;32m"	# Bright green
			YELLOW="[1;33m"	# Bright yellow
			WHITE="[1;37m"	# White
		else
			RED="[1;31m"		# Bright red
			GREEN="[0;32m"	# Green
			YELLOW="[0;35m"	# Purple
			WHITE="[0;30m"	# Black
		fi
	fi
fi


if [ $HASH_UPDATE -eq 1 ]; then

	#
	# For a hash update we must have a valid hash function to use.
	#

	if [ -z "${HASH_FUNC}" ]; then
		echo "Unable to find any hash function command to perform hash update."
		exit 1
	elif [ -z "${STAT_CMD}" ]; then
		echo "No 'stat' command can be found to perform the update."
		exit 1
	elif [ -h "${DB_PATH}/rkhunter.dat" ]; then
		echo "The rkhunter.dat file is a symbolic link: ${DB_PATH}/rkhunter.dat"
		echo "This is a security problem. The link points to another file, and that file is about to be modified by rkhunter."
		exit 1
	elif [ $PRELINKED -eq 1 ]; then
		RKHTMPVAR=`echo "${HASH_FUNC}" | cut -d' ' -f1`
		if [ -z "`echo ${RKHTMPVAR} | egrep -i 'sha1|md5'`" ]; then
			echo "This system uses prelinking, but the hash function (${HASH_FUNC}) does not look like SHA1 or MD5."
			exit 1
		fi
	fi


	#
	# Set up the hash files and directories
	# to be used for the hash checks.
	#

	set_hash_dirs_files
fi


#
# For the update and versioncheck options, we need to make sure
# we have a command capable of downloading files from the web.
# The first command found is used.
#

if [ $UPDATE -eq 1 -o $VERSIONCHECK -eq 1 ]; then
	FOUND=0

	for CMD in ${WEBCMDLIST}; do
		#
		# Ignore perl commands if perl is not present, or if
		# certain modules are not present.
		#

		if [ "${CMD}" = "GET" ]; then
			test -z "${PERL_CMD}" && continue

			MOD_INSTALLED=`${PERL_CMD} ${SCRIPT_PATH}/check_modules.pl LWP URI HTTP::Status HTTP::Date Getopt::Long 2>&1 | grep 'NOT'`

			test -n "${MOD_INSTALLED}" && continue
		elif [ "${CMD}" = "bget" ]; then
			test -z "${PERL_CMD}" && continue

			MOD_INSTALLED=`${PERL_CMD} ${SCRIPT_PATH}/check_modules.pl Socket Carp 2>&1 | grep 'NOT'`

			test -n "${MOD_INSTALLED}" && continue
		fi


		RKHTMPVAR=`echo ${CMD} | tr '[a-z]' '[A-Z]'`

		eval ${RKHTMPVAR}_CMD=`find_cmd ${CMD}`

		if [ -n "`eval echo \"\\$${RKHTMPVAR}_CMD\"`" ]; then
			FOUND=1
			break
		fi
	done

	if [ $FOUND -eq 0 ]; then
		echo "The \"--update\" and \"--versioncheck\" options require a command able to"
		echo "download files from the web. No such command can be found on the system."
		echo "Examples of commands that could be used are: ${WEBCMDLIST}"
		exit 1
	fi


	#
	# For the update option we must have the gunzip command available.
	#

	if [ $UPDATE -eq 1 ]; then
		GUNZIP_CMD=`find_cmd gunzip`

		if [ -z "${GUNZIP_CMD}" ]; then
			echo "The \"--update\" option requires the \"gunzip\" command."
			echo "This command cannot be found on the system."
			exit 1
		fi
	fi
fi


#
# If no option is given for the program to action, then say so and exit.
#

if [ $CHECK -eq 0 -a $VERSIONCHECK -eq 0 -a $UPDATE -eq 0 -a $HASH_UPDATE -eq 0 ]; then
	echo "You must enter an option for the program to perform."
	echo "Type in 'rkhunter --help' to see the available options,"
	echo "or read the rkhunter man page."
	exit 1
fi


#
# See if we have GRSEC installed.
#

if [ "${OPERATING_SYSTEM}" = "Linux" -a -n "`uname -a | grep 'grsec'`" ]; then
	GRSECINSTALLED=1
fi


#
# Before writing anything to the screen or log file, we need to
# set some variables.
#
# First we set whether we should be displaying anything on the
# screen or not.
#
if [ $CRONJOB -eq 1 -o $QUIET -eq 1 -o ! -t 1 ]; then
	NOTTY=1
fi

#
# Next we get the message types and results from the language file,
# and set them to variables. We have to look in the English file since
# that is the definitive one. We then look for the corresponding keyword
# in the actual language file. This allows the language files to work
# even if we add or remove any of the TYPE or RESULT keywords.
#
OLDIFS=$IFS
IFS="
"

for LINE in `egrep '^MSG_(TYPE|RESULT)_' ${DB_PATH}/i18n/en 2>/dev/null`; do
	TYPE=`echo "${LINE}" | cut -d: -f1`

	if [ "${LANGUAGE}" != "en" ]; then
		RKHTMPVAR=`grep "^${TYPE}:" ${DB_PATH}/i18n/${LANGUAGE} 2>/dev/null`
		test -n "${RKHTMPVAR}" && LINE=$RKHTMPVAR
	fi

	RKHTMPVAR=`echo "${LINE}" | cut -d: -f2-`

	eval $TYPE=\"${RKHTMPVAR}\"
done

IFS=$OLDIFS


#
# Sort out the logfile before we write to it. If we have no log file,
# then record this. The 'logtext' function will still be called, but
# will return straight away.
#

if [ "${LOGFILE}" = "/dev/null" ]; then
	NOLOG=1
else
	if [ $APPEND_LOG -eq 0 ]; then
		mv -f ${LOGFILE} ${LOGFILE}.old >/dev/null 2>&1
		touch ${LOGFILE} >/dev/null 2>&1
		chmod 600 ${LOGFILE} >/dev/null 2>&1
	else
		echo "" >>${LOGFILE}
		echo "" >>${LOGFILE}
	fi
fi


FOUNDTRACES="
-----------------------------------------------------------------------
Found parts of this rootkit/trojan by checking the default files and directories.
Please inspect the available files, by checking the logfile ($LOGFILE).
-----------------------------------------------------------------------
"


######################################################################
#
# Initial logging
#
######################################################################


#
# Write out various information messages to the logfile.
#

display --to SCREEN --type PLAIN VERSIONLINE "${PROGRAM_NAME}" "${PROGRAM_version}"

if [ -n "${HOST_NAME}" ]; then
	display --to LOG --type PLAIN VERSIONLINE2 "${PROGRAM_NAME}" "${PROGRAM_version}" ${HOST_NAME}
else
	display --to LOG --type PLAIN VERSIONLINE3 "${PROGRAM_NAME}" "${PROGRAM_version}"
fi

display --to LOG --type INFO --nl RKH_STARTDATE "`date`"

display --to LOG --type PLAIN --nl CONFIG_CHECK_START

display --to LOG --type INFO OPSYS "${OPERATING_SYSTEM}"

display --to LOG --type INFO CONFIG_CMDLINE "${CMD_LINE}"

display --to LOG --type INFO CONFIG_ENVSHELL ${SHELL} ${MYSHELL}

display --to LOG --type INFO CONFIG_CONFIGFILE "${CONFIGFILE}"

display --to LOG --type INFO CONFIG_INSTALLDIR "${INSTALLDIR}"

display --to LOG --type INFO CONFIG_LANGUAGE "${LANGUAGE}"

display --to LOG --type INFO CONFIG_DBDIR "${DB_PATH}"

display --to LOG --type INFO CONFIG_SCRIPTDIR "${SCRIPT_PATH}"

display --to LOG --type INFO CONFIG_BINDIR "${BINPATHS}"

if [ -z "${ROOTDIR}" ]; then
	display --to LOG --type INFO CONFIG_ROOTDIR "/"
else
	display --to LOG --type INFO CONFIG_ROOTDIR "${ROOTDIR}"
fi

display --to LOG --type INFO CONFIG_TMPDIR "${TMPDIR}"

if [ -z "${MAILONWARNING}" ]; then
	display --to LOG --type INFO CONFIG_NO_MAIL_ON_WARN
else
	display --to LOG --type INFO CONFIG_MAIL_ON_WARN "${MAILONWARNING}" "${MAIL_CMD}"
fi

test $ALLOW_SSH_ROOT_USER -eq 1 && display --to LOG --type INFO CONFIG_SSH_ROOT

test $AUTO_X_DTCT -eq 1 && display --to LOG --type INFO CONFIG_X_AUTO
test $CLRSET2 -eq 1 && display --to LOG --type INFO CONFIG_CLRSET2

for CMD in ${CMDLIST}; do
	RKHTMPVAR=`echo ${CMD} | tr '[a-z]' '[A-Z]'`
	RKHTMPVAR=`eval echo "\\$${RKHTMPVAR}_CMD"`
	if [ -n "${RKHTMPVAR}" ]; then
		display --to LOG --type INFO FOUND_CMD "${CMD}" "${RKHTMPVAR}"
	else
		display --to LOG --type INFO NOT_FOUND_CMD "${CMD}"
	fi
done

for CMD in ${WEBCMDLIST}; do
	RKHTMPVAR=`echo ${CMD} | tr '[a-z]' '[A-Z]'`
	RKHTMPVAR=`eval echo "\\$${RKHTMPVAR}_CMD"`
	if [ -n "${RKHTMPVAR}" ]; then
		display --to LOG --type INFO FOUND_CMD "${CMD}" "${RKHTMPVAR}"
	fi
done

if [ $HASH_UPDATE -eq 1 -o $GOOD_HASH_ENABLED -eq 1 ]; then
	if [ $PRELINKED -eq 1 ]; then
		RKHTMPVAR=$PRELINK_CMD
		test -n "${RUNCON_CMD}" && RKHTMPVAR=`echo "${RKHTMPVAR}" | cut -d' ' -f5`

		display --to LOG --type INFO FOUND_CMD 'prelink' "${RKHTMPVAR}"

		if [ -n "${RUNCON_CMD}" ]; then
			display --to LOG --type INFO FOUND_CMD 'runcon' "${RKHTMPVAR}"
		else
			display --to LOG --type INFO NOT_FOUND_CMD 'runcon'
		fi

		RKHTMPVAR=`echo "${HASH_FUNC}" | cut -d' ' -f1`
		if [ -z "`echo ${RKHTMPVAR} | egrep -i 'sha1|md5'`" ]; then
			SKIP_GOODHASH_MSG=3
		elif [ -n "`echo ${RKHTMPVAR} | egrep -i 'sha1'`" ]; then
			display --to LOG --type INFO SYS_PRELINK_SHA1 "${HASH_FUNC}"
		else
			display --to LOG --type INFO SYS_PRELINK_MD5 "${HASH_FUNC}"
		fi
	else
		display --to LOG --type INFO SYS_NO_PRELINK

		if [ -n "`echo "${HASH_FUNC}" | grep '/filehashsha1\.pl$'`" ]; then
			display --to LOG --type INFO HASH_PERL_SHA1
		elif [ -n "`echo "${HASH_FUNC}" | grep '/filehashmd5\.pl$'`" ]; then
			display --to LOG --type INFO HASH_PERL_MD5
		else
			display --to LOG --type INFO HASH_PERL_FUNC "${HASH_FUNC}"
		fi
	fi
fi

test $GRSECINSTALLED -eq 1 && display --to LOG --type INFO GRSECINSTALLED

if [ $CHECK -eq 1 ]; then
	display --to LOG --type INFO ENABLED_TESTS "${ENABLE_TESTS}"
	display --to LOG --type INFO DISABLED_TESTS "${DISABLE_TESTS}"

	test -z "${KSYMS_FILE}" && display --to LOG --type INFO KSYMS_MISSING


	#
	# To use syslog we must have the logger command present.
	#

	if [ -n "${USE_SYSLOG}" ]; then
		if [ "${USE_SYSLOG}" = "none" ]; then
			USE_SYSLOG=""
			display --to LOG --type INFO SYSLOG_DISABLED
		else
			LOGGER_CMD=`find_cmd logger`

			if [ -n "${LOGGER_CMD}" ]; then
				display --to LOG --type INFO SYSLOG_ENABLED "${USE_SYSLOG}"
			else
				USE_SYSLOG=""
				display --to LOG --type INFO SYSLOG_NO_LOGGER
			fi
		fi
	fi
fi


######################################################################
#
# Start of program actions and checks
#
######################################################################


#
# We can now start to run the actions the user has requested on
# the command-line. We run the update type commands first before
# doing any full system check.
#

#
# If the user wants to run a system check, then the rkhunter.dat
# file must exist. If it does not, or is empty, then we log the
# fact and inform the user to run RKH with the --hashupd option.
# The program will continue, but without the file hash checking.
#

if [ $HASH_UPDATE -eq 0 ]; then
	if [ $GOOD_HASH_ENABLED -eq 1 ]; then
		if [ ! -f "${DB_PATH}/rkhunter.dat" -o ! -s "${DB_PATH}/rkhunter.dat" ]; then
			if [ ! -f "${DB_PATH}/rkhunter.dat" ]; then
				SKIP_GOODHASH_MSG=4
			else
				SKIP_GOODHASH_MSG=5
			fi
		else

			#
			# We perform a simple check of some of the stored
			# O/S information, and compare it to the current
			# info. Basically we are just seeing if the system
			# has changed at all because it could affect the
			# file hash check. If it does then log it.
			#

			rkh_dat_get_os_info

			check_os_info
		fi
	fi
else
	#
	# The user wants to update the O/S and file hash data.
	#

	do_hash_update
fi


#
# The user wants to update the supplied RKH *.dat files.
#

test $UPDATE -eq 1 && do_update


#
# The user wants to check for the latest program version.
#

test $VERSIONCHECK -eq 1 && do_versioncheck


#
# The user wants to check the local system for anomalies.
#

test $CHECK -eq 1 && do_system_check


display --to LOG --type INFO --nl RKH_ENDDATE "`date`"

exit $RET_CODE
