#!/bin/sh

#
# rkhunter -- Scan the system for rootkits and other known security issues.
#
# Copyright (c) 2003-2006, Michael Boelen ( michael AT rootkit DOT nl )
#
#     This program is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program; if not, write to the Free Software
#     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
#


#
# Unfortunately we must do some O/S checks at the very beginning.
# Otherwise SunOS will complain about some of the ksh/bash syntax.
#

OPERATING_SYSTEM=`uname`

if [ "${OPERATING_SYSTEM}" = "SunOS" ]; then
	if [ -z "$RANDOM" ]; then
		if [ -n "`which bash 2>/dev/null | grep '^/'`" ]; then
			exec bash $0 $*
		else
			exec ksh $0 $*
		fi

		exit 0
	fi
fi

case "${OPERATING_SYSTEM}" in
AIX|OpenBSD|SunOS)
	# What is the default shell?
	if print >/dev/null 2>&1; then
		alias echo='print'
		E=""
		ECHOOPT="--"
		MYSHELL=ksh
	else
		E="-e"
		ECHOOPT=""
		MYSHELL=bash
	fi
	;;
*)
	E="-e"
	ECHOOPT=""


	#
	# We want to get the actual shell used by this program, and
	# so we need to test /bin/sh.
	#

	MYSHELL=/bin/sh
	test -h ${MYSHELL} && MYSHELL=`readlink ${MYSHELL} 2>/dev/null`
	MYSHELL=`basename ${MYSHELL} 2>/dev/null`

	if [ -z "${MYSHELL}" ]; then
		MYSHELL=bash
	elif [ "${MYSHELL}" = "dash" -o "${MYSHELL}" = "ash" ]; then
		E=""
	fi
	;;
esac


######################################################################
#
# Global function definitions
#
######################################################################


# Waitkeypress: wait for a keypress after some events
waitkeypress() {
	if [ "${WAITONWARNING}" -eq 1 -o "${PAUSEAFTERTESTS}" -eq 1 ]; then
		if [ ${QUIET} -eq 0 ]; then
			echo ""
			echo "[Press <ENTER> to continue]"
			read a
		fi
	fi
}


# Keypresspause: wait for a keypress, only if option is set
keypresspause() {
	if [ "${PAUSEAFTERTESTS}" -eq 1 -a "${QUIET}" -eq 0 ]; then
		echo ""
		echo "[Press <ENTER> to continue]"
		read a
	fi
}


# Logtext: add text to logfile
logtext() {
	test $NOLOG -eq 1 && return

	# Add date/time to logfile
	if [ "$1" = "--nodate" ]; then
		:
	elif [ "$1" = "--indent" ]; then
		echo -n "           " >>${LOGFILE}
	else
		echo -n "`date '+[%H:%M:%S] '`" >>${LOGFILE}
	fi

	NE1="n"
	[ "$1" = "-n" ] && NE1="y"
	[ "$1" = "-e" ] && NE1="y"

	if [ "$NE1" = "y" ]; then
		if [ "$MYSHELL" = "ksh" ]; then
			[ "$1" = "-n" ] &&  echo -n "$2" >>$LOGFILE || echo $ECHOOPT $2 >>$LOGFILE
		else
			echo $1 "$2" >>$LOGFILE
		fi
	else
		if [ "$1" = "--nodate" -o "$1" = "--indent" ]; then
			echo $ECHOOPT "$2" >>$LOGFILE
		else
			echo $ECHOOPT "$1" >>$LOGFILE
		fi
	fi
}


# Displaytext: display text to STDOUT
displaytext() {
	DODISPLAY=0
	FOUNDWARNING=0

	FOUNDWARNING1=`echo $ECHOOPT $1 | egrep 'BAD|Warning|WARNING|Watch'`
	FOUNDWARNING2=`echo $2 | egrep 'BAD|Warning|WARNING|Watch'`
	FOUNDWARNING3=`echo $3 | egrep 'BAD|Warning|WARNING|Watch'`

	if [ ! "${FOUNDWARNING1}" = "" -o ! "${FOUNDWARNING2}" = "" -o ! "${FOUNDWARNING3}" = "" ]; then
		FOUNDWARNING=1
		WARNING=1
	fi

	[ $QUIET -eq 0 -o $FOUNDWARNING -eq 1 ] && DODISPLAY=1

	if [ "$1" = "-n" -o "$1" = "-e" ]; then
		if [ $DODISPLAY -eq 1 ]; then
			if [ -n "$PREVIOUSTEXT" ]; then
				echo -n "${PREVIOUSTEXT}"
				PREVIOUSTEXT=""
			fi
			if [ "$MYSHELL" = "ksh" ]; then
				[ "$1" = "-n" ] && echo -n "$2" || echo $ECHOOPT "$2"
			else
				echo $ECHOOPT $1 "$2"
			fi
		else
			[ "$1" = "-n" ] && PREVIOUSTEXT=`echo "$2" | sed -e 's/^ *//'`
		fi
	else
		if [ $DODISPLAY -eq 1 ]; then
			if [ -n "$PREVIOUSTEXT" ]; then
				echo -n "${PREVIOUSTEXT}"
				PREVIOUSTEXT=""
			fi
			echo $ECHOOPT "$1"
		fi
	fi
}


insertlayout() {
	if [ ${CRONJOB} -eq 0 ]; then
		LAYOUT="\033[${jump}C"
	else
		LAYOUT="  "
	fi
}


scanrootkit() {
	if [ "${ROOTKIT_TESTS}" = "" ]; then
		ROOTKIT_TESTS="${SCAN_ROOTKIT}"
	else
		ROOTKIT_TESTS="${ROOTKIT_TESTS}, ${SCAN_ROOTKIT}"
	fi
	SCAN_STATUS=0
	JUMPCOL=`expr ${defaultcolumn} - 12`
	SIZE=`echo \'${SCAN_ROOTKIT}\' | wc -c | tr -s ' ' | tr -d ' '`
	jump=`expr ${JUMPCOL} - ${SIZE}`
	displaytext -n "   Rootkit '${SCAN_ROOTKIT}'... "
	logtext "*** Start scan ${SCAN_ROOTKIT} ***"

	for I in $SCAN_FILES; do
		SCANNED_COUNT=`expr ${SCANNED_COUNT} + 1`
		I=`echo ${I} | tr -s '%' ' '`
		logtext -n "  - File ${I}... "
		if [ -f "${I}" ]; then
			logtext --nodate "WARNING! Exists."
			SCAN_STATUS=1
			# Set warning value, to exit with a non-zero value
			WARNING=1
		else
			logtext --nodate "OK. Not found."
		fi
	done

	for I in $SCAN_DIRS; do
		I=`echo ${I} | tr -s '%' ' '`
		logtext -n "  - Directory ${I}... "
		if [ -d "${I}" ]; then
			logtext --nodate "WARNING! Exists."
			SCAN_STATUS=1
		else
			logtext --nodate "OK. Not found."
		fi
	done

	# Scan ksyms or kallsyms file
	if [ -n "${SCAN_KSYMS}" -a -n "${KSYMS_FILE}" ]; then
		SEARCHTEXT=`grep ${SCAN_KSYMS} ${KSYMS_FILE}`
		if [ -n "${SEARCHTEXT}" ]; then
			logtext "WARNING! Found ${SCAN_KSYMS}"
		else
			logtext "${KSYMS_FILE} file seems to be clean"
		fi
	fi

	if [ "${SCAN_STATUS}" -eq 1 ]; then
		insertlayout
		displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
		INFECTED_COUNT=`expr ${INFECTED_COUNT} + 1`
		INFECTED_NAMES="${INFECTED_NAMES}${SCAN_ROOTKIT} "
		displaytext "${FOUNDTRACES}"

		# Run routine
		waitkeypress
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
	fi
}


scanrootkit_suckit_extra_checks() {
	if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
		if [ -n "${STAT_CMD}" -a -z "`echo ${STAT_CMD} | grep '\.pl$'`" ]; then
			# Let's check the amount of links /sbin/init has
			unset i;
			i=`${STAT_CMD} -t /sbin/init | cut -d ' ' -f9`
			case ${i} in
			1)
				;;
			*)
				logtext "WARNING! ${SCAN_ROOTKIT} /sbin/init linkage"
				SCAN_STATUS=1
				;;
			esac
			# Let's check xrk or mem hiding
			# Easiest way to define random?
			__RANDOM=$$$(date +%s)
			umask 027
			for ext in xrk mem; do
				randf="${TMPDIR}/${__RANDOM}.${ext}"
				test -f ${randf} || \
				( touch ${randf} && test -f ${randf} && rm -f ${randf} || \
					logtext "WARNING! ${SCAN_ROOTKIT} ${ext} hiding" )
			done

			# Plugin: skdet
			SKDET_CMD=`find_cmd skdet`
			if [ -n "${SKDET_CMD}" ]; then
				# Skdet version
				SKDETVER=`${SKDET_CMD} -v 2>&1 | grep '^skdet.v' | awk -F'.' '{ print $1 }'`
				case "${SKDETVER}" in
					*v0)
						SKDETOPT="-a"
						;;
					*v1)
						SKDETOPT="-c"
						;;
				esac
				${SKDET_CMD} ${SKDETOPT} 2>&1 | tr -s " " | grep -i 'invis'
			fi
		else
			logtext "Info: Extended suckit tests skipped, due to missing stat command"
		fi
	else
		logtext "Info: Extended suckit tests skipped for this operating system (not Linux architecture)"
	fi
}


check_required_commands() {

	#
	# This function checks that some required commands are
	# present on the system. The function takes one argument
	# which is a list of directories to look in.
	#

	for CMD in grep sed tail; do
		SEEN=0

		for DIR in $1; do
			test ! -d ${DIR} && continue

			if [ -f "${DIR}/${CMD}" -a -x "${DIR}/${CMD}" ]; then
				SEEN=1
				break
			fi
		done

		if [ $SEEN -eq 0 ]; then
			echo "The command '$CMD' must be present on the system in order to run rkhunter."
			exit 1
		fi
	done

	return
}


check_commands() {
# jh - need to check where perl is used - must verify that perl is available.

	#
	# We check for some commands used in the tests. If the command
	# is found then a variable including the command name is set.
	# These commands are not 'required', so nothing happens if the
	# command is not found.
	#

	for CMD in ${CMDLIST}; do
		UCMD=`echo ${CMD} | tr [a-z] [A-Z]`

		eval ${UCMD}_CMD=`find_cmd ${CMD}`
	done


	#
	# If we cannot find a stat command, then see if we can use the
	# supplied perl script.
	#

	if [ -z "${STAT_CMD}" -a -n "${PERL_CMD}" ]; then
		STAT_CMD=`find_cmd ${SCRIPT_PATH}/stat.pl`
		test -n "${STAT_CMD}" && STAT_CMD="${PERL_CMD} ${STAT_CMD}"
	fi

	return
}


get_installdir_option() {

	#
	# This function obtains the RKH installation directory. It must
	# be set by the installer script, and has no default.
	#

	INSTALLDIR=`grep '^INSTALLDIR=' ${CONFIGFILE} | tail -1 | sed -e 's/INSTALLDIR=//' | tr -d '"' | tr -s ' '`

	if [ -z "${INSTALLDIR}" -o "${INSTALLDIR}" = " " ]; then
		echo "Invalid INSTALLDIR configuration option - no installation directory specified."
		exit 1
	elif [ ! -d "${INSTALLDIR}" ]; then
		echo "Installation directory does not exist: ${INSTALLDIR}"
		exit 1
	elif [ ! -r "${INSTALLDIR}" ]; then
		echo "Installation directory is not readable: ${INSTALLDIR}"
		exit 1
	fi

	return
}


get_logfile_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${LOGFILE}" ]; then
		LOGFILE=`echo "${LOGFILE}" | tr -s ' '`

		if [ "${LOGFILE}" = " " ]; then
			echo "Invalid --logfile option - no logfile name given."
			exit 1
		fi
	else
		LOGFILE=`grep '^LOGFILE=' ${CONFIGFILE} | tail -1`

		if [ -n "${LOGFILE}" ]; then
			LOGFILE=`echo "${LOGFILE}" | sed -e 's/LOGFILE=//' | tr -d '"' | tr -s ' '`

			if [ -z "${LOGFILE}" -o "${LOGFILE}" = " " ]; then
				echo "Invalid LOGFILE configuration option - no logfile name specified."
				exit 1
			fi
		else
			echo "Default logfile will be used ($DFLT_LOGFILE)."
			LOGFILE=$DFLT_LOGFILE
		fi
	fi

	#
	# Now check that the given option is useable.
	#

	if [ "${LOGFILE}" = "/dev/null" ]; then
		APPEND_LOG=0
	else
		LOGDIR=`echo "${LOGFILE}" | sed -e 's/\/[^/][^/]*$//'`

		if [ -z "`echo ${LOGDIR} | grep '/'`" ]; then
			LOGDIR="."
		fi

		if [ "${LOGDIR}" = "${LOGFILE}" ]; then
			echo "No log filename given: ${LOGFILE}"
			exit 1
		elif [ ! -d "${LOGDIR}" ]; then
			echo "Logfile directory does not exist: ${LOGFILE}"
			exit 1
		elif [ ! -w "${LOGDIR}" ]; then
			echo "Logfile directory is not writable: ${LOGFILE}"
			exit 1
		elif [ ! -r "${LOGDIR}" ]; then
			echo "Logfile directory is not readable: ${LOGFILE}"
			exit 1
		elif [ -h "${LOGFILE}" ]; then
			echo "Logfile is a symbolic link: ${LOGFILE}"
			echo "This is a security problem. The link points to another file, and that file is about to be modified by rkhunter."
			exit 1
		elif [ -e "${LOGFILE}" -a ! -f "${LOGFILE}" ]; then
			echo "Logfile already exists but it is not a file: ${LOGFILE}"
			exit 1
		fi

		#
		# Now check whether we should append to the logfile
		# or overwrite it. We check the configuration file
		# option, if it is given, and ensure that it is valid.
		#

		if [ $APPEND_OPT -eq 0 ]; then
			APPEND_LOG=`grep '^APPEND_LOG=' ${CONFIGFILE} | tail -1`

			if [ -n "${APPEND_LOG}" ]; then
				APPEND_LOG=`echo "${APPEND_LOG}" | sed -e 's/APPEND_LOG=//' | tr -d '"' | tr -s ' '`

				if [ -z "${APPEND_LOG}" -o "${APPEND_LOG}" = " " ]; then
					echo "Invalid APPEND_LOG configuration option - no value specified."
					exit 1
				elif [ "${APPEND_LOG}" != "0" -a "${APPEND_LOG}" != "1" ]; then
					echo "Invalid APPEND_LOG configuration option: ${APPEND_LOG}"
					exit 1
				fi
			else
				APPEND_LOG=0
			fi
		fi
	fi

	return
}


get_tmpdir_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${TMPDIR}" ]; then
		TMPDIR=`echo "${TMPDIR}" | tr -s ' '`

		if [ "${TMPDIR}" = " " ]; then
			echo "Invalid --tmpdir option - no directory name given."
			exit 1
		fi
	else
		TMPDIR=`grep '^TMPDIR=' ${CONFIGFILE} | tail -1`

		if [ -n "${TMPDIR}" ]; then
			TMPDIR=`echo "${TMPDIR}" | sed -e 's/TMPDIR=//' | tr -d '"' | tr -s ' '`

			if [ -z "${TMPDIR}" -o "${TMPDIR}" = " " ]; then
				echo "Invalid TMPDIR configuration option - no directory name specified."
				exit 1
			fi
		else
			TMPDIR="${INSTALLDIR}/lib/rkhunter/tmp"
		fi
	fi

	#
	# Now check that the given option is useable.
	#

	if [ ! -d "${TMPDIR}" ]; then
		echo "Temporary directory does not exist: ${TMPDIR}"
		exit 1
	elif [ ! -w "${TMPDIR}" ]; then
		echo "Temporary directory is not writable: ${TMPDIR}"
		exit 1
	elif [ ! -r "${TMPDIR}" ]; then
		echo "Temporary directory is not readable: ${TMPDIR}"
		exit 1
	fi

	return
}


get_dbdir_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${DB_PATH}" ]; then
		DB_PATH=`echo "${DB_PATH}" | tr -s ' '`

		if [ "${DB_PATH}" = " " ]; then
			echo "Invalid --dbdir option - no directory name given."
			exit 1
		fi
	else
		DB_PATH=`grep '^DBDIR=' ${CONFIGFILE} | tail -1`

		if [ -n "${DB_PATH}" ]; then
			DB_PATH=`echo "${DB_PATH}" | sed -e 's/DBDIR=//' | tr -d '"' | tr -s ' '`

			if [ -z "${DB_PATH}" -o "${DB_PATH}" = " " ]; then
				echo "Invalid DBDIR configuration option - no directory name specified."
				exit 1
			fi
		else
			DB_PATH="${INSTALLDIR}/lib/rkhunter/db"
		fi
	fi

	#
	# Now check that the given option is useable.
	#

	if [ ! -d "${DB_PATH}" ]; then
		echo "Database directory does not exist: ${DB_PATH}"
		exit 1
	elif [ ! -w "${DB_PATH}" ]; then
		echo "Database directory is not writable: ${DB_PATH}"
		exit 1
	elif [ ! -r "${DB_PATH}" ]; then
		echo "Database directory is not readable: ${DB_PATH}"
		exit 1
	fi

	return
}


add_extra_dirs() {

	#
	# This functions takes care of any additional directories
	# that may exist on some systems. After the function is called
	# the value of EXTRA_DIRS must be added to whatever variable
	# is being used.
	#

	EXTRA_DIRS=""

	if [ "${OPERATING_SYSTEM}" = "SunOS" ]; then
		#
		# Add in some other directories, and those which
		# contain the Sun 'companion' software.
		#

		test -d /usr/sfw && EXTRA_DIRS="${EXTRA_DIRS} /usr/sfw/bin /usr/sfw/sbin /usr/sfw/libexec"

		test -d /opt/sfw && EXTRA_DIRS="${EXTRA_DIRS} /opt/sfw/bin /opt/sfw/sbin /opt/sfw/libexec"

		test -d /usr/xpg4/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/xpg4/bin"

		test -d /usr/ccs/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/ccs/bin"
	elif [ "${OPERATING_SYSTEM}" = "NetBSD" ]; then
		test -d /usr/pkg/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/pkg/bin"
		test -d /usr/pkg/sbin && EXTRA_DIRS="${EXTRA_DIRS} /usr/pkg/sbin"
		test -d /usr/pkg/libexec && EXTRA_DIRS="${EXTRA_DIRS} /usr/pkg/libexec"
	elif [ "${OPERATING_SYSTEM}" = "Darwin" ]; then
		#
		# Cater for Fink (Mac OSX) additional software.
		#

		test -d /sw/bin && EXTRA_DIRS="${EXTRA_DIRS} /sw/bin"
		test -d /sw/sbin && EXTRA_DIRS="${EXTRA_DIRS} /sw/sbin"
	fi


	#
	# Finally check if there are any optional
	# bin and sbin directories present.
	#

	test -d /usr/opt/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/opt/bin"
	test -d /usr/opt/sbin && EXTRA_DIRS="${EXTRA_DIRS} /usr/opt/sbin"
	test -d /opt/bin && EXTRA_DIRS="${EXTRA_DIRS} /opt/bin"
	test -d /opt/sbin && EXTRA_DIRS="${EXTRA_DIRS} /opt/sbin"

	return
}


get_bindir_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	USE_DFLT=0

	if [ -n "${BINPATHS}" ]; then
		BINPATHS=`echo "${BINPATHS}" | tr -s ' '`

		if [ "${BINPATHS}" = " " ]; then
			echo "Invalid --bindir option - no directory names given."
			exit 1
		fi
	else
		BINPATHS=`grep '^BINDIR=' ${CONFIGFILE} | tail -1`

		if [ -n "${BINPATHS}" ]; then
			BINPATHS=`echo "${BINPATHS}" | sed -e 's/BINDIR=//' | tr -d '"' | tr -s ' '`

			if [ -z "${BINPATHS}" -o "${BINPATHS}" = " " ]; then
				echo "Invalid BINDIR configuration option - no directory names specified."
				exit 1
			fi
		else
			USE_DFLT=1

			BINPATHS=${DFLT_BINPATHS}


			#
			# Under SunOS /bin is a link to /usr/bin, so
			# there is no need to look in it.
			#

			if [ "${OPERATING_SYSTEM}" = "SunOS" -o "${OPERATING_SYSTEM}" = "AIX" ]; then
				if [ -h /bin ]; then
					B=""

					for DIR in ${BINPATHS}; do
						test "${DIR}" != "/bin" && B="${B} ${DIR}"
					done

					BINPATHS=`echo ${B} | sed -e 's/^ *//'`
				fi
			fi


			add_extra_dirs
			BINPATHS="${BINPATHS}${EXTRA_DIRS}"
		fi
	fi


	#
	# This is a simple check that each directory begins with
	# a '.' or '/', and that the directory exists.
	#

	for DIR in ${BINPATHS}; do
		if [ -z "`echo ${DIR} | grep '^[./]'`" ]; then
			echo "Invalid BINDIR directory: ${DIR}"
			exit 1
		elif [ ! -d ${DIR} -a $USE_DFLT -eq 0 ]; then
			echo "Non-existent BINDIR directory: ${DIR}"
			exit 1
		fi
	done

	return
}


get_scriptdir_option() {

	#
	# Get the value from the configuration file, and do a simple
	# check on whether it is empty or a space.
	#
	# Note: The installer will set this option. As such there
	# is no default.
	#

	SCRIPT_PATH=`grep '^SCRIPTDIR=' ${CONFIGFILE} | tail -1`

	if [ -n "${SCRIPT_PATH}" ]; then
		SCRIPT_PATH=`echo "${SCRIPT_PATH}" | sed -e 's/SCRIPTDIR=//' | tr -d '"' | tr -s ' '`

		if [ -z "${SCRIPT_PATH}" -o "${SCRIPT_PATH}" = " " ]; then
			echo "Invalid SCRIPTDIR configuration option - no directory name specified."
			exit 1
		fi
	else
		echo "The SCRIPTDIR configuration option has not been set by the installer."
		exit 1
	fi

	#
	# Now check that the given option is useable.
	#

	if [ ! -d "${SCRIPT_PATH}" ]; then
		echo "Script directory does not exist: ${SCRIPT_PATH}"
		exit 1
	elif [ ! -r "${SCRIPT_PATH}" ]; then
		echo "Script directory is not readable: ${SCRIPT_PATH}"
		exit 1
	fi

	return
}


find_cmd() {

	#
	# This function performs a search of the PATH and BINPATHS
	# directories looking for the requested command. The full
	# pathname is returned if the command is found.
	#
	# If a full pathname is provided then we simply check that
	# it is executable.
	#

	CMD=$1

	test -z "${CMD}" && return

	if [ -n "`echo ${CMD} | grep '/'`" ]; then
		test -f "${CMD}" -a -x "${CMD}" && echo "${CMD}"
	else
		for CMDDIR in ${SPACEDPATH} ${BINPATHS}; do
			if [ -f "${CMDDIR}/${CMD}" -a -x "${CMDDIR}/${CMD}" ]; then
				echo "${CMDDIR}/${CMD}"
				return
			fi
		done
	fi

	return
}


get_rootdir_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${ROOTDIR}" ]; then
		ROOTDIR=`echo "${ROOTDIR}" | tr -s ' '`

		if [ "${ROOTDIR}" = " " ]; then
			echo "Invalid --rootdir option - no directory name given."
			exit 1
		fi
	else
		ROOTDIR=`grep '^ROOTDIR=' ${CONFIGFILE} | tail -1`

		if [ -n "${ROOTDIR}" ]; then
			ROOTDIR=`echo "${ROOTDIR}" | sed -e 's/ROOTDIR=//' | tr -d '"' | tr -s ' '`

			if [ -z "${ROOTDIR}" -o "${ROOTDIR}" = " " ]; then
				echo "Invalid ROOTDIR configuration option - no directory name specified."
				exit 1
			fi
		fi
	fi

	#
	# Now check that the given option is useable.
	#

	if [ ! -d "${ROOTDIR}" ]; then
		echo "The root directory does not exist: ${ROOTDIR}"
		exit 1
	elif [ ! -r "${ROOTDIR}" ]; then
		echo "The root directory is not readable: ${ROOTDIR}"
		exit 1
	fi

	return
}


get_mailonwarn_option() {

	#
	# Get the option from the configuration file, and do a simple
	# check on whether it is empty or a space.
	#

	MAILONWARNING=`grep '^MAIL-ON-WARNING=' ${CONFIGFILE} | tail -1`

	if [ -n "${MAILONWARNING}" ]; then
		MAILONWARNING=`echo "${MAILONWARNING}" | sed -e 's/MAIL-ON-WARNING=//' | tr -d '"' | tr -s ' '`

		if [ -z "${MAILONWARNING}" -o "${MAILONWARNING}" = " " ]; then
			echo "Invalid MAIL-ON-WARNING configuration option - no email address specified."
			exit 1
		fi
	fi


	if [ -n "${MAILONWARNING}" ]; then
		MAIL_CMD=`grep '^MAIL_CMD=' ${CONFIGFILE} | tail -1`

		if [ -n "${MAIL_CMD}" ]; then
			MAIL_CMD=`echo "${MAIL_CMD}" | sed -e 's/MAIL_CMD=//' | sed -e 's/^"\(.*\)"$/\1/' | tr -s ' '`

			if [ -z "${MAIL_CMD}" -o "${MAIL_CMD}" = " " ]; then
				echo "Invalid MAIL_CMD configuration option - no command specified."
				exit 1
			fi
		else
			MAIL_CMD="mail -s \"[rkhunter] Warnings found for \${HOST_NAME}\""
		fi


		#
		# Check that the mail command is executable.
		#

		MCMD=`echo "${MAIL_CMD}" | cut -d' ' -f1`
		MC=`find_cmd ${MCMD}`

		if [ -n "${MC}" ]; then
			#
			# We rebuild the command to use the full pathname.
			#

			MCMD=`echo "${MAIL_CMD}" | cut -d' ' -f2-`

			if [ -z "${MCMD}" -o "${MCMD}" = "${MAIL_CMD}" ]; then
				MAIL_CMD=${MC}
			else
				MAIL_CMD="${MC} ${MCMD}"
			fi
		else
			echo "Invalid MAIL_CMD configuration option - command '${MCMD}' is non-existent or not executable."
			exit 1
		fi
	fi

	return
}


get_allow_rootssh_option() {

	#
	# If the option is not specified on the command-line, then
	# get it from the configuration file. Next do a simple check
	# on whether it is empty, a space, or not 0 or 1.
	#

	if [ $ALLOW_SSH_ROOT_USER -eq 0 ]; then
		ALLOW_SSH_ROOT_USER=`grep '^ALLOW_SSH_ROOT_USER=' ${CONFIGFILE} | tail -1`

		if [ -n "${ALLOW_SSH_ROOT_USER}" ]; then
			ALLOW_SSH_ROOT_USER=`echo "${ALLOW_SSH_ROOT_USER}" | sed -e 's/ALLOW_SSH_ROOT_USER=//' | tr -d '"' | tr -s ' '`

			if [ -z "${ALLOW_SSH_ROOT_USER}" -o "${ALLOW_SSH_ROOT_USER}" = " " ]; then
				echo "Invalid ALLOW_SSH_ROOT_USER configuration option - no value specified."
				exit 1
			elif [ "${ALLOW_SSH_ROOT_USER}" != "0" -a "${ALLOW_SSH_ROOT_USER}" != "1" ]; then
				echo "Invalid ALLOW_SSH_ROOT_USER configuration option: ${ALLOW_SSH_ROOT_USER}"
				exit 1
			fi
		else
			ALLOW_SSH_ROOT_USER=0
		fi
	fi

	return
}


get_auto_x_option() {

	#
	# For the second colour set we first see if the auto X detect option
	# has been set. If it is set, and X is in use, then the second colour
	# set is used. If X is not in use, or the auto detect option is not
	# set, then we only use the second colour set if the command-line
	# option is used or it is configured in the configuration file.
	#

	if [ $AUTO_X_OPT -eq 0 ]; then
		AUTO_X_DTCT=`grep '^AUTO_X_DETECT=' ${CONFIGFILE} | tail -1`

		if [ -n "${AUTO_X_DTCT}" ]; then
			AUTO_X_DTCT=`echo "${AUTO_X_DTCT}" | sed -e 's/AUTO_X_DETECT=//' | tr -d '"' | tr -s ' '`

			if [ -z "${AUTO_X_DTCT}" -o "${AUTO_X_DTCT}" = " " ]; then
				echo "Invalid AUTO_X_DETECT configuration option - no value specified."
				exit 1
			elif [ "${AUTO_X_DTCT}" != "0" -a "${AUTO_X_DTCT}" != "1" ]; then
				echo "Invalid AUTO_X_DETECT configuration option: ${AUTO_X_DTCT}"
				exit 1
			fi
		else
			AUTO_X_DTCT=0
		fi
	fi


	if [ $AUTO_X_DTCT -eq 1 -a -n "$DISPLAY" ]; then
		CLRSET2=1
	fi


	if [ $CLRSET2 -eq 0 ]; then
		CLRSET2=`grep '^COLOR_SET2=' ${CONFIGFILE} | tail -1`

		if [ -n "${CLRSET2}" ]; then
			CLRSET2=`echo "${CLRSET2}" | sed -e 's/COLOR_SET2=//' | tr -d '"' | tr -s ' '`

			if [ -z "${CLRSET2}" -o "${CLRSET2}" = " " ]; then
				echo "Invalid COLOR_SET2 configuration option - no value specified."
				exit 1
			elif [ "${CLRSET2}" != "0" -a "${CLRSET2}" != "1" ]; then
				echo "Invalid COLOR_SET2 configuration option: ${CLRSET2}"
				exit 1
			fi
		else
			CLRSET2=0
		fi
	fi

	return
}


get_if_prelinked() {

	#
	# If the system appears to be using prelinking, but no
	# prelink command can be found, then we simply skip the
	# hash checks. We do not exit because this is a suspicious
	# circumstance, and it may be better to check the system
	# regardless of the hash checks.
	#

	if [ -f ${ROOTDIR}etc/prelink.cache ]; then
		PRELINK_CMD=`find_cmd prelink`

		if [ -n "${PRELINK_CMD}" ]; then
			PRELINKED=1

			RUNCON_CMD=`find_cmd runcon`

			if [ -n "${RUNCON_CMD}" ]; then
				PRELINK_CMD="${RUNCON_CMD} -t unconfined_t -- ${PRELINK_CMD}"
			fi
		else
			SKIP_HASHCHECK=1
			PRELINK_WARN="Warning: This system uses prelinking, but no prelink command can be found.\n    The file hash check will be skipped."
		fi
	fi

	return
}


get_md5_cmd() {

	#
	# This function is different from the others in that it is
	# called in more than one place. As such we do not generate
	# an error message if no MD5 command can be found - we leave
	# that to the calling code.
	#
	# As usual we first test any given command-line option, and
	# then check the configuration file. We do generate an error
	# message if either of these is invalid.
	#

	if [ -n "${MD5_CMD}" ]; then
		MD5_CMD=`echo "${MD5_CMD}" | tr -s ' '`

		if [ "${MD5_CMD}" = " " ]; then
			echo "Invalid --md5 option - no command given."
			exit 1
		fi
	else
		MD5_CMD=`grep '^MD5_CMD=' ${CONFIGFILE} | tail -1`

		if [ -n "${MD5_CMD}" ]; then
			MD5_CMD=`echo "${MD5_CMD}" | sed -e 's/MD5_CMD=//' | sed -e 's/^"\(.*\)"$/\1/' | tr -s ' '`

			if [ -z "${MD5_CMD}" -o "${MD5_CMD}" = " " ]; then
				echo "Invalid MD5_CMD configuration option - no command specified."
				exit 1
			fi
		else
			MD5_CMD=`find_cmd md5sum`

			if [ -z "${MD5_CMD}" ]; then
				MD5_CMD=`find_cmd md5`

				if [ "${OPERATING_SYSTEM}" = "NetBSD" -a "${MD5_CMD}" = "/usr/bin/md5" ]; then
					MD5_CMD="${MD5_CMD} -n"
				fi
			fi

			if [ -z "${MD5_CMD}" -a -n "${PERL_CMD}" ]; then
				MOD_INSTALLED=`${PERL_CMD} ${SCRIPT_PATH}/check_modules.pl 2>&1 | grep 'Digest::MD5 installed'`

				if [ -n "${MOD_INSTALLED}" ]; then
					MD5_CMD="${PERL_CMD} ${SCRIPT_PATH}/filehashmd5.pl"
				fi
			fi
		fi
	fi


	#
	# We now do a final check that the command is executable.
	#

	if [ -n "${MD5_CMD}" ]; then
		MCMD=`echo "${MD5_CMD}" | cut -d' ' -f1`
		MC=`find_cmd ${MCMD}`

		if [ -n "${MC}" ]; then
			#
			# We rebuild the command to use the full pathname.
			#

			MCMD=`echo "${MD5_CMD}" | cut -d' ' -f2-`

			if [ -z "${MCMD}" -o "${MCMD}" = "${MD5_CMD}" ]; then
				MD5_CMD=${MC}
			else
				MD5_CMD="${MC} ${MCMD}"
			fi
		else
			echo "Invalid MD5 hash option - command '${MCMD}' is non-existent or not executable."
			exit 1
		fi
	fi

	return
}


get_hash_function() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${HASH_FUNC}" ]; then
		HASH_FUNC=`echo "${HASH_FUNC}" | tr -s ' '`

		if [ "${HASH_FUNC}" = " " ]; then
			echo "Invalid --hash option - no command given."
			exit 1
		fi
	else
		HASH_FUNC=`grep '^HASH_FUNC=' ${CONFIGFILE} | tail -1`

		if [ -n "${HASH_FUNC}" ]; then
			HASH_FUNC=`echo "${HASH_FUNC}" | sed -e 's/HASH_FUNC=//' | sed -e 's/^"\(.*\)"$/\1/' | tr -s ' '`

			if [ -z "${HASH_FUNC}" -o "${HASH_FUNC}" = " " ]; then
				echo "Invalid HASH_FUNC configuration option - no command specified."
				exit 1
			fi
		fi
	fi


	#
	# At this point we have either been given a hash function
	# command, one of the reserved words 'SHA1' or 'MD5', or
	# nothing. For the reserved words we must find the SHA1 or
	# MD5 command or use the supplied perl scripts.
	#

	if [ -z "${HASH_FUNC}" -o "${HASH_FUNC}" = "SHA1" ]; then
		HF=`find_cmd sha1sum`

		if [ -z "${HF}" ]; then
			HF=`find_cmd sha1`

			if [ "${HF}" = "/usr/bin/sha1" -a "${OPERATING_SYSTEM}" = "NetBSD" ]; then
				HF="${HF} -n"
			fi
		fi

		if [ -z "${HF}" -a -n "${PERL_CMD}" ]; then
			MOD_INSTALLED=`${PERL_CMD} ${SCRIPT_PATH}/check_modules.pl | grep 'Digest::SHA1 installed'`

			if [ -n "${MOD_INSTALLED}" ]; then
				HASH_FUNC="${PERL_CMD} ${SCRIPT_PATH}/filehashsha1.pl"
			else
				HASH_FUNC=""
			fi
		else
			HASH_FUNC=${HF}
		fi
	elif [ "${HASH_FUNC}" = "MD5" ]; then
		test -z "${MD5_CMD}" && get_md5_cmd

		HASH_FUNC=${MD5_CMD}
	fi


	#
	# A final check that the command is actually executable.
	# This will ensure that the sha1/md5 perl scripts have been
	# installed correctly, should they be needed.
	#

	if [ -n "${HASH_FUNC}" ]; then
		HCMD=`echo "${HASH_FUNC}" | cut -d' ' -f1`
		HF=`find_cmd ${HCMD}`

		if [ -n "${HF}" ]; then
			#
			# We rebuild the command to use the full pathname.
			#

			HCMD=`echo "${HASH_FUNC}" | cut -d' ' -f2-`

			if [ -z "${HCMD}" -o "${HCMD}" = "${HASH_FUNC}" ]; then
				HASH_FUNC=${HF}
			else
				HASH_FUNC="${HF} ${HCMD}"
			fi
		else
			echo "Invalid hash option - command '${HCMD}' is non-existent or not executable."
			exit 1
		fi
	fi

	return
}


get_configfile_options() {

	#
	# We call separate functions to process each option. The option
	# is checked first to see if it has been given on the command-line,
	# and, if not, then if it is specified in the configuration file.
	#

	get_installdir_option

	get_bindir_option

	get_logfile_option

	get_tmpdir_option

	get_dbdir_option

	get_scriptdir_option

	get_rootdir_option

	get_mailonwarn_option


	#
	# Now that we have processed BINDIR, we will recheck the
	# required commands.
	#
	# Before proceeding too far we also check that we have certain
	# commands available. Typically these are commands which might
	# not have been installed as part of the core system, but are
	# used by RKH. These commands are not 'required' though.
	#

	check_required_commands "${BINPATHS}"

	check_commands


	#
	# Some options are only required when checking the system.
	#

	if [ $CHECK -eq 1 ]; then
		get_allow_rootssh_option

		get_auto_x_option


		#
		# For the 'known bad' MD5 hash file check we must have
		# an MD5 command available for use.
		#

		test $PERFORMKNOWNBAD -eq 1 && get_md5_cmd
	fi


	#
	# We only need the hash function options if we are going to
	# be checking the system or updating the hash database.
	#

	if [ $CHECK -eq 1 -o $HASH_UPDATE -eq 1 ]; then
		#
		# For the file hash check we need to find out if we are
		# a prelinked system, and if so, then find out which
		# hash function to use. We also need to find the 'stat'
		# command.
		#

		if [ $SKIP_HASHCHECK -eq 0 -o $HASH_UPDATE -eq 1 ]; then
			get_if_prelinked

			test $SKIP_HASHCHECK -eq 0 && get_hash_function
		fi
	fi

	return
}


rkh_dat_set_version() {

	#
	# This function calculates and writes out the 'Version:' value
	# for the rkhunter.dat file. It looks for an old value, and adds
	# one to it. If there is no value then simply start at one.
	#

	TODAY=`date +%Y%m%d`

	OLDVER=`grep '^Version:' ${RKHDAT_FILE} 2>/dev/null | tail -1 | cut -d: -f2`

	if [ -n "${OLDVER}" ]; then
		OLDVER=`echo "${OLDVER}" | cut -c9-10`

		if [ "${OLDVER}" = "99" ]; then
			NEWVER="00"
		else
			NEWVER=`expr ${OLDVER} + 1`
			test $NEWVER -lt 10 && NEWVER="0${NEWVER}"
		fi
	else
		NEWVER="00"
	fi

	echo "Version:${TODAY}${NEWVER}" >>${RKHDAT_FILE}

	return
}


rkh_dat_get_os_info() {

	#
	# This function obtains information about the local computer
	# system. This is then written into the rkhunter.dat file
	# using a simple 'keyword:<value>' format. The OSNAME and
	# ARCH values are not important, but are simply used to check
	# whether they have changed since RKH was last run.
	#
	# Obtaining the OSNAME is somewhat tricky. There is no sure
	# way of finding the information, so we have to use some tricks
	# to locate the correct file. First we look for certain specific
	# O/S release files, and then at the /etc/release file, but not
	# if it is a link. Next we look for a generic /etc/*-release
	# file, again not as a link. This should find most O/S versions.
	# Overall this should also save users having to ask us to support
	# their O/S. In other cases, we will have to ask what file does
	# contain their O/S release information.
	#

	ARCH=`uname -m 2>/dev/null`

	REL_FILES="${ROOTDIR}etc/lsb-release ${ROOTDIR}etc/debian_version ${ROOTDIR}etc/slackware-version ${ROOTDIR}var/ipcop/general-functions.pl ${ROOTDIR}etc/release ${ROOTDIR}etc/*-release"

	for FNAME in ${REL_FILES}; do
		if [ -f "${FNAME}" -a ! -h "${FNAME}" ]; then
			RELEASE=${FNAME}

			case "${RELEASE}" in
			${ROOTDIR}etc/lsb-release)
				OSNAME=`cat ${RELEASE} | grep '^DISTRIB_DESCRIPTION=' | sed -e 's/DISTRIB_DESCRIPTION=//' | tr -d '"'`
				;;
			${ROOTDIR}etc/SuSE-release)
				OSNAME=`grep -i 'SuSE Linux' ${RELEASE}`
				;;
			${ROOTDIR}etc/SLOX-release)
				OSNAME=`grep -i 'SuSE Linux' ${RELEASE}`
				;;
			${ROOTDIR}etc/gentoo-release)
				if [ -h ${ROOTDIR}etc/make.profile ]; then
					OSNAME="Gentoo `ls -l ${ROOTDIR}etc/make.profile 2>/dev/null | sed -e 's/^.*\/\([^\/]*\)$/\1/'`"
				else
					OSNAME=`head -n 1 ${RELEASE} | tr -s ' '`
				fi
				;;
			${ROOTDIR}var/ipcop/general-functions.pl)
				OSNAME=`grep 'version *=' ${RELEASE} | head -n 1`
				;;
			${ROOTDIR}etc/debian_version)
				OSNAME="Debian `cat ${RELEASE}`"
				;;
			*)
				OSNAME=`head -n 1 ${RELEASE} | tr -s ' '`
				;;
			esac

			test "${OSNAME}" = " " && OSNAME=""


			#
			# If we have a release file but the first line seems
			# to be blank, we take a quick look at the second
			# line.
			#

			if [ -z "${OSNAME}" -a `wc -l ${RELEASE} | awk '{ print $1 }'` -gt 1 ]; then
				OSNAME=`head -n 2 ${RELEASE} | tail -1 | tr -s ' '`
			fi

			test -n "${OSNAME}" && break
		fi
	done


	test -z "${OSNAME}" && RELEASE=""

	case "${OPERATING_SYSTEM}" in
	SunOS)
		ARCH=`uname -p`
		;;
	FreeBSD)
		ARCH=`sysctl -n hw.machine_arch 2>/dev/null`
		OSNAME=`uname -v | cut -d' ' -f1,2`
		;;
	OpenBSD)
		OSNAME="OpenBSD `uname -r`"
		;;
	Darwin)
		OSNAME=`sw_vers 2>/dev/null | grep 'ProductName' | sed -e 's/^ProductName: *//'`
		OSNAME="${OSNAME} `sysctl kern.version 2>/dev/null | sed -e 's/^kern.version = //' | cut -d: -f1`"
		;;
	AIX)
		ARCH=`uname -p`
		OSNAME="IBM AIX `oslevel`"
		;;
	esac

	return
}


get_hash_value() {

	#
	# This function simply runs the hash function command for the
	# given file. The environment variable HCMD must have been
	# previously set to the command to use.
	#

	HSHVAL=`${HCMD} $1 2>/dev/null`

	if [ "${OPERATING_SYSTEM}" = "OpenBSD" -a "${HCMD}" = "/bin/md5" ]; then
		echo ${HSHVAL} | cut -d' ' -f4 | tr -d ' '
	else
		echo ${HSHVAL} | cut -d' ' -f1
	fi

	return
}


rkh_dat_set_file_hash() {

	#
	# This function determines various bits of information about
	# the files to be checked. The format in the rkhunter.dat file is:
	#
	#     File:<pathname>:<hash value>:<inode>:<permissions>:<uid>:<gid>:
	#          <date/time modified>
	#

	#
	# To save time in the loops below, we determine the exact commands
	# required before entering them.
	#

	if [ -n "`echo ${STAT_CMD} | grep '\.pl$'`" ]; then
		SCMD="${STAT_CMD} --modeoct --raw --mode --ino -uid -gid -Mtime"
	else
		if [ "${OPERATING_SYSTEM}" = "NetBSD" ]; then
			SCMD="${STAT_CMD} -f '%i %Mp%Lp %u %g %m:'"
		else
			SCMD="${STAT_CMD} --format='%i 0%a %u %g %Y:'"
		fi
	fi

	if [ $PRELINKED -eq 0 ]; then
		HCMD=${HASH_FUNC}
	else
		if [ -n "`echo ${HASH_FUNC} | grep 'md5'`" ]; then
			HCMD="${PRELINK_CMD} --verify --md5"
		else
			HCMD="${PRELINK_CMD} --verify --sha"
		fi
	fi


	#
	# Now loop through the directories looking for the files.
	#

# jh - set counters in this loop to record how many hashes out of how many were added.
	for DIR in ${HASHDIRS}; do
		test ! -d ${DIR} && continue

		for FNAME in ${HASHFILES}; do
			test ! -f ${DIR}/${FNAME} && continue

			SYSHASH=`get_hash_value "${DIR}/${FNAME}"`

			FDATA=`eval ${SCMD} ${DIR}/${FNAME} 2>/dev/null | tr ' ' ':'`

			echo "File:${DIR}/${FNAME}:${SYSHASH}:${FDATA}" >>${RKHDAT_FILE}
		done
	done

	return
}


do_hash_update() {

	#
	# This function updates the local hosts rkhunter.dat file
	# with O/S information and file hash values.
	#

	#
	# If the rkhunter.dat file is a link then we alert the user.
	# This is a security problem, because we are about to
	# write a lot of data to the file.
	#

	if [ -h "${DB_PATH}/rkhunter.dat" ]; then
		echo "The rkhunter.dat file is a symbolic link: ${DB_PATH}/rkhunter.dat"
		echo "This is a security problem. The link points to another file, and that file is about to be modified by rkhunter."

		RET_CODE=1
		return
	fi


	#
	# We must have access to either the 'stat' command, or the
	# supplied perl script. If neither can be found then we
	# must exit.
	#

	if [ -z "${STAT_CMD}" ]; then
		echo "No 'stat' command can be found to perform the update."

		RET_CODE=1
		return
	fi


	#
	# We need now to create a unique temporary file to store
	# the new data. We either use mktemp if it is available,
	# or simply use the RANDOM environment variable.
	#

	MKTEMP_CMD=`find_cmd mktemp`

	if [ -n "${MKTEMP_CMD}" ]; then
		RKHDAT_FILE=`${MKTEMP_CMD} ${TMPDIR}/rkhunter.dat.XXXXXX`

		logtext "Info: Found 'mktemp' command: ${MKTEMP_CMD}"
	else
		RKHDAT_FILE="${TMPDIR}/rkhunter.dat.$RANDOM"
		rm -f ${RKHDAT_FILE} >/dev/null 2>&1

		logtext "Info: Unable to find 'mktemp' command: using random number instead"
	fi

	logtext "Info: Created temporary file ${RKHDAT_FILE}"


	#
	# We now start to write out information about this system
	# to the file. Some information we already have available,
	# but for others we call functions to obtain what is wanted.
	#

	ARCH=""
	OSNAME=""
	RELEASE=""

	rkh_dat_set_version

	rkh_dat_get_os_info

	echo "Host:${HOST_NAME}" >>${RKHDAT_FILE}

	test -n "${ARCH}" && echo "Arch:${ARCH}" >>${RKHDAT_FILE}

	if [ -n "${RELEASE}" ]; then
		logtext "Info: Found release file: ${RELEASE}"
	else
		logtext "Info: Unable to find a release file: LS output shows:"
		logtext --indent "`ls -d /etc/*release* /etc/*version* 2>/dev/null`"
	fi

	if [ -n "${OSNAME}" ]; then
		echo "OS:${OSNAME}" >>${RKHDAT_FILE}
		logtext "Info: Found O/S name: ${OSNAME}"
	fi

	if [ $PRELINKED -eq 0 ]; then
		echo "Prelinked:No" >>${RKHDAT_FILE}
	else
		echo "Prelinked:Yes" >>${RKHDAT_FILE}
	fi

	logtext "Info: O/S info obtained"


	rkh_dat_set_file_hash

	logtext "Info: File hashes obtained"


	#
	# Now put the new rkhunter.dat file in place.
	#

	cp -f ${DB_PATH}/rkhunter.dat ${DB_PATH}/rkhunter.dat.old >/dev/null 2>&1
	cp ${RKHDAT_FILE} ${DB_PATH}/rkhunter.dat >/dev/null 2>&1
	rm -f ${RKHDAT_FILE} >/dev/null 2>&1

	logtext "Info: New rkhunter.dat file put in place"

	return
}


do_update() {

	#
	# This function checks to see if any of the supplied RKH
	# *.dat files needs updating. If it does, then the new file
	# is downloaded.
	#

# jh - put this script in-line?
	${SCRIPT_PATH}/check_update.sh ${CONFIGFILE} "${DB_PATH}/mirrors.dat" ${DB_PATH} ${LOGFILE}
	RET_CODE=$?

	return
}


do_versioncheck() {

# jh - go through this function. Sort out messages; forcing update; use of quiet option; add logtext msgs, etc.
	#
	# This function performs a program version check.
	#

	LATESTVERSION="unknown"

	if [ -f ${TMPDIR}/rkhunter.upd ]; then
		rm -f ${TMPDIR}/rkhunter.upd >/dev/null 2>&1
	fi

	URLPREFIX=`grep -v 'version=' ${DB_PATH}/mirrors.dat | head -n 1 | cut -d '=' -f2`

	VERSIONUPDATEURL=`grep 'LATESTVERSION=' ${CONFIGFILE} | sed -e 's/LATESTVERSION=//g'`

# jh - put check in here to use wget, lynx, links, elinks, curl, GET.
	if [ -n "${WGET_CMD}" ]; then
		${WGET_CMD} -q -O ${TMPDIR}/rkhunter.upd ${URLPREFIX}${VERSIONUPDATEURL}
		displaytext "${URLPREFIX}${VERSIONUPDATEURL}"
		LATESTVERSION=`cat ${TMPDIR}/rkhunter.upd`
	fi

	if [ $QUIET -eq 0 ]; then
		displaytext ""
		displaytext "${PROGRAM_NAME} ${PROGRAM_version}, copyright ${PROGRAM_copyright_owner}"
		displaytext ""
		displaytext "This version:   ${PROGRAM_version}"
		displaytext "Latest version: ${LATESTVERSION}"
	fi

	if [ -z "${LATESTVERSION}" ]; then
		echo "Unable to fetch latest rkhunter version number from mirror."
		echo "${WHITE}Please check manually for updates${NORMAL}"
	else
		PROG_VERS=`echo "${PROGRAM_version}" | cut -d. -f1-3 | sed -e 's/\.\([0-9]\)\./.0\1./' | sed -e 's/\.\([0-9]\)$/.0\1/' | sed -e 's/\.//g'`
		LATEST_VERS=`echo "${LATESTVERSION}" | cut -d. -f1-3 | sed -e 's/\.\([0-9]\)\./.0\1./' | sed -e 's/\.\([0-9]\)$/.0\1/' | sed -e 's/\.//g'`

		if [ ${PROG_VERS} -lt ${LATEST_VERS} ]; then
			echo "${WHITE}Update available${NORMAL}"
		fi
	fi

	if [ $QUIET -eq 0 ]; then
		displaytext ""; displaytext ""; displaytext "";
	fi

	return
}


do_system_check_initialisation() {

	#
	# This function simply initialises the default rootkit
	# files and directories.
	#


	# 55808 Variant A
	W55808A_FILES="${ROOTDIR}tmp/.../r ${ROOTDIR}tmp/.../a"


	# AjaKit
	AJAKIT_FILES="${ROOTDIR}dev/tux/.addr ${ROOTDIR}dev/tux/.proc
		      ${ROOTDIR}dev/tux/.file ${ROOTDIR}lib/.libgh-gh/cleaner
		      ${ROOTDIR}lib/.libgh-gh/Patch/patch
		      ${ROOTDIR}lib/.libgh-gh/sb0k"
	AJAKIT_DIRS="${ROOTDIR}dev/tux ${ROOTDIR}lib/.libgh-gh"
	AJAKIT_KSYMS=""


	# aPa Kit
	APAKIT_FILES="${ROOTDIR}usr/share/.aPa"
	APAKIT_DIRS=""
	APAKIT_KSYMS=""


	# Apache Worm
	APACHEWORM_FILES="${ROOTDIR}bin/.log"


	# Ambient (ark) Rootkit
	ARK_FILES="${ROOTDIR}usr/lib/.ark? ${ROOTDIR}dev/ptyxx/.log
		   ${ROOTDIR}dev/ptyxx/.file"
	ARK_DIRS="${ROOTDIR}dev/ptyxx"


	# Balaur Rootkit 2.0 (LRK5 based)
	BALAUR_FILES="${ROOTDIR}usr/lib/liblog.o"
	BALAUR_DIRS="${ROOTDIR}usr/lib/.kinetic ${ROOTDIR}usr/lib/.egcs
		     ${ROOTDIR}usr/lib/.wormie"
	BALAUR_KSYMS=""


	# Beastkit
	BEASTKIT_FILES="${ROOTDIR}usr/sbin/arobia ${ROOTDIR}usr/sbin/idrun
			${ROOTDIR}usr/lib/elm/arobia/elm
			${ROOTDIR}usr/lib/elm/arobia/elm/hk
			${ROOTDIR}usr/lib/elm/arobia/elm/hk.pub
			${ROOTDIR}usr/lib/elm/arobia/elm/sc
			${ROOTDIR}usr/lib/elm/arobia/elm/sd.pp
			${ROOTDIR}usr/lib/elm/arobia/elm/sdco
			${ROOTDIR}usr/lib/elm/arobia/elm/srsd"
	BEASTKIT_DIRS="${ROOTDIR}lib/ldd.so/bktools"


	# beX2
	BEX_FILES=""
	BEX_DIRS="${ROOTDIR}/usr/include/bex"
	BEX_KSYMS=""


	# BOBkit
	BOBKIT_FILES="${ROOTDIR}usr/sbin/ntpsx ${ROOTDIR}usr/lib/.../ls
		      ${ROOTDIR}usr/lib/.../netstat ${ROOTDIR}usr/lib/.../lsof
		      ${ROOTDIR}usr/lib/.../bkit-ssh/bkit-shdcfg
		      ${ROOTDIR}usr/lib/.../bkit-ssh/bkit-shhk
		      ${ROOTDIR}usr/lib/.../bkit-ssh/bkit-pw
		      ${ROOTDIR}usr/lib/.../bkit-ssh/bkit-shrs
		      ${ROOTDIR}usr/lib/.../uconf.inv ${ROOTDIR}usr/lib/.../psr
		      ${ROOTDIR}usr/lib/.../find ${ROOTDIR}usr/lib/.../pstree
		      ${ROOTDIR}usr/lib/.../slocate ${ROOTDIR}usr/lib/.../du
		      ${ROOTDIR}usr/lib/.../top"
	BOBKIT_DIRS="${ROOTDIR}usr/lib/... ${ROOTDIR}usr/lib/.../bkit-ssh
		     ${ROOTDIR}usr/lib/.bkit- ${ROOTDIR}tmp/.bkp"


	# CiNIK Worm (Slapper.B variant)
	CINIK_DIRS="${ROOTDIR}tmp/.font-unix/.cinik"
	CINIK_FILES="${ROOTDIR}tmp/.cinik"


	# Danny-Boy's Abuse Kit
	DANNYBOY_FILES="${ROOTDIR}dev/mdev ${ROOTDIR}usr/lib/libX.a"
	DANNYBOY_DIRS=""
	DANNYBOY_KSYMS=""


	# Devil
	DEVIL_FILES="${ROOTDIR}var/lib/games/.src ${ROOTDIR}dev/dsx
		     ${ROOTDIR}dev/caca"


	# Dica (T0rn variant)
	DICA_FILES="${ROOTDIR}lib/.sso ${ROOTDIR}lib/.so
		    ${ROOTDIR}var/run/...dica/clean
		    ${ROOTDIR}var/run/...dica/xl ${ROOTDIR}var/run/...dica/xdr
		    ${ROOTDIR}var/run/...dica/psg
		    ${ROOTDIR}var/run/...dica/secure
		    ${ROOTDIR}var/run/...dica/rdx ${ROOTDIR}var/run/...dica/va
		    ${ROOTDIR}var/run/...dica/cl.sh ${ROOTDIR}usr/bin/.etc"
	DICA_DIRS="${ROOTDIR}var/run/...dica ${ROOTDIR}var/run/...dica/mh
		   ${ROOTDIR}var/run/...dica/scan"
	DICA_KSYMS=""


	# Dreams
	DREAMS_FILES="${ROOTDIR}dev/ttyoa ${ROOTDIR}dev/ttyof
		      ${ROOTDIR}dev/ttyop ${ROOTDIR}usr/bin/sense
		      ${ROOTDIR}usr/bin/sl2 ${ROOTDIR}usr/bin/logclear
		      ${ROOTDIR}usr/bin/(swapd) ${ROOTDIR}usr/bin/snfs
		      ${ROOTDIR}usr/lib/libsss"
	DREAMS_DIRS="${ROOTDIR}dev/ida/.hpd"
	DREAMS_KSYMS=""


	# Duarawkz
	DUARAWKZ_FILES="${ROOTDIR}usr/bin/duarawkz/loginpass"
	DUARAWKZ_DIRS="${ROOTDIR}usr/bin/duarawkz"
	DUARAWKZ_KSYMS=""

	# ENYELKM v1.1
	# Installer default.
	ENYELKM_FILES="${ROOTDIR}etc/.enyelkmHIDE^IT.ko"
	ENYELKM_DIRS=""
	ENYELKM_KSYMS=""

	# Flea Linux rootkit
	FLEA_FILES="${ROOTDIR}etc/ld.so.hash
		    ${ROOTDIR}lib/security/.config/ssh/ssh_host_key
		    ${ROOTDIR}lib/security/.config/ssh/ssh_host_key.pub
		    ${ROOTDIR}lib/security/.config/ssh/ssh_random_seed
		    ${ROOTDIR}usr/bin/ssh2d ${ROOTDIR}usr/lib/ldlibns.so
		    ${ROOTDIR}usr/lib/ldlibpst.so ${ROOTDIR}usr/lib/ldlibdu.so
		    ${ROOTDIR}usr/lib/ldlibct.so"
	FLEA_DIRS="${ROOTDIR}lib/security/.config/ssh ${ROOTDIR}dev/..0
		   ${ROOTDIR}dev/..0/backup"
	FLEA_KSYMS=""


	# FreeBSD Rootkit
	FREEBSD_RK_FILES="${ROOTDIR}usr/lib/.fx/sched_host.2
			  ${ROOTDIR}usr/lib/.fx/random_d.2
			  ${ROOTDIR}usr/lib/.fx/set_pid.2
			  ${ROOTDIR}usr/lib/.fx/cons.saver
			  ${ROOTDIR}usr/lib/.fx/adore/adore/adore.ko
			  ${ROOTDIR}bin/sysback
			  ${ROOTDIR}usr/local/bin/sysback"
	FREEBSD_RK_DIRS="${ROOTDIR}usr/lib/.fx ${ROOTDIR}usr/lib/.fx/adore"


	# Fuckit Rootkit
	FUCKIT_FILES="${ROOTDIR}dev/proc/fuckit/hax0r
		      ${ROOTDIR}dev/proc/fuckit/hax0rshell
		      ${ROOTDIR}dev/proc/fuckit/config/lports
		      ${ROOTDIR}dev/proc/fuckit/config/rports
		      ${ROOTDIR}dev/proc/fuckit/config/rkconf
		      ${ROOTDIR}dev/proc/fuckit/config/password
		      ${ROOTDIR}dev/proc/fuckit/config/progs
		      ${ROOTDIR}dev/proc/system-bins/init"


	# GasKit Rootkit
	GASKIT_FILES="${ROOTDIR}dev/dev/gaskit/sshd/sshdd"
	GASKIT_DIRS="${ROOTDIR}dev/dev ${ROOTDIR}dev/dev/gaskit
		     ${ROOTDIR}dev/dev/gaskit/sshd"


	# Heroin LKM
	HEROIN_FILES=""
	HEROIN_DIRS=""
	HEROIN_KSYMS="heroin"


	# HjC Kit
	HJCKIT_FILES=""
	HJCKIT_DIRS="${ROOTDIR}dev/.hijackerz"
	HJCKIT_KSYMS=""


	# ignoKit
	IGNOKIT_FILES="${ROOTDIR}lib/defs/p ${ROOTDIR}lib/defs/q
		       ${ROOTDIR}lib/defs/r ${ROOTDIR}lib/defs/s
		       ${ROOTDIR}lib/defs/t ${ROOTDIR}usr/lib/defs/p
		       ${ROOTDIR}usr/lib/defs/q ${ROOTDIR}usr/lib/defs/r
		       ${ROOTDIR}usr/lib/defs/s ${ROOTDIR}usr/lib/defs/t
		       ${ROOTDIR}usr/lib/.libigno/pkunsec
		       ${ROOTDIR}usr/lib/.libigno/.igno/psybnc/psybnc"
	IGNOKIT_DIRS="${ROOTDIR}usr/lib/.libigno
		      ${ROOTDIR}usr/lib/.libigno/.igno/"
	IGNOKIT_KSYMS=""


	# ImperalsS-FBRK (FreeBSD Rootkit)
	IMPFRB_DIRS="${ROOTDIR}dev/fd/.88 ${ROOTDIR}dev/fd/.99"


	# Irix Rootkit (for Irix 6.x)
	IRIXRK_FILES=""
	IRIXRK_DIRS="${ROOTDIR}dev/pts/01 ${ROOTDIR}dev/pts/01/backup
		     ${ROOTDIR}dev/pts/01/etc ${ROOTDIR}dev/pts/01/tmp"
	IRIXRK_KSYMS=""


	# Kitko
	KITKO_FILES=""
	KITKO_DIRS="${ROOTDIR}usr/src/redhat/SRPMS/..."
	KITKO_KSYMS=""


	# Knark
	KNARK_FILES="${ROOTDIR}proc/knark/pids"
	KNARK_DIRS="${ROOTDIR}proc/knark"
	KNARK_KSYMS=""


	# Lion Worm
	LION_FILES="${ROOTDIR}bin/in.telnetd ${ROOTDIR}bin/mjy
		    ${ROOTDIR}usr/man/man1/man1/lib/.lib/mjy
		    ${ROOTDIR}usr/man/man1/man1/lib/.lib/in.telnetd
		    ${ROOTDIR}usr/man/man1/man1/lib/.lib/.x
		    ${ROOTDIR}dev/.lib/lib/scan/1i0n.sh
		    ${ROOTDIR}dev/.lib/lib/scan/hack.sh
		    ${ROOTDIR}dev/.lib/lib/scan/bind
		    ${ROOTDIR}dev/.lib/lib/scan/randb
		    ${ROOTDIR}dev/.lib/lib/scan/scan.sh
		    ${ROOTDIR}dev/.lib/lib/scan/pscan
		    ${ROOTDIR}dev/.lib/lib/scan/star.sh
		    ${ROOTDIR}dev/.lib/lib/scan/bindx.sh
		    ${ROOTDIR}dev/.lib/lib/scan/bindname.log
		    ${ROOTDIR}dev/.lib/lib/1i0n.sh
		    ${ROOTDIR}dev/.lib/lib/lib/netstat
		    ${ROOTDIR}dev/.lib/lib/lib/dev/.1addr
		    ${ROOTDIR}dev/.lib/lib/lib/dev/.1logz
		    ${ROOTDIR}dev/.lib/lib/lib/dev/.1proc
		    ${ROOTDIR}dev/.lib/lib/lib/dev/.1file"


	# Lockit (a.k.a. LJK2)
	LOCKIT_FILES="${ROOTDIR}usr/lib/libmen.oo/.LJK2/ssh_config
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/ssh_host_key
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/ssh_host_key.pub
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/ssh_random_seed*
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/sshd_config
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/backdoor/RK1bd
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/backup/du
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/backup/ifconfig
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/backup/inetd.conf
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/backup/locate
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/backup/login
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/backup/ls
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/backup/netstat
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/backup/ps
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/backup/pstree
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/backup/rc.sysinit
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/backup/syslogd
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/backup/tcpd
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/backup/top
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/clean/RK1sauber
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/clean/RK1wted
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/hack/RK1parser
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/hack/RK1sniff
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/hide/.RK1addr
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/hide/.RK1dir
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/hide/.RK1log
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/hide/.RK1proc
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/hide/RK1phidemod.c
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/modules/README.modules
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/modules/RK1hidem.c
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/modules/RK1phide
		      ${ROOTDIR}usr/lib/libmen.oo/.LJK2/sshconfig/RK1ssh"
	LOCKIT_DIRS="${ROOTDIR}usr/lib/libmen.oo/.LJK2"
	LOCKIT_KSYMS=""


	# MRK (MiCrobul RootKit?, based on Devil RootKit )
	MRK_FILES="${ROOTDIR}dev/ida/.inet/pid
		   ${ROOTDIR}dev/ida/.inet/ssh_host_key
		   ${ROOTDIR}dev/ida/.inet/ssh_random_seed
		   ${ROOTDIR}dev/ida/.inet/tcp.log"
	MRK_DIRS="${ROOTDIR}dev/ida/.inet ${ROOTDIR}var/spool/cron/.sh"

	# Mood-NT
	# Binary is by default called "mood-nt" but can be anywhere.
	# Here we look for collaterals, from include/prefs.h defaults
	# until sig-based dirscan() is added.
	MOODNT_FILES="${ROOTDIR}sbin/init__mood-nt-_-_cthulhu
			${ROOTDIR}_cthulhu/mood-nt.init
			${ROOTDIR}_cthulhu/mood-nt.conf
			${ROOTDIR}_cthulhu/mood-nt.sniff"
	MOODNT_DIRS="${ROOTDIR}_cthulhu"
	MOODNT_KSYMS=""

	# Ni0 Rootkit
	NIO_FILES="${ROOTDIR}var/lock/subsys/...datafile.../...net...
		   ${ROOTDIR}var/lock/subsys/...datafile.../...port...
		   ${ROOTDIR}var/lock/subsys/...datafile.../...ps...
		   ${ROOTDIR}var/lock/subsys/...datafile.../...file..."
	NIO_DIRS="${ROOTDIR}tmp/waza ${ROOTDIR}var/lock/subsys/...datafile...
		  ${ROOTDIR}usr/sbin/es"
	NIO_KSYMS=""


	# RootKit for SunOS / NSDAP
	NSDAP_FILES="${ROOTDIR}usr/lib/vold/nsdap/.kit
		     ${ROOTDIR}usr/lib/vold/nsdap/defines
		     ${ROOTDIR}usr/lib/vold/nsdap/patcher
		     ${ROOTDIR}usr/lib/vold/nsdap/pg
		     ${ROOTDIR}usr/lib/vold/nsdap/cleaner
		     ${ROOTDIR}usr/lib/vold/nsdap/utime
		     ${ROOTDIR}usr/lib/vold/nsdap/crypt
		     ${ROOTDIR}usr/lib/vold/nsdap/findkit
		     ${ROOTDIR}usr/lib/vold/nsdap/sn2
		     ${ROOTDIR}usr/lib/vold/nsdap/sniffload
		     ${ROOTDIR}usr/lib/vold/nsdap/runsniff
		     ${ROOTDIR}usr/lib/lpset"
	NSDAP_DIRS="${ROOTDIR}usr/lib/vold/nsdap"
	NSDAP_KSYMS=""


	# Ohhara Rootkit
	OHHARA_FILES="${ROOTDIR}var/lock/subsys/...datafile.../...datafile.../in.smbd.log"
	OHHARA_DIRS="${ROOTDIR}var/lock/subsys/...datafile...
		     ${ROOTDIR}var/lock/subsys/...datafile.../...datafile...
		     ${ROOTDIR}var/lock/subsys/...datafile.../...datafile.../bin
		     ${ROOTDIR}var/lock/subsys/...datafile.../...datafile.../usr/bin
		     ${ROOTDIR}var/lock/subsys/...datafile.../...datafile.../usr/sbin
		     ${ROOTDIR}var/lock/subsys/...datafile.../...datafile.../lib/security"


	# Optic Kit (Tux variant)
	OPTICKIT_DIRS="${ROOTDIR}dev/tux ${ROOTDIR}usr/bin/xchk
		       ${ROOTDIR}usr/bin/xsf ${ROOTDIR}usr/bin/ssh2d"


	# Oz Rootkit
	OZ_FILES="${ROOTDIR}dev/.oz/.nap/rkit/terror"
	OZ_DIRS="${ROOTDIR}dev/.oz"


	# PHALANX
	PHALANX_FILES="${ROOTDIR}usr/share/.home.ph1/cb
			${ROOTDIR}etc/host.ph1
			${ROOTDIR}bin/host.ph1
			${ROOTDIR}usr/share/.home.ph1/phalanx"
	PHALANX_DIRS="${ROOTDIR}usr/share/.home.ph1"
	PHALANX_KSYMS=""

	# Portacelo
	PORTACELO_FILES="${ROOTDIR}var/lib/.../.ak ${ROOTDIR}var/lib/.../.hk
			 ${ROOTDIR}var/lib/.../.rs ${ROOTDIR}var/lib/.../.p
			 ${ROOTDIR}var/lib/.../getty
			 ${ROOTDIR}var/lib/.../lkt.o ${ROOTDIR}var/lib/.../show
			 ${ROOTDIR}var/lib/.../nlkt.o
			 ${ROOTDIR}var/lib/.../ssshrc
			 ${ROOTDIR}var/lib/.../sssh_equiv
			 ${ROOTDIR}var/lib/.../sssh_known_hosts
			 ${ROOTDIR}var/lib/.../sssh_pid ~/.sssh/known_hosts"


	# R3dstorm Toolkit
	REDSTORM_FILES="${ROOTDIR}var/log/tk02/see_all
			${ROOTDIR}bin/.../sshd/sbin/sshd1
			${ROOTDIR}bin/.../hate/sk
			${ROOTDIR}bin/.../see_all"
	REDSTORM_DIRS="${ROOTDIR}var/log/tk02 ${ROOTDIR}var/log/tk02/old
		       ${ROOTDIR}bin/..."
	REDSTORM_KSYMS=""


	# RH-Sharpe's rootkit
	RHSHARPES_FILES="${ROOTDIR}bin/lps ${ROOTDIR}usr/bin/lpstree
			 ${ROOTDIR}usr/bin/ltop ${ROOTDIR}usr/bin/lkillall
			 ${ROOTDIR}usr/bin/ldu ${ROOTDIR}usr/bin/lnetstat
			 ${ROOTDIR}usr/bin/wp ${ROOTDIR}usr/bin/shad
			 ${ROOTDIR}usr/bin/vadim ${ROOTDIR}usr/bin/slice
			 ${ROOTDIR}usr/bin/cleaner
			 ${ROOTDIR}usr/include/rpcsvc/du"
	RHSHARPES_DIRS=""
	RHSHARPES_KSYMS=""


	# RSHA's rootkit
	RSHA_FILES="${ROOTDIR}bin/kr4p ${ROOTDIR}usr/bin/n3tstat
		    ${ROOTDIR}usr/bin/chsh2 ${ROOTDIR}usr/bin/slice2
		    ${ROOTDIR}usr/src/linux/arch/alpha/lib/.lib/.1proc
		    ${ROOTDIR}etc/rc.d/arch/alpha/lib/.lib/.1addr"
	RSHA_DIRS="${ROOTDIR}etc/rc.d/rsha
		   ${ROOTDIR}etc/rc.d/arch/alpha/lib/.lib"
	RSHA_KSYMS=""


	# Shutdown
	SHUTDOWN_FILES="${ROOTDIR}usr/man/man5/..%%/.dir/scannah/asus
			${ROOTDIR}usr/man/man5/..%%/.dir/see
			${ROOTDIR}usr/man/man5/..%%/.dir/nscd
			${ROOTDIR}usr/man/man5/..%%/.dir/alpd
			${ROOTDIR}etc/rc.d/rc.local%%"
	SHUTDOWN_DIRS="${ROOTDIR}usr/man/man5/..%%/.dir/
		       ${ROOTDIR}usr/man/man5/..%%/.dir/scannah
		       ${ROOTDIR}etc/rc.d/rc0.d/..%%/.dir"


	# Scalper (FreeBSD.Scalper.Worm)
	SCALPER_FILES="${ROOTDIR}tmp/.a ${ROOTDIR}tmp/.uua"


	# SHV4
	SHV4_FILES="${ROOTDIR}etc/ld.so.hash ${ROOTDIR}lib/libext-2.so.7
		    ${ROOTDIR}lib/lidps1.so ${ROOTDIR}usr/sbin/xntps"
	SHV4_DIRS="${ROOTDIR}lib/security/.config
		   ${ROOTDIR}lib/security/.config/ssh"


	# SHV5
	SHV5_FILES="${ROOTDIR}etc/sh.conf ${ROOTDIR}dev/srd0"
	SHV5_DIRS="/usr/lib/libsh"
	SHV5_KSYMS=""


	# Sin Rootkit
	SINROOTKIT_FILES="${ROOTDIR}dev/.haos/haos1/.f/Denyed
			  ${ROOTDIR}dev/ttyoa ${ROOTDIR}dev/ttyof
			  ${ROOTDIR}dev/ttyop ${ROOTDIR}dev/ttyos
			  ${ROOTDIR}usr/lib/.lib ${ROOTDIR}usr/lib/sn/.X
			  ${ROOTDIR}usr/lib/sn/.sys ${ROOTDIR}usr/lib/ld/.X
			  ${ROOTDIR}usr/man/man1/...
			  ${ROOTDIR}usr/man/man1/.../.m
			  ${ROOTDIR}usr/man/man1/.../.w"
	SINROOTKIT_DIRS="${ROOTDIR}usr/lib/sn ${ROOTDIR}usr/lib/man1/...
			 ${ROOTDIR}dev/.haos"


	# Slapper
	SLAPPER_FILES="${ROOTDIR}tmp/.bugtraq ${ROOTDIR}tmp/.uubugtraq
		       ${ROOTDIR}tmp/.bugtraq.c ${ROOTDIR}tmp/httpd
		       ${ROOTDIR}tmp/.unlock ${ROOTDIR}tmp/update
		       ${ROOTDIR}tmp/.cinik ${ROOTDIR}tmp/.b"


	# Sneakin Rootkit
	SNEAKIN_DIRS="${ROOTDIR}tmp/.X11-unix/.../rk"


	# Suckit Rootkit
	SUCKIT_FILES="${ROOTDIR}sbin/initsk12 ${ROOTDIR}sbin/initxrk
		      ${ROOTDIR}usr/bin/null
		      ${ROOTDIR}usr/share/locale/sk/.sk12/sk
		      ${ROOTDIR}etc/rc.d/rc0.d/S23kmdac
		      ${ROOTDIR}etc/rc.d/rc1.d/S23kmdac
		      ${ROOTDIR}etc/rc.d/rc2.d/S23kmdac
		      ${ROOTDIR}etc/rc.d/rc3.d/S23kmdac
		      ${ROOTDIR}etc/rc.d/rc4.d/S23kmdac
		      ${ROOTDIR}etc/rc.d/rc5.d/S23kmdac
		      ${ROOTDIR}etc/rc.d/rc6.d/S23kmdac"
	SUCKIT_DIRS="${ROOTDIR}dev/sdhu0/tehdrakg ${ROOTDIR}etc/.MG
		     ${ROOTDIR}usr/share/locale/sk/.sk12
		     ${ROOTDIR}usr/lib/perl5/site_perl/i386-linux/auto/TimeDate/.packlist"


	# SunOS Rootkit
	SUNOSROOTKIT_FILES="${ROOTDIR}etc/ld.so.hash
			    ${ROOTDIR}lib/libext-2.so.7 ${ROOTDIR}usr/bin/ssh2d
			    ${ROOTDIR}bin/xlogin ${ROOTDIR}usr/lib/crth.o
			    ${ROOTDIR}usr/lib/crtz.o ${ROOTDIR}sbin/login
			    ${ROOTDIR}lib/security/.config/sn
			    ${ROOTDIR}lib/security/.config/lpsched
			    ${ROOTDIR}dev/kmod ${ROOTDIR}dev/dos"


	# Superkit
	SUPERKIT_FILES="${ROOTDIR}usr/man/.sman/sk"
	SUPERKIT_DIRS=""
	SUPERKIT_KSYMS=""


	# Telnet Backdoor
	TBD_FILES="${ROOTDIR}usr/lib/.tbd"


	# TeLeKiT
	TELEKIT_FILES="${ROOTDIR}usr/man/man3/.../TeLeKiT/bin/sniff
		       ${ROOTDIR}usr/man/man3/.../TeLeKiT/bin/telnetd
		       ${ROOTDIR}usr/man/man3/.../TeLeKiT/bin/teleulo
		       ${ROOTDIR}usr/man/man3/.../cl ${ROOTDIR}dev/ptyr
		       ${ROOTDIR}dev/ptyp ${ROOTDIR}dev/ptyq
		       ${ROOTDIR}dev/hda06 ${ROOTDIR}usr/info/libc1.so"
	TELEKIT_DIRS="${ROOTDIR}usr/man/man3/...
		      ${ROOTDIR}usr/man/man3/.../lsniff
		      ${ROOTDIR}usr/man/man3/.../TeLeKiT"
	TELEKIT_KSYMS=""


	# Torn (and misc)
	TORN_FILES="${ROOTDIR}dev/.lib/lib/lib/t0rns
		    ${ROOTDIR}dev/.lib/lib/lib/du
		    ${ROOTDIR}dev/.lib/lib/lib/ls
		    ${ROOTDIR}dev/.lib/lib/lib/t0rnsb
		    ${ROOTDIR}dev/.lib/lib/lib/ps
		    ${ROOTDIR}dev/.lib/lib/lib/t0rnp
		    ${ROOTDIR}dev/.lib/lib/lib/find
		    ${ROOTDIR}dev/.lib/lib/lib/ifconfig
		    ${ROOTDIR}dev/.lib/lib/lib/pg
		    ${ROOTDIR}dev/.lib/lib/lib/ssh.tgz
		    ${ROOTDIR}dev/.lib/lib/lib/top
		    ${ROOTDIR}dev/.lib/lib/lib/sz
		    ${ROOTDIR}dev/.lib/lib/lib/login
		    ${ROOTDIR}dev/.lib/lib/lib/in.fingerd
		    ${ROOTDIR}dev/.lib/lib/lib/1i0n.sh
		    ${ROOTDIR}dev/.lib/lib/lib/pstree
		    ${ROOTDIR}dev/.lib/lib/lib/in.telnetd
		    ${ROOTDIR}dev/.lib/lib/lib/mjy
		    ${ROOTDIR}dev/.lib/lib/lib/sush
		    ${ROOTDIR}dev/.lib/lib/lib/tfn
		    ${ROOTDIR}dev/.lib/lib/lib/name
		    ${ROOTDIR}dev/.lib/lib/lib/getip.sh
		    ${ROOTDIR}usr/info/.torn/sh*
		    ${ROOTDIR}usr/src/.puta/
		    ${ROOTDIR}usr/src/.puta/.1addr
		    ${ROOTDIR}usr/src/.puta/.1file
		    ${ROOTDIR}usr/src/.puta/.1proc
		    ${ROOTDIR}usr/src/.puta/.1logz
		    ${ROOTDIR}usr/info/.t0rn/"
	TORN_DIRS="${ROOTDIR}dev/.lib/ ${ROOTDIR}dev/.lib/lib/
		   ${ROOTDIR}dev/.lib/lib/lib/ ${ROOTDIR}dev/.lib/lib/lib/dev/
		   ${ROOTDIR}dev/.lib/lib/scan/ ${ROOTDIR}usr/src/.puta/
		   ${ROOTDIR}usr/man/man1/man1/
		   ${ROOTDIR}usr/man/man1/man1/lib/
		   ${ROOTDIR}usr/man/man1/man1/lib/.lib/
		   ${ROOTDIR}usr/man/man1/man1/lib/.lib/.backup/"


	# Trojanit Kit
	TROJANIT_FILES="${ROOTDIR}bin/.ls ${ROOTDIR}bin/.ps
			${ROOTDIR}bin/.netstat ${ROOTDIR}usr/bin/.nop
			${ROOTDIR}usr/bin/.who"


	# Tuxtendo (Tuxkit)
	TUXTENDO_FILES="${ROOTDIR}dev/tux/.addr
			${ROOTDIR}dev/tux/.cron
			${ROOTDIR}dev/tux/.file
			${ROOTDIR}dev/tux/.log
			${ROOTDIR}dev/tux/.proc
			${ROOTDIR}dev/tux/backup/crontab
			${ROOTDIR}dev/tux/backup/df
			${ROOTDIR}dev/tux/backup/dir
			${ROOTDIR}dev/tux/backup/find
			${ROOTDIR}dev/tux/backup/ifconfig
			${ROOTDIR}dev/tux/backup/locate
			${ROOTDIR}dev/tux/backup/netstat
			${ROOTDIR}dev/tux/backup/ps
			${ROOTDIR}dev/tux/backup/pstree
			${ROOTDIR}dev/tux/backup/syslogd
			${ROOTDIR}dev/tux/backup/tcpd
			${ROOTDIR}dev/tux/backup/top
			${ROOTDIR}dev/tux/backup/updatedb
			${ROOTDIR}dev/tux/backup/vdir"
	TUXTENDO_DIRS="${ROOTDIR}dev/tux ${ROOTDIR}dev/tux/ssh2
		       ${ROOTDIR}dev/tux/backup"
	TUXTENDO_KSYMS=""


	# URK (Universal Root Kit)
	URK_FILES="${ROOTDIR}usr/man/man1/xxxxxxbin/find
		   ${ROOTDIR}usr/man/man1/xxxxxxbin/du
		   ${ROOTDIR}usr/man/man1/xxxxxxbin/ps
		   ${ROOTDIR}tmp/conf.inf"
	URK_DIRS="${ROOTDIR}usr/man/man1/xxxxxxbin"


	# VcKit
	VCKIT_FILES=""
	VCKIT_DIRS="${ROOTDIR}usr/include/linux/modules/lib.so
		    ${ROOTDIR}usr/include/linux/modules/lib.so/bin"


	# Volc Rootkit
	VOLC_FILES=""
	VOLC_DIRS="${ROOTDIR}var/spool/.recent
		   ${ROOTDIR}var/spool/.recent/.files
		   ${ROOTDIR}usr/lib/volc
		   ${ROOTDIR}usr/lib/volc/backup"


	# X-Org SunOS Rootkit
	XORGSUNOS_FILES="${ROOTDIR}usr/lib/libX.a/bin/tmpfl
			 ${ROOTDIR}usr/lib/libX.a/bin/rps
			 ${ROOTDIR}usr/bin/srload
			 ${ROOTDIR}usr/lib/libX.a/bin/sparcv7/rps
			 ${ROOTDIR}usr/sbin/modcheck"
	XORGSUNOS_DIRS="${ROOTDIR}usr/lib/libX.a
			${ROOTDIR}usr/lib/libX.a/bin
			${ROOTDIR}usr/lib/libX.a/bin/sparcv7
			${ROOTDIR}usr/share/man..."


	# zaRwT.KiT
	ZARWT_FILES="${ROOTDIR}dev/rd/s/sendmeil ${ROOTDIR}dev/ttyf
		     ${ROOTDIR}dev/ttyp ${ROOTDIR}dev/ttyn ${ROOTDIR}rk/tulz"
	ZARWT_DIRS="${ROOTDIR}rk ${ROOTDIR}dev/rd/s"
	ZARWT_LOGS=".zarwt. sendmeil :60922 cky."


	# Miscellaneous login backdoors
	LOGIN_BACKDOOR_FILES="${ROOTDIR}bin/.login ${ROOTDIR}sbin/.login"


	# Misc Apache Backdoors
	APACHEBDOORS_STRINGS="gotcha"


	# Suspicious files in /dev
	# v1rootkit does use some files here to hide processes, UIDs and GIDs.
	# Files: /dev/ttyp, /dev/ttypr, /dev/ttypp, /dev/ttypq
	# (Checked: FreeBSD and RedHat doesn't have these files by default)
	# Files: /dev/ptyxx/.list /dev/ptyxx/.proc
	# Files: ${ROOTDIR}tmp/tr/td:

	SUSPICIOUS1_FILES=".list:Unknown file: .proc:Unknown file:
			   psybnc:IRC%%bouncer: td:Unknown file:
			   ttyp:Unknown file: ttypr:Unknown file:
			   ttypp:Unknown file: ttypq:Unknown file:"


	# Suspicious directories
	SUSPICIOUS1_DIRS="${ROOTDIR}usr/X11R6/bin/.,/copy/ ${ROOTDIR}dev/rd"


	# Evil strings
	STRINGSCAN="bin:test2:abc:Test
		    bin:init:/dev/proc/fuckit:Fuckit%%Rootkit
		    bin:init:FUCK:Possible%%Suckit%%Rootkit%%found
		    bin:init:backdoor:Possible%%backdoored%%init%%file%%(Suckit)
		    bin:login:vt200:Possible%%Linux%%Rootkit
		    bin:login:/usr/bin/xstat:Possible%%Linux%%Rootkit
		    bin:login:/bin/envpc:Unknown bin:login:l4m3r0x:Unknown
		    bin:login:/usr/lib/.tbd:TBD%%Rootkit
		    bin:ls:/dev/ptyxx/.file:Dica%%(T0rn%%variant)
		    bin:ls:/dev/sgk:Unknown
		    bin:ls:/var/lock/subsys/...datafile...:Ohhara%%Rootkit
		    bin:ls:/usr/lib/.tbd:TBD%%Rootkit
		    bin:netstat:/dev/proc/fuckit:Fuckit%%Rootkit
		    bin:netstat:/lib/.sso:Dica%%(T0rn%%variant)
		    bin:netstat:/var/lock/subsys/...datafile...:Ohhara%%Rootkit
		    bin:netstat:/dev/caca:MRK
		    bin:netstat:/dev/ttyoa:Sin%%Rootkit
		    bin:netstat:syg:Possible%%trojaned%%netstat
		    bin:nscd:sshd_config:Possible%%backdoor%%shell%%installed%%(SSH)
		    bin:ps:/dev/pts/01:SunOS%%Rootkit
		    bin:ps:tw33dl3:SunOS%%Rootkit
		    bin:ps:psniff:SunOS%%Rootkit
		    bin:ps:/var/lock/subsys/...datafile...:Ohhara%%Rootkit%%or%%Ni0%%Rootkit
		    bin:rpc.nfsd:cant%%open%%log:Possible%%sniffer%%installed
		    bin:rpc.nfsd:sniff.pid:Possible%%sniffer%%installed
		    bin:rpc.nfsd:tcp.log:Possible%%sniffer%%installed
		    bin:sshd:/dev/ptyxx:OpenBSD%%Rootkit
		    bin:syslogd:promiscuous:Possible%%sniffer%%installed
		    bin:syslogd:/usr/lib/.tbd:TBD%%Rootkit
		    bin:tcpd:/dev/xdta:Dica%%(T0rn%%variant)
		    bin:top:/usr/lib/.tbd:TBD%%Rootkit
		    bin:xtty:/bin/sh:Possible%%backdoor%%shell%%installed
		    etc:passwd:r00t:Possible%%GasKit
		    etc:passwd:t00r:Possible%%GasKit
		    libs:libproc.so.2.0.7:/dev/proc/fuckit:Fuckit%%Rootkit
		    rc.d:boot:/usr/bin/initrd%%-t1%%-X53%%-p:Dreams%%Rootkit
		    rc.d:functions:/usr/bin/initrd%%-t1%%-X53%%-p:Dreams%%Rootkit
		    rc.inet1:/usr/bin/initrd%%-t1%%-X53%%-p:Dreams%%Rootkit"


	# bin: /bin, /usr/bin, /usr/local/bin, /usr/sbin, /usr/local/sbin
	# etc: /etc
	# rc.d: /etc/rc.d /etc/rc.d/init.d
	# rc.sysinit: /etc/rc.d

	# Slackware /etc/rc.d/sysvinit
	RCSTRINGS="sshdu:Possible%%trojaned%%SSH%%Daemon
		   sshd1:Possible%%trojaned%%SSH%%Daemon
		   linsniffer:Possible%%keyboard%%sniffer%%found
		   startadore:Possible%%Adore%%rootkit%%found
		   ava:Possible%%PID%%hider%%found
		   .lsd:Torn%%based%%part%%found
		   /usr/bin/hdparm%%-t1%%-X53%%-p:MRK%%part%%found"


	BASHPROFILESTRINGS="${ROOTDIR}dev/proc/fucking/config:Possible%%Rootkit%%found
			    ${ROOTDIR}dev/proc/toolz/scan:Possible%%Rootkit%%found
			    ${ROOTDIR}script:Possible%%background%%logger%%found"


	# Files
	FILESCAN="file:${ROOTDIR}dev/sdr0:Possible%%MD5%%hash%%database
		  file:${ROOTDIR}tmp/.syshackfile:Trojaned%%syslog%%daemon
		  file:${ROOTDIR}tmp/.bash_history:Possible%%Lite5-r%%rootkit
		  file:${ROOTDIR}usr/info/.clib:Possible%%backdoor
		  file:${ROOTDIR}usr/sbin/tcp.log:Possible%%sniffer
		  file:${ROOTDIR}usr/bin/take/pid:Trojaned%%SSH%%daemon
		  file:${ROOTDIR}sbin/create:MzOzD%%Local%%backdoor%%found
		  file:${ROOTDIR}dev/ttypz:Found%%spwn%%login%%backdoor
		  dir:${ROOTDIR}usr/bin/take:Trojaned%%SSH%%daemon
		  dir:${ROOTDIR}usr/src/.lib:Unusual%%directory
		  dir:${ROOTDIR}usr/share/man/man1/.1c:Possible%%Eggdrop%%installed
		  dir:${ROOTDIR}lib/lblip.tk:Directory%%with%%backdoored%%SSH-configuration
		  dir:${ROOTDIR}usr/sbin/...:Unusual%%directory
		  dir:${ROOTDIR}usr/share/.gun:Unusual%%directory"


	# Evil strings for *BSD KLD (Dynamic Kernel Linker modules)
	KLDSTATKEYWORDS="backd00r backdoor"

# New:
#KLDSTATKEYWORDS="
#backd00r:Unknown%%backdoor
#backdoor:Unknown%%backdoor
#r00tkit:Unknown%%backdoor
#rootkit:Unknown%%backdoor
#darkside:Darkside%%KLD
#hide_link_file:Darkside%%KLD
#"


	LKMSCAN="LuCe%%LKM:LuCe%%LKM-module"
	LKMSTRINGS="pass.log|thc.org:THC%%Vlogger:Keylogger/sniffer"


	RCLOCAL_STRINGS="${ROOTDIR}usr/bin/rpc.wall:Unknown
			 sshdd:Possible%%GasKit
			 hidef:Possible%%part%%of%%Knark%%found"


	# Integrity tests
	STRINGS_INTEGRITY="${BOBKIT_FILES} ${BOBKIT_DIRS} ${CINIK_FILES}
			   ${CINIK_DIRS} ${DICA_FILES} ${FREEBSD_RK_FILES}
			   ${TBD_FILES} ${TORN_FILES} ${TORN_DIRS}"


	SNIFFER_FILES="${ROOTDIR}usr/lib/libice.log"


	APACHE_MOD_ROOTME="${ROOTDIR}usr/local/apache/libexec/mod_rootme.so
			   ${ROOTDIR}usr/lib/apache/1.3/mod_rootme.so
			   ${ROOTDIR}usr/lib/apache2/modules/mod_rootme2.so
			   ${ROOTDIR}usr/local/apache2/modules/mod_rootme2.so"


	HTTPDCONFS="${ROOTDIR}usr/local/apache/conf/httpd.conf
		    ${ROOTDIR}usr/local/etc/apache/httpd.conf
		    ${ROOTDIR}etc/apache/httpd.conf"


	BAD_PROCESSES="31337:Linsniffer"

	return
}


do_known_good_hash_check() {

	displaytext "  ${WHITE}Performing 'known good' check...${NORMAL}"


	if [ $PRELINKED -eq 0 ]; then
		HCMD=${HASH_FUNC}
	else
		if [ -n "`echo ${HASH_FUNC} | grep 'md5'`" ]; then
			HCMD="${PRELINK_CMD} --verify --md5"
		else
			HCMD="${PRELINK_CMD} --verify --sha"
		fi
	fi

	if [ -n "`echo ${STAT_CMD} | grep '\.pl$'`" ]; then
		SCMD="${STAT_CMD} --modeoct --raw --mode --ino -uid -gid -Mtime"
	else
		if [ "${OPERATING_SYSTEM}" = "NetBSD" ]; then
			SCMD="${STAT_CMD} -f '%i %Mp%Lp %u %g %m:'"
		else
			SCMD="${STAT_CMD} --format='%i 0%a %u %g %Y:'"
		fi
	fi


	for DIR in ${HASHDIRS}; do
		for FNAME in ${HASHFILES}; do
			HASH_OK=0; MISSING=0

			RKHLINE=`grep "^File:${DIR}/${FNAME}:" ${DB_PATH}/rkhunter.dat`

			if [ -f "${DIR}/${FNAME}" ]; then
				if [ -n "${RKHLINE}" ]; then
					HASH_COUNT=`expr ${HASH_COUNT} + 1`

					RKHHASH=`echo ${RKHLINE} | cut -d: -f3`

					if [ -n "${RKHHASH}" ]; then
						SYSHASH=`get_hash_value "${DIR}/${FNAME}"`

						if [ $PRELINKED -eq 0 ]; then
							RKHINODE=`echo ${RKHLINE} | cut -d: -f4`
							RKHPERM=`echo ${RKHLINE} | cut -d: -f5`
							RKHUID=`echo ${RKHLINE} | cut -d: -f6`
							RKHGID=`echo ${RKHLINE} | cut -d: -f7`
							RKHDTM=`echo ${RKHLINE} | cut -d: -f8`

							FDATA=`eval ${SCMD} ${DIR}/${FNAME} 2>/dev/null | tr ' ' ':'`
							SYSINODE=`echo ${FDATA} | cut -d: -f1`
							SYSPERM=`echo ${FDATA} | cut -d: -f2`
							SYSUID=`echo ${FDATA} | cut -d: -f3`
							SYSGID=`echo ${FDATA} | cut -d: -f4`
							SYSDTM=`echo ${FDATA} | cut -d: -f5`

							if [ "${RKHHASH}" = "${SYSHASH}" -a "${RKHINODE}" = "${SYSINODE}" -a "${RKHPERM}" = "${SYSPERM}" -a "${RKHUID}" = "${SYSUID}" -a "${RKHGID}" = "${SYSGID}" -a "${RKHDTM}" = "${SYSDTM}" ]; then
								HASH_OK=1
							fi
						elif [ "${RKHHASH}" = "${SYSHASH}" ]; then
							HASH_OK=1
						fi
					else
						MISSING=1
						logtext "Warning: The file ${DIR}/${FNAME} exists on the system,"
						logtext --indent "but it has no hash value in the rkhunter.dat file."
					fi
				else
					MISSING=1
					logtext "Warning: The file ${DIR}/${FNAME} exists on the system,"
					logtext --indent "but it is not present in the rkhunter.dat file."
				fi
			else
				if [ -n "${RKHLINE}" ]; then
					MISSING=1
					logtext "Warning: The file ${DIR}/${FNAME} does not exist on the system,"
					logtext --indent "but it is present in the rkhunter.dat file."
				else
					continue
				fi
			fi


			if [ $HASH_OK -eq 0 -a $MISSING -eq 0 ]; then
				for WHITELISTSTRING in `grep '^HASHWHITELIST=' ${CONFIGFILE} | sed -e 's/HASHWHITELIST=//g'`; do
					WHITELISTFILE=`echo ${WHITELISTSTRING} | cut -d: -f1`
					WHITELISTHASH=`echo ${WHITELISTSTRING} | cut -d: -f2`

					if [ "${WHITELISTFILE}" = "${FNAME}" -a "${WHITELISTHASH}" = "${RKHHASH}" ]; then
						HASH_OK=1
						logtext "Info: Whitelisted file hash value found: File: ${FNAME}    Hash: ${RKHHASH}"
					fi
				done
			fi


			FSIZE=`echo "${DIR}/${FNAME}" | wc -c | tr -d ' '`
			jump=`expr ${defaultcolumn} - ${FSIZE}`

			displaytext -n "   ${DIR}/${FNAME}"
			insertlayout

			if [ $HASH_OK -eq 1 ]; then
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			else
				HASH_DIFFERENT=`expr ${HASH_DIFFERENT} + 1`

				displaytext $E "${LAYOUT}[ ${RED}BAD${NORMAL} ]"

				if [ $MISSING -eq 0 ]; then
					logtext "Warning: File data values have changed:"
					logtext --indent "File: ${DIR}/${FNAME}"

					if [ "${SYSHASH}" != "${RKHHASH}" ]; then
						logtext --indent "File hash: ${SYSHASH}"
						logtext --indent "DB hash  : ${RKHHASH}"
					fi

					test "${SYSINODE}" != "${RKHINODE}" && logtext --indent "File inode: ${SYSINODE}    DB inode: ${RKHINODE}"
					test "${SYSPERM}" != "${RKHPERM}" && logtext --indent "File permissions: ${SYSPERM}    DB permissions: ${RKHPERM}"
					test "${SYSUID}" != "${RKHUID}" && logtext --indent "File uid: ${SYSUID}    DB uid: ${RKHUID}"
					test "${SYSGID}" != "${RKHGID}" && logtext --indent "File gid: ${SYSGID}    DB gid: ${RKHGID}"
					test "${SYSDTM}" != "${RKHDTM}" && logtext --indent "File modification time: ${SYSDTM}    DB modification time: ${RKHDTM}"
				fi
			fi
		done
	done


	if [ $HASH_COUNT -eq 0 ]; then
		displaytext "Warning: No file hash values found"
		logtext "Warning: No file hash values found"
	fi

	return
}


do_system_check() {

	do_system_check_initialisation

##################################################################################################
#
# Initialisation
#
##################################################################################################

# We don't know OS yet
valid_os="0"


# Begin parameters

##################################################################################################
#
# check complete system
#
##################################################################################################

logtext "---------------------------- System checks ----------------------------"

	displaytext ""; displaytext "";
	displaytext "${PROGRAM_NAME} ${PROGRAM_version} is running"
	displaytext ""


	if [ -z "${KSYMS_FILE}" ]; then
		logtext "Info: ksyms and kallsyms file checks will be skipped (files not present on this system)"
	fi


# jh - split this up. mirrors.dat for update only; programs files for apps check; md5blacklist for check bad option.
	logtext "---------------------------- File checks -----------------------------"


	NEEDEDFILES="
	${DB_PATH}/md5blacklist.dat
	${DB_PATH}/mirrors.dat
	${DB_PATH}/programs_bad.dat
	${DB_PATH}/programs_good.dat
	"

	for I in ${NEEDEDFILES}; do
		logtext -n "Checking ${I}... "
		if [ -f "${I}" ]; then
			logtext --nodate "OK"
		else
			logtext --nodate "Error. Doesn't exists!"
			displaytext "Fatal error: file ${I} doesn't exists. Please check your paths and/or parameters."
			exit 1
		fi
	done


	displaytext ""; displaytext ""
	displaytext "${YELLOW}Checking binaries${NORMAL}"
	displaytext "${test}* Selftests${NORMAL}"

	logtext "------------------------------ Selftests ------------------------------"

	# Self check

	SIZE=23
	displaytext -n "     Strings (command)"
	jump=`expr ${defaultcolumn} - ${SIZE}`
	STRINGSFAILED=0

	if [ -n "${STRINGS_CMD}" ]; then
		for I in ${STRINGS_INTEGRITY}; do
			logtext -n "Strings selftest: scanning for string ${I}... "
			STRINGNAME=`echo "${I}" | sed -e 's/\./\\\./g'`
			STRINGFOUND=`echo "${I}" | ${STRINGS_CMD} | grep "${STRINGNAME}" | tr -d ' '`
			if [ "${STRINGFOUND}" = "" ]; then
				STRINGSFAILED=1
				FAILEDSTRINGS="${FAILEDSTRINGS} ${I}"
				logtext --nodate "WARNING!"
			else
				logtext --nodate "OK"
			fi
		done

		if [ "${STRINGSFAILED}" -eq 1 ]; then
			insertlayout
			displaytext $E "   ${file}${LAYOUT}[ ${RED}BAD${NORMAL} ]"
			displaytext ""
			displaytext "-----------------------------------------------------------------------------------"
			displaytext "Expected (but not found) strings:"
			displaytext "${FAILEDSTRINGS}"
			displaytext "-----------------------------------------------------------------------------------"
		else
			jump=`expr ${defaultcolumn} - ${SIZE}`
			insertlayout
			displaytext $E "   ${file}${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		fi
		displaytext "${NORMAL}"
	else
		insertlayout
		displaytext $E "   ${file}${LAYOUT}[ ${WHITE}Skipped!${NORMAL} ]"
	fi

	displaytext ""



	logtext "---------------------------- Hash tests ---------------------------"


	# Binary check

	displaytext "${test}* System tools${NORMAL}"

	if [ $SKIP_HASHCHECK -eq 0 ]; then
		logtext "Starting hash checksum test"

		if [ $PERFORMKNOWNBAD -eq 1 ]; then

			displaytext "  ${WHITE}Performing 'known bad' check...${NORMAL}"

			# Files to check
			CHECKFILES="${ROOTDIR}bin/cat ${ROOTDIR}bin/chmod ${ROOTDIR}bin/chown ${ROOTDIR}bin/csh ${ROOTDIR}bin/date ${ROOTDIR}bin/df ${ROOTDIR}bin/dmesg ${ROOTDIR}bin/echo ${ROOTDIR}bin/ed ${ROOTDIR}bin/egrep ${ROOTDIR}bin/env ${ROOTDIR}bin/fgrep ${ROOTDIR}bin/grep ${ROOTDIR}bin/id ${ROOTDIR}bin/kill ${ROOTDIR}bin/login ${ROOTDIR}bin/ls ${ROOTDIR}bin/md5 ${ROOTDIR}bin/more ${ROOTDIR}bin/mount ${ROOTDIR}bin/netstat ${ROOTDIR}bin/ps ${ROOTDIR}bin/sh ${ROOTDIR}bin/sha1 ${ROOTDIR}bin/sort ${ROOTDIR}bin/su ${ROOTDIR}sbin/checkproc ${ROOTDIR}sbin/chkconfig ${ROOTDIR}sbin/depmod ${ROOTDIR}sbin/dmesg ${ROOTDIR}sbin/ifconfig ${ROOTDIR}sbin/ifdown ${ROOTDIR}sbin/ifstatus ${ROOTDIR}sbin/ifup ${ROOTDIR}sbin/init ${ROOTDIR}sbin/insmod ${ROOTDIR}sbin/ip ${ROOTDIR}sbin/kldload ${ROOTDIR}sbin/kldstat ${ROOTDIR}sbin/kldunload ${ROOTDIR}sbin/kallsyms ${ROOTDIR}sbin/ksyms ${ROOTDIR}sbin/lsmod ${ROOTDIR}sbin/md5 ${ROOTDIR}sbin/modinfo ${ROOTDIR}sbin/modload ${ROOTDIR}sbin/modprobe ${ROOTDIR}sbin/modunload ${ROOTDIR}sbin/nologin ${ROOTDIR}sbin/rmmod ${ROOTDIR}sbin/runlevel ${ROOTDIR}sbin/sulogin ${ROOTDIR}sbin/sysctl ${ROOTDIR}sbin/syslogd ${ROOTDIR}usr/bin/basename ${ROOTDIR}usr/bin/chattr ${ROOTDIR}usr/bin/du ${ROOTDIR}usr/bin/egrep ${ROOTDIR}usr/bin/fgrep ${ROOTDIR}usr/bin/file ${ROOTDIR}usr/bin/find ${ROOTDIR}usr/bin/groups ${ROOTDIR}usr/bin/head ${ROOTDIR}usr/bin/kill ${ROOTDIR}usr/bin/killall ${ROOTDIR}usr/bin/last ${ROOTDIR}usr/bin/lastlog ${ROOTDIR}usr/bin/less ${ROOTDIR}usr/bin/locate ${ROOTDIR}usr/bin/logger ${ROOTDIR}usr/bin/login ${ROOTDIR}usr/bin/lsattr ${ROOTDIR}usr/bin/md5sum ${ROOTDIR}usr/bin/modstat ${ROOTDIR}usr/bin/more ${ROOTDIR}usr/bin/netstat ${ROOTDIR}usr/bin/newsyslog ${ROOTDIR}usr/bin/passwd ${ROOTDIR}usr/bin/pstree ${ROOTDIR}usr/bin/sha1sum ${ROOTDIR}usr/bin/size ${ROOTDIR}usr/bin/slocate ${ROOTDIR}usr/bin/sockstat ${ROOTDIR}usr/bin/sort ${ROOTDIR}usr/bin/stat ${ROOTDIR}usr/bin/strace ${ROOTDIR}usr/bin/strings ${ROOTDIR}usr/bin/su ${ROOTDIR}usr/bin/systat ${ROOTDIR}usr/bin/test ${ROOTDIR}usr/bin/top ${ROOTDIR}usr/bin/touch ${ROOTDIR}usr/bin/uname ${ROOTDIR}usr/bin/users ${ROOTDIR}usr/bin/vmstat ${ROOTDIR}usr/bin/w ${ROOTDIR}usr/bin/watch ${ROOTDIR}usr/bin/wc ${ROOTDIR}usr/bin/wget ${ROOTDIR}usr/bin/whatis ${ROOTDIR}usr/bin/whereis ${ROOTDIR}usr/bin/which ${ROOTDIR}usr/bin/who ${ROOTDIR}usr/bin/whoami ${ROOTDIR}usr/sbin/adduser ${ROOTDIR}usr/sbin/amd ${ROOTDIR}usr/sbin/chroot ${ROOTDIR}usr/sbin/cron ${ROOTDIR}usr/sbin/inetd ${ROOTDIR}usr/sbin/kudzu ${ROOTDIR}usr/sbin/syslogd ${ROOTDIR}usr/sbin/tcpd ${ROOTDIR}usr/sbin/useradd ${ROOTDIR}usr/sbin/usermod ${ROOTDIR}usr/sbin/vipw ${ROOTDIR}usr/sbin/xinetd"
			for I in ${CHECKFILES}; do
				if [ -f ${I} ]; then
					displaytext -n "   ${I}"
					SIZE=`echo "${I}" | wc -c | tr -d ' '`
					ISBAD=""
					MD5SUM=`${MD5_CMD} ${I} | cut -d' ' -f1`

					if [ "${OPERATING_SYSTEM}" = "OpenBSD" -a "${MD5_CMD}" = "/bin/md5" ]; then
						MD5SUM=`echo ${MD5SUM} | cut -d ' ' -f4 | tr -d ' '`
					fi

					ISBAD=`grep ${MD5SUM} ${DB_PATH}/md5blacklist.dat`

					if [ "${ISBAD}" = "" ]; then
						jump=`expr ${defaultcolumn} - ${SIZE}`
						insertlayout
						displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
					else
						jump=`expr ${defaultcolumn} - ${SIZE}`
						insertlayout
						displaytext $E "${LAYOUT}[ ${RED}BAD${NORMAL} ]"
						logtext "Possible backdoored or harmful file found ${I}"
						WARNING=1
					fi
				fi
			done

			displaytext ""
		fi


		do_known_good_hash_check

		keypresspause

	else
		displaytext "     ${WHITE}Skipped!${NORMAL}"
		logtext "Hash test skipped!"

	fi


	#    displaytext "${test}* Searching for system files${NORMAL}"

	#	SCANFILELIST="${INSTALLDIR}/lib/rkhunter/tmp/files.lst"
	#	if [ ${QUICKSCAN} -eq 0 ]; then
	#		find / -name *.o -or -name *.ko > ${SCANFILELIST}
	#	else
	#		locate *.o *.ko | head > ${SCANFILELIST}
	#	fi
	#	FILESCOUNT=`cat ${SCANFILELIST} | wc -l | tr -s ' ' | tr -d ' '`
	#	displaytext "Datbase contains ${FILESCOUNT} files to investigate."


	##################################################################################################
	#
	# Rootkits
	#
	##################################################################################################


	displaytext ""; displaytext ""
	displaytext "${YELLOW}Check rootkits${NORMAL}"
	displaytext "${test}* Default files and directories${NORMAL}"

	logtext "------------------------------ Rootkits ------------------------------"

	# 55808 Trojan - Variant A

	SCAN_ROOTKIT="55808 Trojan - Variant A"
	SCAN_FILES=${W55808A_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# ADM worm

	SIZE="13"
	jump=`expr ${defaultcolumn} - ${SIZE}`

	displaytext -n "   ADM Worm... "
	if [ -e /etc/passwd ]; then
		logtext "Checking /etc/passwd for presence of ADM worm"
		WORM=`grep 'w0rm' /etc/passwd`
		if [ "${WORM}" = "" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			logtext --nodate "OK"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}BAD${NORMAL} ]"
			logtext --nodate "Warning! Possible ADM w0rm found"
			displaytext "${FOUNDTRACES}"
		fi
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}Clean${NORMAL} ]"
	fi

	# AjaKit

	SCAN_ROOTKIT="AjaKit"
	SCAN_FILES=${AJAKIT_FILES}
	SCAN_DIRS=${AJAKIT_DIRS}
	SCAN_KSYMS=${AJAKIT_KSYMS}
	scanrootkit

	# aPa Kit

	SCAN_ROOTKIT="aPa Kit"
	SCAN_FILES=${APAKIT_FILES}
	SCAN_DIRS=${APAKIT_DIRS}
	SCAN_KSYMS=${APAKIT_KSYMS}
	scanrootkit

	# Apache worm

	SCAN_ROOTKIT="Apache Worm"
	SCAN_FILES=${APACHEWORM_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# Ambient (ark) Rootkit

	SCAN_ROOTKIT="Ambient (ark) Rootkit"
	SCAN_FILES=${ARK_FILES}
	SCAN_DIRS=${ARK_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Balaur Rootkit

	SCAN_ROOTKIT="Balaur Rootkit"
	SCAN_FILES=${BALAUR_FILES}
	SCAN_DIRS=${BALAUR_DIRS}
	SCAN_KSYMS=${BALAUR_KSYMS}
	scanrootkit

	# BeastKit

	SCAN_ROOTKIT="BeastKit"
	SCAN_FILES=${BEASTKIT_FILES}
	SCAN_DIRS=${BEASTKIT_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# beX2
	SCAN_ROOTKIT="beX2"
	SCAN_FILES=${BEX_FILES}
	SCAN_DIRS=${BEX_DIRS}
	SCAN_KSYMS=${BEX_KSYMS}
	scanrootkit

	# BOBKit

	SCAN_ROOTKIT="BOBKit"
	SCAN_FILES=${BOBKIT_FILES}
	SCAN_DIRS=${BOBKIT_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# CiNIK Worm (Slapper.B variant)
	SCAN_ROOTKIT="CiNIK Worm (Slapper.B variant)"
	SCAN_FILES=${CINIK_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# Danny-Boy's Abuse Kit

	SCAN_ROOTKIT="Danny-Boy's Abuse Kit"
	SCAN_FILES=${DANNYBOYS_FILES}
	SCAN_DIRS=${DANNYBOYS_DIRS}
	SCAN_KSYMS=${DANNYBOYS_KSYMS}
	scanrootkit

	# Devil RootKit

	SCAN_ROOTKIT="Devil RootKit"
	SCAN_FILES=${DEVIL_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# Dica

	SCAN_ROOTKIT="Dica"
	SCAN_FILES=${DICA_FILES}
	SCAN_DIRS=${DICA_DIRS}
	SCAN_KSYMS=${DICA_KSYMS}
	scanrootkit

	# Dreams RootKit

	SCAN_ROOTKIT="Dreams Rootkit"
	SCAN_FILES=${DREAMS_FILES}
	SCAN_DIRS=${DREAMS_DIRS}
	SCAN_KSYMS=${DREAMS_KSYMS}
	scanrootkit

	# Duarawkz

	SCAN_ROOTKIT="Duarawkz"
	SCAN_FILES=${DUARAWKZ_FILES}
	SCAN_DIRS=${DUARAWKZ_DIRS}
	SCAN_KSYMS=${DUARAWKZ_KSYMS}
	scanrootkit

	# Enye LKM

	SCAN_ROOTKIT="Enye LKM"
	SCAN_FILES=${ENYELKM_FILES}
	SCAN_DIRS=${ENYELKM_DIRS}
	SCAN_KSYMS=${ENYELKM_KSYMS}
	scanrootkit

	# Flea Linux rootkit

	SCAN_ROOTKIT="Flea Linux Rootkit"
	SCAN_FILES=${FLEA_FILES}
	SCAN_DIRS=${FLEA_DIRS}
	SCAN_KSYMS=${FLEA_KSYMS}
	scanrootkit

	# FreeBSD Rootkit

	SCAN_ROOTKIT="FreeBSD Rootkit"
	SCAN_FILES=${FREEBSD_RK_FILES}
	SCAN_DIRS=${FREEBSD_RK_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Fuck`it Rootkit

	SCAN_ROOTKIT="Fuck\`it Rootkit"
	SCAN_FILES=${FUCKIT_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# GasKit

	SCAN_ROOTKIT="GasKit"
	SCAN_FILES=${GASKIT_FILES}
	SCAN_DIRS=${GASKIT_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Heroin

	SCAN_ROOTKIT="Heroin LKM"
	SCAN_FILES=${HEROIN_FILES}
	SCAN_DIRS=${HEROIN_DIRS}
	SCAN_KSYMS=${HEROIN_KSYMS}
	scanrootkit

	# HjC Kit

	SCAN_ROOTKIT="HjC Kit"
	SCAN_FILES=${HJCKIT_FILES}
	SCAN_DIRS=${HJCKIT_DIRS}
	SCAN_KSYMS=${HJCKIT_KSYMS}
	scanrootkit

	# ignoKit

	SCAN_ROOTKIT="ignoKit"
	SCAN_FILES=${IGNOKIT_FILES}
	SCAN_DIRS=${IGNOKIT_DIRS}
	SCAN_KSYMS=${IGNOKIT_KSYMS}
	scanrootkit

	# ImperalsS-FBRK

	SCAN_ROOTKIT="ImperalsS-FBRK"
	SCAN_FILES=""
	SCAN_DIRS=${IMPFRB_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Irix Rootkit

	SCAN_ROOTKIT="Irix Rootkit"
	SCAN_FILES=${IRIXRK_FILES}
	SCAN_DIRS=${IRIXRK_DIRS}
	SCAN_KSYMS=${IRIXRK_KSYMS}
	scanrootkit

	# Kitko

	SCAN_ROOTKIT="Kitko"
	SCAN_FILES=${KITKO_FILES}
	SCAN_DIRS=${KITKO_DIRS}
	SCAN_KSYMS=${KITKO_KSYMS}
	scanrootkit

	# Knark

	SCAN_ROOTKIT="Knark"
	SCAN_FILES=${KNARK_FILES}
	SCAN_DIRS=${KNARK_DIRS}
	SCAN_KSYMS=${KNARK_KSYMS}
	scanrootkit

	# Li0n Worm

	SCAN_ROOTKIT="Li0n Worm"
	SCAN_FILES=${LION_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# Lockit / LJK2

	SCAN_ROOTKIT="Lockit / LJK2"
	SCAN_FILES=${LOCKIT_FILES}
	SCAN_DIRS=${LOCKIT_DIRS}
	SCAN_KSYMS=${LOCKIT_KSYMS}
	scanrootkit

	# Mood-NT

	SCAN_ROOTKIT="Mood-NT"
	SCAN_FILES=${MOODNT_FILES}
	SCAN_DIRS=${MOODNT_DIRS}
	SCAN_KSYMS=${MOODNT_KSYMS}
	scanrootkit

	# MRK (MiCrobul RootKit?)

	SCAN_ROOTKIT="MRK"
	SCAN_FILES=${MRK_FILES}
	SCAN_DIRS=${MRK_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Ni0 Rootkit

	SCAN_ROOTKIT="Ni0 Rootkit"
	SCAN_FILES=${NIO_FILES}
	SCAN_DIRS=${NIO_DIRS}
	SCAN_KSYMS=${NIO_KSYMS}
	scanrootkit

	# RootKit for SunOS / NSDAP

	SCAN_ROOTKIT="RootKit for SunOS / NSDAP"
	SCAN_FILES=${NSDAP_FILES}
	SCAN_DIRS=${NSDAP_DIRS}
	SCAN_KSYMS=${NSDAP_KSYMS}
	scanrootkit

	# Optic Kit Worm

	SCAN_ROOTKIT="Optic Kit (Tux)"
	SCAN_FILES=""
	SCAN_DIRS=${OPTICKIT_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Oz Rootkit

	SCAN_ROOTKIT="Oz Rootkit"
	SCAN_FILES=${OZ_FILES}
	SCAN_DIRS=${OZ_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Phalanx

	SCAN_ROOTKIT="Phalanx"
	SCAN_FILES=${PHALANX_FILES}
	SCAN_DIRS="${PHALANX_DIRS}"
	SCAN_KSYMS="${PHALANX_KSYMS}"
	scanrootkit

	if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
		STATUS=0
		SIZE=13

		logtext "Debug: Phalanx (/bin/hostname)"
		displaytext -n "   Phalanx (/bin/hostname)"

		# Search for Phalanx in /bin/hostname
		if [ -e /bin/hostname ]; then
			if `grep -q 'phalanx' /bin/hostname >/dev/null 2>&1`; then
				STATUS=1
			fi
		fi

		if [ ${STATUS} -eq 0 ]; then
			jump=`expr ${defaultcolumn} - ${SIZE}`
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		else
			jump=`expr ${defaultcolumn} - ${SIZE}`
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
			displaytext "${FOUNDTRACES}"
		fi
	fi

	# Portacelo

	SCAN_ROOTKIT="Portacelo"
	SCAN_FILES=${PORTACELO_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# R3dstorm Toolkit

	SCAN_ROOTKIT="R3dstorm Toolkit"
	SCAN_FILES=${REDSTORM_FILES}
	SCAN_DIRS=${REDSTORM_DIRS}
	SCAN_KSYMS=${REDSTORM_KSYMS}
	scanrootkit

	# RH-Sharpe's rootkit

	SCAN_ROOTKIT="RH-Sharpe's rootkit"
	SCAN_FILES=${RHSHARPES_FILES}
	SCAN_DIRS=${RHSHARPES_DIRS}
	SCAN_KSYMS=${RHSHARPES_KSYMS}
	scanrootkit

	# RSHA's rootkit

	SCAN_ROOTKIT="RSHA's rootkit"
	SCAN_FILES=${RSHA_FILES}
	SCAN_DIRS=${RSHA_DIRS}
	SCAN_KSYMS=${RSHA_KSYMS}
	scanrootkit

	# Sebek LKM (Honeypot)

	STATUS=0
	SIZE=13

	logtext "Debug: Sebek LKM"
	displaytext -n "   Sebek LKM..."

	# Search for signs of Sebek in ksyms and kallsyms files
	if [ -n "${KSYMS_FILE}" ]; then
		if `egrep -i 'adore|sebek' ${KSYMS_FILE} >/dev/null 2>&1`; then
			STATUS=1
		fi
	fi

	if [ ${STATUS} -eq 0 ]; then
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
	else
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
		displaytext "${FOUNDTRACES}"
	fi

	# Scalper Worm

	SCAN_ROOTKIT="Scalper Worm"
	SCAN_FILES=${SCALPER_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# Shutdown

	SCAN_ROOTKIT="Shutdown"
	SCAN_FILES=${SHUTDOWN_FILES}
	SCAN_DIRS=${SHUTDOWN_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# SHV4 Rootkit

	SCAN_ROOTKIT="SHV4"
	SCAN_FILES=${SHV4_FILES}
	SCAN_DIRS=${SHV4_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# SHV5 Rootkit

	SCAN_ROOTKIT="SHV5"
	SCAN_FILES=${SHV5_FILES}
	SCAN_DIRS=${SHV5_DIRS}
	SCAN_KSYMS=${SHV5_KSYMS}
	scanrootkit

	# Sin Rootkit

	SCAN_ROOTKIT="Sin Rootkit"
	SCAN_FILES=${SINROOTKIT_FILES}
	SCAN_DIRS=${SINROOTKIT_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Slapper

	SCAN_ROOTKIT="Slapper"
	SCAN_FILES=${SLAPPER_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# Sneakin Rootkit

	SCAN_ROOTKIT="Sneakin Rootkit"
	SCAN_FILES=""
	SCAN_DIRS=${SNEAKIN_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Suckit Rootkit

	SCAN_ROOTKIT="Suckit Rootkit"
	SCAN_FILES=${SUCKIT_FILES}
	SCAN_DIRS=${SUCKIT_DIRS}
	SCAN_KSYMS=""
	scanrootkit
	scanrootkit_suckit_extra_checks

	# SunOS Rootkit

	SCAN_ROOTKIT="SunOS Rootkit"
	SCAN_FILES=${SUNOSROOTKIT_FILES}
	SCAN_DIRS=${SUNOSROOTKIT_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Superkit

	SCAN_ROOTKIT="Superkit"
	SCAN_FILES=${SUPERKIT_FILES}
	SCAN_DIRS=${SUPERKIT_DIRS}
	SCAN_KSYMS=${SUPERKIT_KSYMS}
	scanrootkit

	# TBD (Telnet BackDoor)

	SCAN_ROOTKIT="TBD (Telnet BackDoor)"
	SCAN_FILES=${TBD_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# TeLeKiT

	SCAN_ROOTKIT="TeLeKiT"
	SCAN_FILES=${TELEKIT_FILES}
	SCAN_DIRS=${TELEKIT_DIRS}
	SCAN_KSYMS=${TELEKIT_KSYMS}
	scanrootkit


	# T0rn Rootkit

	SCAN_ROOTKIT="T0rn Rootkit"
	SCAN_FILES=${TORN_FILES}
	SCAN_DIRS=${TORN_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# Trojanit Kit

	SCAN_ROOTKIT="Trojanit Kit"
	SCAN_FILES=${TROJANIT_FILES}
	SCAN_DIRS=""
	SCAN_KSYMS=""
	scanrootkit

	# Tuxtendo

	SCAN_ROOTKIT="Tuxtendo"
	SCAN_FILES=${TUXTENDO_FILES}
	SCAN_DIRS=${TUXTENDO_DIRS}
	SCAN_KSYMS=${TUXTENDO_KSYMS}
	scanrootkit

	# URK (Universal Root Kit)

	SCAN_ROOTKIT="URK"
	SCAN_FILES=${URK_FILES}
	SCAN_DIRS=${URK_DIRS}
	SCAN_KSYMS=${URK_KSYMS}
	scanrootkit

	# VcKit

	SCAN_ROOTKIT="VcKit"
	SCAN_FILES=${VCKIT_FILES}
	SCAN_DIRS=${VCKIT_DIRS}
	SCAN_KSYMS=${VCKIT_KSYMS}
	scanrootkit

	# Volc Rootkit

	SCAN_ROOTKIT="Volc Rootkit"
	SCAN_FILES=${VOLC_FILES}
	SCAN_DIRS=${VOLC_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# X-Org SunOS Rootkit

	SCAN_ROOTKIT="X-Org SunOS Rootkit"
	SCAN_FILES=${XORGSUNOS_FILES}
	SCAN_DIRS=${XORGSUNOS_DIRS}
	SCAN_KSYMS=""
	scanrootkit

	# zaRwT.KiT

	SCAN_ROOTKIT="zaRwT.KiT Rootkit"
	SCAN_FILES=${ZARWT_FILES}
	SCAN_DIRS=${ZARWT_DIRS}
	SCAN_KSYMS=""
	scanrootkit



	##################################################################################################
	#
	# Malware
	#
	##################################################################################################

	displaytext ""
	displaytext "${test}* Suspicious files and malware${NORMAL}"

	logtext "------------------------------ Malware ------------------------------"

	logtext "Start scan for common used known (and unknown) rootkit files..."

	SIZE=35
	displaytext -n "   Scanning for known rootkit strings"
	logtext "[Start string tests]"

	if [ -n "${STRINGS_CMD}" ]; then
		FOUND=0
		for I in ${STRINGSCAN}; do
			TYPE=`echo $I | cut -d ':' -f1`
			FILE=`echo $I | cut -d ':' -f2 | sed -e 's/%%/ /g'`
			FILESTRING=`echo $I | cut -d ':' -f3 | sed -e 's/%%/ /g'`
			INFO=`echo $I | cut -d ':' -f4 | sed -e 's/%%/ /g'`
			FOUNDFILE=0
			case ${TYPE} in
			bin)
				for I in ${BINPATHS}; do
					FILENAME="${I}/${FILE}"
					if [ -f $FILENAME ]; then
						FSTRING=`echo "${FILESTRING}" | sed -e 's/\./\\\./g'`
						FOUNDSTRING=`${STRINGS_CMD} $FILENAME | grep "${FSTRING}"`
						if [ "${FOUNDSTRING}" = "" ]; then
							logtext "${FILENAME} clean (string: $FILESTRING)"
						else
							logtext "Warning: ${FILENAME} NOT clean (string: $FILESTRING)"
							FOUND=1
						fi
					fi
				done
				;;
			esac
		done

		if [ ${FOUND} -eq 1 ]; then
			jump=`expr ${defaultcolumn} - ${SIZE}`
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}BAD${NORMAL} ]"
			displaytext "Warning: Found unexpected strings in some files! Check the logfile for more details"
			logtext "Warning: Found unexpected strings in some files!"
		else
			jump=`expr ${defaultcolumn} - ${SIZE}`
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			logtext "All files are OK"
		fi
	else
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${YELLOW}Skipped${NORMAL} ]"
		logtext "Skipped stringtest (rootkit strings), due to missing `strings`"
	fi

	logtext "[End string tests]"

	SIZE=33
	displaytext -n "   Scanning for known rootkit files"

	for I in ${FILESCAN}; do
		TYPE=`echo $I | cut -d ':' -f1`
		FILE=`echo $I | cut -d ':' -f2`
		INFO=`echo $I | cut -d ':' -f3`
		FOUNDFILE=0
		FILE=`echo ${FILE} | sed -e 's/%%/ /g'`
		INFO=`echo ${INFO} | sed -e 's/%%/ /g'`

		logtext -n "Scanning for presence of ${FILE} (${TYPE})... "
		case ${TYPE} in
		dir)
			if [ -d "${FILE}" ]; then
				FOUNDFILE=1
				logtext --nodate "WARNING! Found possible bad directory"
			else
				logtext --nodate "OK (not found)"
			fi
			;;
		file)
			if [ -f "{$FILE}" ]; then
				FOUNDFILE=1
				logtext --nodate "WARNING! Found possible bad file"
			else
				logtext --nodate "OK (not found)"
			fi
			;;
		esac
	done

	if [ ${FOUNDFILE} -eq 0 ]; then
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
	else
		INFECTED_COUNT=`expr ${INFECTED_COUNT} + 1`
		INFECTED_NAMES="${INFECTED_NAMES} / ${INFO} "
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
		displaytext "
		-------------------------------------------------------------------------
		Warning found file '${FILE}'
		Information: ${INFO}
		-------------------------------------------------------------------------
		"
	fi

	logtext "-------------------------- Open files tests ---------------------------"

	SUSP_FILES_INFO="
adore.o:Adore%%LKM%%rootkit
mod_rootme.so:Apache%%mod_rootme%%backdoor
phide_mod.o:PID%%hider%%LKM
lbk.ko:LBK%%FreeBSD%%kernel%%module
vlogger.o:THC-Vlogger%%kernel%%module
cleaner.o:Cleaner%%kernel%%module
mod_klgr.o:klgr,%%keyboard%%logger%%(kernel%%module)
hydra:THC-Hydra%%(password%%capture)
hydra.restore:THC-Hydra%%(password%%capture)
"

	displaytext -n "   Testing running processes... "
	logtext -n "Scanning running processes... "
	SIZE="30"
	jump=`expr ${defaultcolumn} - ${SIZE}`

	if [ -n "${LSOF_CMD}" ]; then
		SUSP_FILES="backdoor"
		# Add more suspicious files to the check
		for I in ${SUSP_FILES_INFO}; do
			FILENAME=`echo ${I} | cut -d':' -f1 | sed -e 's/\./\\\./g'`
			SUSP_FILES="${SUSP_FILES}|${FILENAME}"
		done
		SEARCHFILES=`${LSOF_CMD} -F n -w | sort | uniq | grep '^n/' | sed -e 's/^n//' | egrep "/(${SUSP_FILES})$"`
		if [ ! "${SEARCHFILES}" = "" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}BAD${NORMAL} ]"
			logtext --nodate "Bad"
			logtext "Warning! Found possible harmful files. Please inspect"
			logtext "Warning! Output of test: ${SEARCHFILES}"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			logtext --nodate "OK"
		fi
		SUSP_FILES=`echo "${SUSP_FILES}" | sed -e 's/\\\././g'`
		logtext "Scanned for '${SUSP_FILES}'"
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${YELLOW}Skipped${NORMAL} ]"
		logtext --nodate "Skipped"
	fi

	UNHIDE_CMD=`find_cmd unhide`
	if [ -n "${UNHIDE_CMD}" ]; then
		logtext -n "Scanning hidden processes... "
		SIZE="30"
		jump=`expr ${defaultcolumn} - ${SIZE}`

		UNHIDEPROCS=`${UNHIDE_CMD} sys | grep '^F' | awk -F':' '{ print $2 }'`
		if [ -n "${UNHIDEPROCS}" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}BAD${NORMAL} ]"
			logtext --nodate "Bad"
			logtext "Warning! Hidden PIDs found: ${UNHIDEPROCS}"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			logtext --nodate "OK"
		fi

		logtext "Scanned for hidden processes"
	fi

	if [ $CHKDEL -eq 1 ]; then
		displaytext -n "   Checking processes for deleted files... "
		logtext -n "Scanning processes for deleted files... "
		SIZE="41"
		jump=`expr ${defaultcolumn} - ${SIZE}`

		if [ -n "${LSOF_CMD}" ]; then
			STATUS=0
			WHITEPROC=""; BLACKPROC=""
			SEARCHFILES=`${LSOF_CMD} -n -l -w | grep "(dele" | head -n 1`
			if [ ! "${SEARCHFILES}" = "" ]; then
				PMATCH=1; PIDLIST=""
				OLDIFS=$IFS
				IFS="
"
				for line in `${LSOF_CMD} -n -l -w | grep "(dele"`; do
					lproc=`echo $line | awk '{ print $1 }'`
					lpid=`echo $line | awk '{ print $2 }'`
					l8=`echo $line | awk '{ print $8 }'`
					lfile=`echo $line | awk '{ print $9 }'`
					for i in $PIDLIST; do
						i=`echo $i | cut -d' ' -f1`
						if [ $lpid -eq $i ]; then
							PMATCH=0
						fi
					done
					if [ $PMATCH -eq 1 ]; then
						if [ -n "${READLINK_CMD}" ]; then
							if [ "${OPERATING_SYSTEM}" != "SunOS" -o -h /proc/${lpid}/exe ]; then
								lproc=`${READLINK_CMD} /proc/${lpid}/exe`
							fi
						fi
						# If $lfile is not a pathname then look at $l8
						if [ -z "`echo ${lfile} | grep '^/'`" ]; then
							if [ -n "`echo ${l8} | grep '^/'`" ]; then
								lfile=${l8}
							fi
						fi
						# Remove anything after the pathname
						if [ -n "`echo ${lfile} | grep '^/'`" ]; then
							lfile=`echo ${lfile} | cut -f1 -d' '`
						fi
						ALLOWPROCDELFILES=`grep '^ALLOWPROCDELFILE=' ${CONFIGFILE} | sed -e 's/ALLOWPROCDELFILE=//g'`
						FMATCH=1
						for i in $ALLOWPROCDELFILES; do
							if [ "$lproc" = "$i" ]; then
								FMATCH=0; break
							fi
						done
						if [ -z "${READLINK_CMD}" ]; then
							lproc="\"$lproc\""
						fi
						if [ $FMATCH -eq 0 ]; then
							if [ -z "`echo ${WHITEPROC} | egrep \"${lproc}( |$)\"`" ]; then
								WHITEPROC="${WHITEPROC} ${lproc}"
							fi
						else
							STATUS=1
							BLACKPROC="${BLACKPROC}\\n${lproc} ${lpid} ${lfile}"
						fi
					fi
					PIDLIST="$lpid $PIDLIST"
				done
				IFS=$OLDIFS
			fi

			insertlayout

			if [ $STATUS -eq 0 ]; then
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
				logtext --nodate "OK"
			else
				displaytext $E "${LAYOUT}[ ${RED}BAD${NORMAL} ]"
				logtext --nodate "Bad"
				logtext "Warning! Found deleted files in use. Please inspect:"

				echo $E $BLACKPROC \
				| while read lproc lpid lfile; do
					if [ -n "$lproc" ]; then
						logtext "Warning! Process ${lproc} (${lpid}) used deleted file ${lfile}"
						displaytext "Warning! Process ${lproc} (${lpid}) used deleted file ${lfile}"
					fi
				done
			fi

			for lproc in $WHITEPROC; do
				logtext "Found process ${lproc} on whitelist"
			done

			logtext "Scanned for deleted files"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${YELLOW}Skipped${NORMAL} ]"
			logtext --nodate "Skipped"
		fi
	fi # end CHKDEL


	logtext "----------------------- Login backdoors check -------------------------"


	# Miscellaneous Login backdoors

	STATUS=0
	SIZE=30

	displaytext -n "   Miscellaneous Login backdoors"

	for I in ${LOGIN_BACKDOORS_FILES}; do
		if [ -d ${I} ]; then
			STATUS=1
			logtext "${I} found! Possible part of a rootkit/trojan."
		else
			logtext "${I} clean"
		fi
	done

	if [ ${STATUS} -eq 0 ]; then
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
	else
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
	fi

#	STATUS=0
#	SIZE=17
#	echo -n "   Suspicious files"
#
#	for I in ${SUSPICIOUS1_FILES}; do
#		J=`echo ${I} | cut -d ':' -f1`
#		FINDFILE=`locate -i /${J}`
#		if [ ! "${FINDFILE}" = "" ]; then
#			echo ${FINDFILE}
#			STATUS=1
#			logtext "${J} found! Possible part of a rootkit/trojan."
#			FOUNDFILES="${FOUNDFILES}, "
#		else
#			logtext "${J} clean"
#		fi
#	done
#
#	if [ ${STATUS} -eq 0 ]; then
#		jump=`expr ${defaultcolumn} - ${SIZE}`
#		insertlayout
#		echo $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
#	else
#		jump=`expr ${defaultcolumn} - ${SIZE}`
#		insertlayout
#		echo $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
#		echo "Found files:"
#		echo "${FOUNDFILES}"
#	fi

	STATUS=0
	SIZE=26

	displaytext -n "   Miscellaneous directories"

	for I in ${SUSPICIOUS1_DIRS}; do
		logtext -n "Checking ${I}... "
		if [ -f ${I} ]; then
			STATUS=1
			logtext --nodate "[ WARNING! ] Possible part of a rootkit/trojan."
		else
			logtext --nodate "[ OK ] Not found"
		fi
	done

	if [ ${STATUS} -eq 0 ]; then
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
	else
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
	fi

	# Software related files

	STATUS=0
	SIZE=23
	FOUND=0

	displaytext -n "   Software related files"
	logtext "Scanning for software related files and intrusions..."

	TRIPWIREFILE="${ROOTDIR}var/lib/tripwire/`uname -n`.twd"

	if [ -f "${TRIPWIREFILE}" ]; then
		FOUND=1
		if [ -z "`grep 'Tripwire segment-faulted !' ${TRIPWIREFILE}`" ]; then
			jump=`expr ${defaultcolumn} - ${SIZE}`
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		else
			jump=`expr ${defaultcolumn} - ${SIZE}`
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}BAD${NORMAL} ]"
			logtext "The file ${TRIPWIREFILE} contains a very suspicious text string, which"
			logtext "can indicate the presence of the SHV5 rootkit."
		fi
	fi

	# No traces found
	if [ ${FOUND} -eq 0 ]; then
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
	fi



	# Sniffer logs

	STATUS=0
	SIZE=13

	displaytext -n "   Sniffer logs"

	for I in ${SNIFFER_FILES}; do
		logtext -n "Checking ${I}... "
		if [ -f ${I} ]; then
			STATUS=1
			logtext --nodate "[ WARNING! ] Possible sniffer log found."
		else
			logtext --nodate "[ OK ] Not found"
		fi
	done

	if [ ${STATUS} -eq 0 ]; then
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
	else
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
	fi

	keypresspause

	displaytext ""
	displaytext "${test}* Trojan specific characteristics${NORMAL}"

	displaytext "   shv4"

	SIZE="32"
	jump=`expr ${defaultcolumn} - ${SIZE}`
	if [ "${OPERATING_SYSTEM}" = "AIX" ]; then
		RCFILE="/etc/inittab"
	else
		RCFILE="/etc/rc.d/rc.sysinit"
	fi
	displaytext -n "     Checking ${RCFILE}"
	if [ -f ${RCFILE} ]; then
		# Insert end-of-line
		displaytext ""
		SIZE="11"
		jump=`expr ${defaultcolumn} - ${SIZE}`

		displaytext -n "       Test 1"
		if [ -n "`grep 'in\.inetd' ${RCFILE}`" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}Clean${NORMAL} ]"
		fi

		displaytext -n "       Test 2"
		if [ "`grep 'bin/xchk' ${RCFILE}`" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (possible Optic Kit / Tuxkit) ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}Clean${NORMAL} ]"
		fi

		displaytext -n "       Test 3"
		if [ "`grep 'bin/xsf' ${RCFILE}`" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (possible Optic Kit / Tuxkit) ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}Clean${NORMAL} ]"
		fi
		
		if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
			displaytext -n "       Test 4"
			if [ "`grep '.*#<HIDE_.*>' ${RCFILE}`" ]; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (possible ENYELKM) ]"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}Clean${NORMAL} ]"
			fi
		fi
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}Not found${NORMAL} ]"
	fi

	SIZE="27"
	jump=`expr ${defaultcolumn} - ${SIZE}`
	displaytext -n "     Checking /etc/inetd.conf"

	if [ -f /etc/inetd.conf ]; then
		FOUND=0
		if [ -e /etc/inetd.conf ]; then
			grep '/bin/csh' /etc/inetd.conf >/dev/null && FOUND=1
			grep '/bin/bash' /etc/inetd.conf >/dev/null && FOUND=1
			grep '/bin/tcsh' /etc/inetd.conf >/dev/null && FOUND=1
			grep '/bin/ksh' /etc/inetd.conf >/dev/null && FOUND=1
			grep '/bin/bash' /etc/inetd.conf >/dev/null && FOUND=1
			grep '/bin/sh' /etc/inetd.conf >/dev/null && FOUND=1
			grep '/bin/ash' /etc/inetd.conf >/dev/null && FOUND=1
			grep '/bin/zsh' /etc/inetd.conf >/dev/null && FOUND=1
			grep 'in\.cfinger' /etc/inetd.conf >/dev/null && FOUND=1
		fi

		if [ ${FOUND} -eq 1 ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
			logtext "Possible bad string found in /etc/inetd.conf. Please check this file manually."
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}Clean${NORMAL} ]"
		fi
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}Not found${NORMAL} ]"
	fi


	SIZE="28"
	jump=`expr ${defaultcolumn} - ${SIZE}`
	displaytext -n "     Checking /etc/xinetd.conf"

	# Only check when operating system is Linux and we have a xinetd configuration
	if [ "${OPERATING_SYSTEM}" = "Linux" -a -f /etc/xinetd.conf ]; then
		FOUND=0
		logtext "Operating system is Linux and /etc/xinetd.conf found. Starting xinetd configuration scan..."

		incl=`grep 'includedir' /etc/xinetd.conf | cut -d" " -f2-`
		if [ -n "$incl" ]; then
			I=`find $incl/ -type f`
			WARNINGMSG=""
			for J in ${I}; do
				svc=`grep ".*service." ${J} | grep -v "^#" | cut -d" " -f2-`
				FOUNDSERVICES=`grep ".*disable.*=.*yes" ${J} | grep -v "#"`
				if [ "${FOUNDSERVICES}" = "" ]; then
					logtext "Info: Service ${J} enabled"
				fi
			done
		fi
		if [ ${FOUND} -eq 0 ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}Clean${NORMAL} ]"
			logtext "xinetd.conf seems to be clean"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
			displaytext "${WARNINGMSG}"
			logtext "There were warnings found while testing xinetd.conf"
		fi

		logtext "End of xinetd configuration scan"
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}Skipped${NORMAL} ]"
		logtext "Skipped xinetd tests (not Linux or file doesn't exists)"
	fi

	displaytext ""
	displaytext "${test}* Suspicious file properties${NORMAL}"

	displaytext "   ${WHITE}chmod properties${NORMAL}"

	FILES="
${ROOTDIR}bin/ps
${ROOTDIR}bin/ls
${ROOTDIR}usr/bin/w
${ROOTDIR}usr/bin/who
${ROOTDIR}bin/netstat
${ROOTDIR}usr/bin/netstat
${ROOTDIR}bin/login
"

	for I in ${FILES}; do
		# Calculate string length
		SIZE=`echo "${I}" | wc -c | tr -d ' '`
		SIZE=`expr ${SIZE} + 11`
		jump=`expr ${defaultcolumn} - ${SIZE}`
		if [ -f ${I} ]; then
			displaytext -n "     Checking ${I}"
			RIGHTS=`ls -l ${I} | cut -c 1-10`
			if [ "${RIGHTS}" = "-rwxrwxrwx" ]; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (chmod 777 found, possible trojaned) ]"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}Clean${NORMAL} ]"
			fi
		else
			logtext "Checking ${I}... Not found"
		fi
	done

	displaytext "   ${WHITE}Script replacements${NORMAL}"

	for I in ${FILES}; do
		# Calculate string length
		SIZE=`echo "${I}" | wc -c | tr -d ' '`
		SIZE=`expr ${SIZE} + 11`
		jump=`expr ${defaultcolumn} - ${SIZE}`
		if [ -f ${I} ]; then
			displaytext -n "     Checking ${I}"
			FILEOK=true
			case "${OPERATING_SYSTEM}" in
			AIX)
				file ${I} | grep -q "shell script" && FILEOK=false
				;;
			SunOS)
				file ${I} | grep "shell script" >/dev/null 2>&1 && FILEOK=false
				;;
			*)
				file -b ${I} | grep -q "shell script" && FILEOK=false
				;;
			esac

			if ! $FILEOK; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
				displaytext "(script replacement found, possible trojaned)"
				logtext "Checking ${I}... [ WARNING ]"
				logtext "Possible script replacement found. Please inspect this file (check the file type, contents and size)"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}Clean${NORMAL} ]"
				logtext "Checking ${I}... [ OK ]"
			fi
		else
			logtext "Checking ${I}... Not found"
		fi
	done


	displaytext ""
	displaytext "${test}* OS dependent tests${NORMAL}"

	if [ "${OPERATING_SYSTEM}" = "FreeBSD" ]; then
		displaytext "   ${WHITE}FreeBSD${NORMAL}"
		SIZE=38
		jump=`expr ${defaultcolumn} - ${SIZE}`
		displaytext -n "     Checking presence of KLD signatures"
		STATUS=0

		for I in ${KLDSTATKEYWORDS}; do
			FNAME=`echo "${I}" | sed -e 's/\./\\\./g'`
			PRESENCE=`kldstat -v | grep "${FNAME}"`
			if [ ! "${PRESENCE}" = "" ]; then
				STATUS=1
				FOUNDKEYS="${FOUNDKEYS}${I} "
			fi
		done

		if [ "${STATUS}" -eq 1 ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (found terms: ${FOUNDKEYS}) ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		fi

		logtext "--------------------- Netstat / Sockstat checks -----------------------"

		SIZE=40
		jump=`expr ${defaultcolumn} - ${SIZE}`

		displaytext -n "     Comparing output sockstat and netstat"
		logtext -n "Comparing output of sockstat and netstat... "
		SOCKSTAT=`sockstat | grep '*:*' | cut -c 1-55 | grep '*:' | cut -c 39-47 | tr -d ' ' | sort| grep -v '*' | uniq`
		NETSTAT=`netstat -an | grep -v 'TIME_WAIT' | grep -v 'ESTABLISHED' | grep -v 'SYN_SENT' | grep -v 'CLOSE_WAIT' | grep -v 'LAST_ACK' | grep -v 'SYN_RECV' | grep -v 'CLOSING' | cut -c 1-44 | grep '*.' | cut -c 24-32 | tr -d ' ' | tr -d '\t' | grep -v '*' | sort | uniq`

		if [ "${SOCKSTAT}" = "${NETSTAT}" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			logtext --nodate "OK"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
			logtext --nodate "WARNING!"
			logtext "Sockstat tested output: ${SOCKSTAT}"
			logtext "Netstat tested output: ${NETSTAT}"
		fi

		logtext "---------------------- Packages database check ------------------------"


		if [ -f /usr/local/sbin/pkgdb ]; then
			SIZE=29
			jump=`expr ${defaultcolumn} - ${SIZE}`
			displaytext -n "     Checking packages database"

			RESULT=`/usr/local/sbin/pkgdb -Fa -v | grep "Skipped\."`

			if [ "${RESULT}" = "" ]; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
				logtext "OK"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${YELLOW}Please check${NORMAL} ]"
				logtext "Your package databases seems to have inconsistenties. Please run pkgdb -F to"
				logtext "do manually checking. Although this isn't a security issue, you need to be sure"
				logtext "your applications are using the correct dependencies"
			fi
		fi

#		KLDLOADS=`grep -r 'kldload' /etc/*`
#	    for I in "${KLDLOADS}"; do
#			echo "${I}"
#	    done
	fi

	if [ ${OPERATING_SYSTEM} = "Linux" ]; then
		temp1=""; temp2=""
		displaytext ""
		displaytext "   ${WHITE}Linux${NORMAL}"

		SIZE=37
		jump=`expr ${defaultcolumn} - ${SIZE}`

		displaytext -n "     Checking loaded kernel modules... "

		# Is /proc/modules file available?

		temp1=""; temp2=""
		if [ -f /proc/modules -a -n "${LSMOD_CMD}" ]; then
			if [ "${KERNELVERSION}" = "2.2" -o "${KERNELVERSION}" = "2.4" ]; then
				# show information found in /proc/modules (Linux-only) and get rid of the spaces
				temp1=`cat /proc/modules | sort | tr -d ' '`

				# show output from lsmod. Throw away spaces, because they don't match the content
				# of /proc/modules
				temp2=`${LSMOD_CMD} | grep -v "Size  Used by" | sort | tr -d ' '`
			else
				if [ "${KERNELVERSION}" = "2.6" ]; then
					temp1=`cat /proc/modules | sort | tr -s ' ' | cut -d " " -f1`
					temp2=`${LSMOD_CMD} | grep -v "Size  Used by" | sort | tr -s ' ' | cut -d " " -f1`
				fi
			fi
		fi

		if [ -n "${temp1}" ]; then
			if [ "${temp1}" = "${temp2}" ]; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (found difference in output) ]"
			fi
		else
			displaytext "${WHITE}Skipped!${NORMAL}"
			if [ -n "${LSMOD_CMD}" ]; then
				logtext "Info: no /proc/modules found. Lsmod test skipped"
			else
				logtext "Info: no 'lsmod' command found. Lsmod test skipped"
			fi
		fi

#		displaytext -n "   Checking all kernelmodules..."

#		SCANFILES=`grep '.o' ${SCANFILELIST}`
#		for J in ${SCANFILES}; do

#		FOUNDSIGN=0

#		Search strings in file
#		If we find something, we tell it after the last string
#		(multiple strings will overwrite each other)
#		for I in ${LKMSTRINGS}; do
#			SEARCHSTRING=`echo ${I} | cut -d ':' -f1`
#			TYPE=`echo ${I} | cut -d ':' -f2`
#			INFO=`echo ${I} | cut -d ':' -f3`
#			if [ -f ${J} ]; then
#				FOUND=`strings ${J} | egrep '${SEARCHSTRING}'`
#			else
#				# File not found, no strings returned
#				FOUND=""
#			fi
#			if [ ! "${FOUND}" = "" ]; then
#				FOUNDSIGN=1
#				FOUNDSTRING=${FOUND}
#				FOUNDTYPE=${TYPE}
#				FOUNDINFO=${INFO}
#				echo "Found: ${FOUND}"
#			fi
#		done

#			if [ ${FOUNDSIGN} -eq 1 ]; then
#				displaytext "     Scanning ${J}"
#				displaytext "Warning, found a possible ${FOUNDTYPE}"
#				displaytext "Searchstring '${FOUNDSTRING}' founded in '${SEARCHSTRING}'"
#				displaytext "Extra info: ${FOUNDINFO}"
#				waitkeypress
#			else
#				logtext "Scanning ${J}... [ Clean ]"
#			fi
#		done


		logtext "--------------------------- File attributes ---------------------------"

		SIZE=27
		displaytext -n "     Checking file attributes"
		jump=`expr ${defaultcolumn} - ${SIZE}`

		FOUND=0

		if [ -n "${LSATTR_CMD}" ]; then
			for I in ${BINPATHS}; do
				logtext "Checking $I file attributes"
				if [ -d ${I} ]; then
					for J in `ls ${I}`; do
						LSAT=`${LSATTR_CMD} ${I}/${J} 2>/dev/null | cut -d' ' -f1 | grep 'i'`
						if [ -n "${LSAT}" ]; then
							FOUND=1
							logtext "Found 'immutable' binary (${I}/${J})"
						fi
					done
				fi
			done
			if [ ${FOUND} -eq 0 ]; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${YELLOW}Special attributes found!${NORMAL} ]"
				logtext "Found special attributes on some binaries! This can be performed by security software OR"
				logtext "by a rootkit. Please inspect these files and try to find the reason of this immutable flag."
				logtext "See 'man chattr' for more information about this attributes."
			fi
		else
			insertlayout
			displaytext $E "   ${file}${LAYOUT}[ ${WHITE}Skipped!${NORMAL} ]"
		fi


		logtext "----------------------------- LKM modules -----------------------------"

		LKM_BADNAMES="
adore.o
cleaner.o
flkm.o
phide_mod.o
vlogger.o
"

		LKMPATH="/lib/modules/`uname -r`"
		FOUND=0


		SIZE=27
		displaytext -n "     Checking LKM module path"
		jump=`expr ${defaultcolumn} - ${SIZE}`

		if [ -d ${LKMPATH} -a -n "${FIND_CMD}" ]; then
			for J in `${FIND_CMD} ${LKMPATH} -name "*.o" -print`; do
				for I in ${LKM_BADNAMES}; do
					FNAME=`echo "${I}" | sed -e 's/\./\\\./g'`
					if [ ! "`echo ${J} | grep \"/${FNAME}\$\"`" = "" ]; then
						logtext "Warning, possible malicious LKM (filename: ${J} string: ${I}) installed!"
						FOUND=1
					#else
					#	logtext "Checking ${I} in ${J}... Not found"
					fi
				done
			done

			if [ ${FOUND} -eq 0 ]; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
			fi
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${WHITE}Skipped!${NORMAL} ]"
			if [ -n "${FIND_CMD}" ]; then
				logtext "LKM module filename check skipped, because path (${LKMPATH}) doesn't exist"
			else
				logtext "LKM module filename check skipped, because 'find' command doesn't exist"
			fi
		fi

		# End Linux tests
	fi

	logtext "------------------------------- Backdoors -----------------------------"


	displaytext ""; displaytext ""
	displaytext "${YELLOW}Networking${NORMAL}"

	displaytext "${test}* Check: frequently used backdoors${NORMAL}"

	if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
		donetstat="1"
	fi
	if [ "${OPERATING_SYSTEM}" = "FreeBSD" ]; then
		donetstat="1"
	fi
	if [ "${OPERATING_SYSTEM}" = "AIX" ]; then
		donetstat="1"
	fi
	if [ "${OPERATING_SYSTEM}" = "SunOS" ]; then
		donetstat="1"
	fi

	# Skip tests when GRSEC is available (because of the locking of /proc/*)
	if [ ${GRSECINSTALLED} -eq 1 ]; then
		donetstat="0"
	fi

	if [ "${donetstat}" = "1" ]; then
		for i in `cat ${DB_PATH}/backdoorports.dat`; do
			port=`echo ${i} | cut -d ':' -f 1`
			DESCRIPTION=`echo ${i} | cut -d ':' -f 2`
			DESCRIPTION=`echo ${DESCRIPTION} | sed -e 's/%%/ /g'`

			if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
				checkport=`netstat -an | grep "LISTEN" | grep ":${port} "`
			fi

			if [ "${OPERATING_SYSTEM}" = "FreeBSD" -o "${OPERATING_SYSTEM}" = "AIX" -o "${OPERATING_SYSTEM}" = "SunOS" ]; then
				checkport=`netstat -an | grep "LISTEN" | grep "\.${port} "`
			fi

			SIZE=`echo "   ${port}: ${DESCRIPTION} " | wc -c | tr -d ' '`
			jump=`expr ${defaultcolumn} - ${SIZE}`
			displaytext -n "  Port ${port}: ${DESCRIPTION}"

			if [ "${checkport}" = "" ]; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (possible trojan port) ]"
			fi
		done
	else
		displaytext "${YELLOW}Not tested"
		if [ ${GRSECINSTALLED} -eq 1 ]; then
			logtext "Backdoor ports test skipped, due to customized kernel (GRSEC)"
		fi
	fi

	displaytext ""
	displaytext "${test}* Interfaces${NORMAL}"

	SIZE=41
	jump=`expr ${defaultcolumn} - ${SIZE}`

	displaytext -n "     Scanning for promiscuous interfaces..."
	LOGTEXT="Checking network interfaces (promiscuous mode)... "

	PROMISCSCAN1=""; PROMISCSCAN2=""

	if [ "${OPERATING_SYSTEM}" = "OpenBSD" -o "${OPERATING_SYSTEM}" = "AIX" ]; then
		PROMISCSCAN1=`${IFCONFIG_CMD} -a 2>/dev/null | grep -v 'pflog' | grep 'PROMISC'`
	elif [ "${OPERATING_SYSTEM}" = "SunOS" -o "${OPERATING_SYSTEM}" = "NetBSD" ]; then
		PROMISCSCAN1=`${IFCONFIG_CMD} -a 2>/dev/null | grep 'PROMISC'`
	else
		PROMISCSCAN1=`${IFCONFIG_CMD} 2>/dev/null | grep 'PROMISC'`
	fi

	if [ "${OPERATING_SYSTEM}" = "Linux" -a -n "${IP_CMD}" ]; then
		PROMISCSCAN2=`${IP_CMD} -s link | grep 'PROMISC'`
	fi

	if [ "${PROMISCSCAN1}" = "" -a "${PROMISCSCAN2}" = "" ]; then
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		logtext "${LOGTEXT}[ OK ]"
		if [ "${OPERATING_SYSTEM}" = "Linux" -a -n "${IP_CMD}" ]; then
			logtext "Performed successful test with 'ip' command"
		fi
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
		displaytext "Warning! Found promiscuous interface. Please check the logfile."
		logtext "${LOGTEXT}[ WARNING ]"
		logtext "Possible promisc interfaces:"
		logtext "Output test 1: ${PROMISCSCAN1}"
		if [ "${OPERATING_SYSTEM}" = "Linux" -a -n "${PROMISCSCAN2}" ]; then
			PROMISCSCAN2IFACES=`${IP_CMD} -s link | grep 'PROMISC' | cut -d ":" -f2`
			for if in $PROMISCSCAN2IFACES ; do
				logtext "Output test 2: $if in promiscuous mode"
			done
		fi
	fi

	SKIPNEXT=0
	if [ "${OPERATING_SYSTEM}" != "Linux" ]; then
		SKIPNEXT=1
	fi
	if [ -z "${LSOF_CMD}" ]; then
		SKIPNEXT=1
	fi
	if [ ! -f "/proc/net/packet" ]; then
		SKIPNEXT=1
	fi

	if [ "$SKIPNEXT" -eq 0 -a $CHKLISTEN -eq 1 ]; then
		STATUS=0
		WHITEPROC=""; BLACKPROC=""
		SIZE=48
		jump=`expr ${defaultcolumn} - ${SIZE}`

		displaytext -n "     Scanning for packet capturing applications..." # libpcap, raw
		logtext -n "Checking for packet capturing applications... "
		LIBPCAPRES=`egrep -v "^sk|888e" /proc/net/packet | cut -c 1`
		if [ -n "${LIBPCAPRES}" ]; then
			for inode in `egrep -v "^sk|888e" /proc/net/packet | awk '{print $9}'`; do
				for pid in `${LSOF_CMD} -lMnP | grep "$inode" | awk '{print $2}'`; do
					if [ -n "${READLINK_CMD}" ]; then
						name=`${READLINK_CMD} -f /proc/$pid/exe`
					else
						name=`grep "^Name:." /proc/$pid/status | sed -e 's/^Name:.//'`
					fi
					ALLOWPROCLISTENERS=`grep '^ALLOWPROCLISTEN=' ${CONFIGFILE} | sed -e 's/ALLOWPROCLISTEN=//g'`
					AMATCH=1
					for i in $ALLOWPROCLISTENERS; do
						if [ "$name" = "$i" ]; then
							AMATCH=0; break
						fi
					done
					if [ "$AMATCH" -eq "0" ]; then
						FNAME=`echo "${name}" | sed -e 's/\./\\\./g'`
						if [ -z "`echo ${WHITEPROC} | egrep \"${FNAME}( |$)\"`" ]; then
							WHITEPROC="${WHITEPROC} ${name}"
						fi
					else
						STATUS=1
						BLACKPROC="${BLACKPROC}\\n${name} ${pid}"
					fi
				done
			done
		fi

		insertlayout

		if [ $STATUS -eq 0 ]; then
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			logtext --nodate "OK"
		else
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
			displaytext "Warning! Found packet capturing application. Please check the logfile."

			logtext --nodate "Warning"
			echo $E $BLACKPROC | \
			while read name pid; do
				if [ -n "$name" ]; then
					logtext "Warning! Process ${name} (${pid}) listening"
				fi
			done
		fi

		for name in $WHITEPROC; do
			logtext "Found process ${name} on whitelist"
		done
	fi


	keypresspause


##################################################################################################
#
# System checks
#
##################################################################################################


	logtext "---------------------------- System checks ----------------------------"

	displaytext ""; displaytext ""
	displaytext "${YELLOW}System checks${NORMAL}"

	displaytext "${test}* Allround tests${NORMAL}"

	displaytext -n "   Checking hostname... "
	if [ "${HOST_NAME}" = "" ]; then
		displaytext "${RED}Warning. ${NORMAL}Found empty hostname. Some programs don't like this."
	else
		displaytext "${GREEN}Found. ${NORMAL}Hostname is ${HOST_NAME}"
	fi

	##################################################################################################

	FOUND=0
	SIZE=49
	jump=`expr ${defaultcolumn} - ${SIZE}`
	displaytext -n "   Checking for passwordless user accounts... "
	logtext "Checking for passwordless user accounts... "
	if [ -e "/etc/shadow" ]; then
		for I in `cat /etc/shadow`; do
			USER=`echo "${I}" | cut -d ':' -f1`
			PASSWORD=`echo "${I}" | cut -d ':' -f2`
			# Exclude NIS-user (+::::::)
			if [ ! "${USER}" = "+" -a "x${PASSWORD}x" = "xx" ]; then
				FOUND=1
				logtext "Warning! Found passwordless account (${USER})"
				logtext "Check this account and give it a password."
			fi
		done
		if [ ${FOUND} -eq 0 ]; then
			displaytext "${GREEN}OK${NORMAL}"
		else
			displaytext "${RED}Warning!${NORMAL}"
			displaytext "Found passwordless user account. Check the logfile for more information"
			logtext --nodate "OK"
		fi
	else
		insertlayout
		displaytext "${WHITE}Skipped${NORMAL}"
		logtext --nodate "Skipped"
		logtext "Skipped test because /etc/shadow doesn't exist"
	fi

	##################################################################################################


	if [ $SKIP_PASSWDCHECK -eq 0 ]; then
		displaytext -n "   Checking for differences in user accounts... "
		if [ -e "/etc/passwd" ]; then
			if [ -e "${TMPDIR}/passwd" ]; then
				differences=`diff /etc/passwd ${TMPDIR}/passwd | grep ":"`
				if [ "${differences}" = "" ]; then
					displaytext "${GREEN}OK. ${NORMAL}No differences."
				else
					diffadded=`echo "${differences}" | grep "<"`
					diffremoved=`echo "${differences}" | grep ">"`
					displaytext "${RED}Found differences${NORMAL}"
					displaytext "   Info: "
					displaytext "----------------------"
					displaytext "${differences}"
					displaytext "----------------------"
					if [ ! "${diffadded}" = "" ]; then
						displaytext "   Info: Some items have been added (items marked with '<')"
					fi
					if [ ! "${diffremoved}" = "" ]; then
						displaytext "   Info: Some items have been removed (items marked with '>')"
					fi
				fi
				rm -f ${TMPDIR}/passwd
			else
				jump=44
				displaytext $E "${LAYOUT}[ ${YELLOW}NA${NORMAL} ]"
			fi
			cp /etc/passwd ${TMPDIR}/passwd
		else
			displaytext "${RED}Error. ${NORMAL}Cannot find /etc/passwd"
			logtext "Can't find /etc/passwd file?!?"
		fi

		displaytext -n "   Checking for differences in user groups... "
		if [ -e "/etc/group" ]; then
			if [ -e "${TMPDIR}/group" ]; then
				differences=`diff /etc/group ${TMPDIR}/group | grep ":"`
				if [ "${differences}" = "" ]; then
					displaytext "${GREEN}OK. ${NORMAL}No differences."
				else
					diffadded=`echo "${differences}" | grep "<"`
					diffremoved=`echo "${differences}" | grep ">"`
					displaytext "${RED}Found differences${NORMAL}"
					displaytext "   Info: "
					displaytext "----------------------"
					displaytext "${differences}"
					displaytext "----------------------"
					if [ ! "${diffadded}" = "" ]; then
						displaytext "   Info: Some items have been added (items marked with '<')"
					fi
					if [ ! "${diffremoved}" = "" ]; then
						displaytext "   Info: Some items have been removed (items marked with '>')"
					fi
				fi
				rm -f ${TMPDIR}/group
			else
				displaytext "${YELLOW}Creating file ${NORMAL}It seems this is your first time."
			fi
			cp /etc/group ${TMPDIR}/group
		else
			displaytext "${RED}Error. ${NORMAL}Cannot find /etc/group"
			logtext "Can't find /etc/group file?!?"
		fi
	fi

	SIZE=42
	jump=`expr ${defaultcolumn} - ${SIZE}`
	displaytext "   Checking boot.local/rc.local file... "

	# Gentoo: /etc/conf.d/local.start
	RCLOCATIONS="/etc/rc.local /etc/rc.d/rc.local /usr/local/etc/rc.local /usr/local/etc/rc.d/rc.local /etc/conf.d/local.start /etc/init.d/boot.local"
	FOUNDRCSIGN=0

	for FILE in ${RCLOCATIONS}; do
		FILELENGTH=`echo ${FILE} | wc -c | tr -d ' '`
		SIZE=4
		jump=`expr ${defaultcolumn} - ${SIZE} - ${FILELENGTH}`

		displaytext -n "     - ${FILE}"
		if [ -f "${FILE}" ]; then
			for J in ${RCLOCAL_STRINGS}; do
				STRING=`echo ${J} | cut -d':' -f1 | sed -e 's/\./\\\./g'`
				FOUND=`grep "${STRING}" ${FILE}`
				if [ ! "${FOUND}" = "" ]; then
					FOUNDRCSIGN=1
					logtext "Warning! Found unusual string in ${FILE}"
				fi
			done

			if [ "${FOUNDRCSIGN}" -eq 1 ]; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (found unusual signs) ]"
				logtext "Warning! Found unusual string in rc.local/boot.local file"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			fi
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}Not found${NORMAL} ]"
		fi
	done

	FOUNDRCSIGN=0
	COUNTER=0

	SIZE=24
	jump=`expr ${defaultcolumn} - ${SIZE}`
	displaytext -n "   Checking rc.d files... "

	if [ -d /etc/rc.d ]; then
		# Insert end-of-line
		displaytext ""
		displaytext -n "     Processing"
		for I in `find /etc/rc.d/*`; do
			# Only check files, not directories
			if [ -f ${I} ]; then
				COUNTER=`expr ${COUNTER} + 1`
				if [ ${COUNTER} -eq 40 ]; then
					displaytext "."
					displaytext -n "               "
					COUNTER=0
				else
					displaytext -n "."
				fi
				for J in ${RCLOCAL_STRINGS}; do
					STRING=`echo ${J} | cut -d':' -f1 | sed -e 's/\./\\\./g'`
					FOUND=`grep "${STRING}" ${I}`
					if [ ! "${FOUND}" = "" ]; then
						FOUNDRCSIGN=1
					fi
				done
			fi
		done

		# Insert end-of-line
		displaytext ""
		displaytext -n "   Result rc.d files check"
		if [ "${FOUNDRCSIGN}" -eq 1 ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (found unusual things) ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		fi
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}Not found${NORMAL} ]"
	fi

	if [ -f ${ROOTDIR}etc/conf.d/local.start ]; then
		SIZE=37
		jump=`expr ${defaultcolumn} - ${SIZE}`
		displaytext -n "   Checking Gentoo local.start file... "
		logtext "Found ${ROOTDIR}etc/conf.d/local.start file (Gentoo)"

		INSPECTLINES=`grep -v '^#' ${ROOTDIR}etc/conf.d/local.start | grep -v '^$'`

		for J in ${RCLOCAL_STRINGS}; do
			STRING=`echo ${J} | cut -d':' -f1 | sed -e 's/\./\\\./g'`
			FOUND=`echo ${INSPECTLINES} | grep "${STRING}"`
			if [ ! "${FOUND}" = "" ]; then
				FOUNDRCSIGN=1
				logtext "Found ${FOUND} while checking ${ROOTDIR}etc/conf.d/local.start"
			fi
		done

		if [ "${FOUNDRCSIGN}" -eq 1 ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		fi
	fi

#	logtext "---------------------------- Binary checks ----------------------------"

#	SIZE=18
#	displaytext -n "   Checking binaries..."
#	jump=`expr ${defaultcolumn} - ${SIZE}`

#	if [ -n "${STRINGS_CMD}" ]; then
#		FOUND=0
#		for I in ${BINPATHS}; do

#			# Calculate string length
#			SIZE=`echo "${I}" | wc -c | tr -d ' '`
#			SIZE=`expr ${SIZE} + 7`
#			jump=`expr ${defaultcolumn} - ${SIZE}`

#			for J in ${I}; do
#				for K in `ls ${J}/*`; do
#					UPXED=`${STRINGS_CMD} ${K} | grep " UPX "`
#					logtext -n "Checking ${K}... "
#					if [ ! "${UPXED}" = "" ]; then
#						FOUND=1
#						logtext "BAD"
#						logtext "Warning: ${J} seems to be a UPXed file. This is not usual for a binary file"
#					else
#						logtext "OK"
#					fi
#				done
#			done
#		done

#		# Check results
#		if [ ${FOUND} -eq 1 ]; then
#			insertlayout
#			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
#			displaytext "Check the logfile for more information"
#		else
#			insertlayout
#			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
#		fi

#	else
#		insertlayout
#		displaytext $E "${LAYOUT}[ ${YELLOW}Skipped${NORMAL} ]"
#	fi

	logtext "---------------------------- History files ----------------------------"

	SIZE=15
	displaytext "   Checking history files"
	jump=`expr ${defaultcolumn} - ${SIZE}`

	displaytext -n "     Bourne Shell"

	if [ -f /root/.bash_history ]; then
		ATTRIBUTE=`ls -l /root/.bash_history | cut -c1`
		if [ "${ATTRIBUTE}" = "l" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (redirection found) ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		fi
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}Not Found${NORMAL} ]"
	fi

	displaytext ""
	displaytext "${test}* Filesystem checks${NORMAL}"
	displaytext -n "   Checking /dev for suspicious files... "

	if [ -d ${ROOTDIR}dev ]; then
		# FreeBSD (5): character special, symbolic link to,directory
		# Linux (Debian): block special, socket, fifo (named pipe)
		SPECIALFILES=`file "${ROOTDIR}dev/"* | egrep -v 'character special|block special|socket|fifo \(named pipe\)|symbolic link to|empty|directory|MAKEDEV'`

		SIZE=39
		jump=`expr ${defaultcolumn} - ${SIZE}`

		if [ "${SPECIALFILES}" = "" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (unusual files found) ]"
			displaytext "---------------------------------------------"
			displaytext "Unusual files:"
			displaytext "${SPECIALFILES}"
			displaytext "---------------------------------------------"
		fi
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${YELLOW}NA${NORMAL} ]"
	fi

	SIZE=29

	displaytext -n "   Scanning for hidden files..."

	SEARCHINDIRS="/dev /bin /usr /usr/man /usr/share/man /usr/man/man1 /usr/share/man/man1 /usr/man/man8 /usr/share/man/man8 /usr/bin /usr/sbin /sbin /etc"
	# Only reset status once
	STATUS=0

	for I in ${SEARCHINDIRS}; do
		# Initialize directory
		HIDDENDIRS=""

		logtext "Start scanning for hidden files in ${I}..."

		if [ -d "${I}" ]; then
			HIDDENDIRS=`${PERL_CMD} ${SCRIPT_PATH}/showfiles.pl ${I}`
			logtext "Value of hiddendirs: ${HIDDENDIRS}"
		fi

		if [ ! "${HIDDENDIRS}" = "" ]; then
			ALLHIDDENDIRS="${HIDDENDIRS} ${ALLHIDDENDIRS}"
			STATUS=1
		fi

		logtext "End of scanning ${I}"
	done

	if [ ${STATUS} -eq 0 ]; then
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
	else
		# Reset state
		STATUS=0
		for I in ${ALLHIDDENDIRS}; do
			if [ ${OPERATING_SYSTEM} = "AIX" -o ${OPERATING_SYSTEM} = "SunOS" ] ; then
				FILETYPE=`file ${I}|awk '{print $2}'`
			else
				FILETYPE=`file -b ${I}`
			fi

			# Ignore some filetypes, because they are harmless
			case ${FILETYPE} in
			"character special (8/0)" | "character special (254/0)" | "empty")
				logtext "Hidden file/dir ${I} [${FILETYPE}] seems to be OK"
				;;
			"TDB database"*)
				logtext "Hidden file/dir ${I} [${FILETYPE}] seems to be OK"
				;;
			*)
				# Ignore Gentoo's zero-sized files (extra check for future use)
				if [ ! ${GENTOO} -eq 1 -a ! "${I}" = ".keep" -a ! -z ${I} ]; then
					SEARCHDIR=0
					if [ "${FILETYPE}" = "directory" ]; then
						for ALLOWHIDDENDIRS in `grep '^ALLOWHIDDENDIR=' ${CONFIGFILE} | sed -e 's/ALLOWHIDDENDIR=//g'`; do
							if [ "${ALLOWHIDDENDIRS}" = "${I}" ]; then
								SEARCHDIR=1
								logtext "Found hidden directory ${I} on whitelist"
							fi
						done
					else
						for ALLOWHIDDENFILES in `grep '^ALLOWHIDDENFILE=' ${CONFIGFILE} | sed -e 's/ALLOWHIDDENFILE=//g'`; do
							if [ "${ALLOWHIDDENFILES}" = "${I}" ]; then
								SEARCHDIR=1
								logtext "Found hidden file ${I} on whitelist"
							fi
						done
					fi

					# Is it a directory and is it on the whitelist?
					# searchdir: 0 = NOT on list, 1 = on list
					if [ ${SEARCHDIR} -eq 0 ]; then
						STATUS=1
						HIDDENFILES="${HIDDENFILES} ${I} (${FILETYPE}) "
						logtext "Added ${I} (${FILETYPE}) to list of unknown hidden files/dirs"
					fi
				fi
				;;
			esac
		done

		if [ ${STATUS} -eq 1 ]; then
			jump=`expr ${defaultcolumn} - ${SIZE}`
			insertlayout
			displaytext $E "${LAYOUT}[ ${YELLOW}Warning!${NORMAL} ]"
			logtext "WARNING, found: ${HIDDENFILES}"

			displaytext "---------------"
			displaytext "${ALLHIDDENDIRS}"
			displaytext "---------------"

			displaytext "Please inspect: ${HIDDENFILES}"
		else
			jump=`expr ${defaultcolumn} - ${SIZE}`
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		fi
	fi

	keypresspause

##################################################################################################
#
# Application advisories and warnings
#
##################################################################################################


	logtext "------------------------ Application advisories -----------------------"

	displaytext ""; displaytext ""
	displaytext "${YELLOW}Application advisories${NORMAL}"
	displaytext "* Application scan"

	FOUNDSTRING=0
	SIZE=33
	displaytext -n "   Checking Apache2 modules ... "
	jump=`expr ${defaultcolumn} - ${SIZE}`

	if [ -d /etc/apache2/mods-enabled ]; then
		for I in `ls /etc/apache2/mods-enabled/*`; do
			SEARCHSTRING=`egrep 'mod_rootme\.so|mod_rootme2\.so' ${I}`
			logtext -n "Checking Apache2 modules in /etc/apache2/mods-enabled ${I}... "
			if [ ! "${SEARCHSTRING}" = "" ]; then
				logtext --nodate "Warning! Possible bad module found."
				FOUNDSTRING=1
			else
				logtext --nodate "OK"
			fi
		done

		if [ ${FOUNDSTRING} -eq 1 ]; then
			insertlayout
			displaytext $E "   ${LAYOUT}[ ${RED}BAD${NORMAL} ]"
		else
			insertlayout
			displaytext $E "   ${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		fi
	else
		insertlayout
		displaytext $E "   ${LAYOUT}[ ${GREEN}Not found${NORMAL} ]"
	fi

	FOUNDSTRING=0

	SIZE=38
	displaytext -n "   Checking Apache configuration ... "
	jump=`expr ${defaultcolumn} - ${SIZE}`

	for I in ${HTTPDCONFS}; do
		if [ -f ${I} ]; then
			SEARCHSTRING=`egrep 'mod_rootme\.so|mod_rootme2\.so' ${I}`
			if [ ! "${SEARCHSTRING}" = "" ]; then
				# Found evil module
				FOUNDSTRING=1
			fi
		fi
	done

	if [ ${FOUNDSTRING} -eq 1 ]; then
		insertlayout
		displaytext $E "   ${LAYOUT}[ ${RED}BAD${NORMAL} ]"
	else
		insertlayout
		displaytext $E "   ${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
	fi


	logtext "---------------------- Application version check ----------------------"

	if [ ${APPLICATION_CHECK} -eq 1 ]; then
		displaytext ""
		displaytext "* Application version scan"

		#BINPATHS="/bin /sbin /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin /usr/local/libexec /usr/libexec"

		if [ "${OPERATING_SYSTEM}" = "AIX" ]; then
			SCANFILES="
exim:Exim%%MTA:
httpd:Apache:
openssl:OpenSSL:
php:PHP:
procmail:Procmail%%MTA:
proftpd:ProFTPd:
sshd:OpenSSH:
"
		else
			SCANFILES="
exim:Exim%%MTA:
gpg:GnuPG:
httpd:Apache:
named:Bind%%DNS:
openssl:OpenSSL:
php:PHP:
procmail:Procmail%%MTA:
proftpd:ProFTPd:
sshd:OpenSSH:
"
		fi

		LINUX_KERNELS="
vulnerable:%2.4.22%2.4.23%
nonvulnerable:%2.4.24%
"

		FOUND=0
		FOUNDUNKNOWN=0

		for J in ${SCANFILES}; do
			APPLICATION=`echo ${J} | cut -d ':' -f1`
			APPLICATIONNAME=`echo ${J} | cut -d ':' -f2`
			VULNERABLE=`cat ${DB_PATH}/programs_bad.dat | cut -d ':' -f2`
			NONVULNERABLE=`cat ${DB_PATH}/programs_good.dat | cut -d ':' -f2`
			logtext "----------------------------------------------------------"
			logtext "Scanning ${APPLICATIONNAME}..."

			FILEFOUND=0
			for I in ${BINPATHS}; do
				if [ -f "${I}/${APPLICATION}" ]; then
					FILEFOUND=1
					VERSION=""
					case ${APPLICATION} in
					exim)
						VERSION=`${I}/exim -bV | grep 'Exim version' | awk '{ print $3 }'`
						;;
					gpg)
						VERSION=`${I}/gpg --version | grep 'GnuPG' | awk '{ print $3 }'`
						;;
					httpd)
						VERSION=`${I}/httpd -v | grep 'Apache' | cut -d ' ' -f3 | cut -d '/' -f2`
						;;
					named)
						VERSION=`${I}/named -v | grep 'named' | grep -v '/' | awk '{ print $2 }'`
						if [ ! "`echo ${VERSION} | grep "-"`" = "" ]; then
							VERSION=`echo ${VERSION} | cut -d '-' -f1`
						fi
						TEST=`${I}/named -v | grep 'named'`
						logtext "Debug: ${TEST}"
						if [ "${VERSION}" = "" ]; then
							VERSION=`${I}/named -v | awk '{ print $2 }'`
						fi
						;;
					openssl)
						VERSION=`${I}/openssl version | head -n 1 | cut -d' ' -f2`
						;;
					php)
						# Strip off any additions (like Debian using version 4.3.10-8)
						VERSION=`${I}/php -v | head -n 1 | awk '{ print $2 }' | cut -d'-' -f1`
						;;
					procmail)
						VERSION=`${I}/procmail -v 2>&1  | grep 'procmail v' | awk '{ print $2 }' | tr -d 'v'`
						;;
					proftpd)
						VERSION=`${I}/proftpd -v 2>&1 | awk '{ print $4 }'`
						;;
					squid)
						VERSION=`${I}/squid -v | grep 'Squid Cache' | awk '{ print $4 }'`
						;;
					sshd)
						VERSION=`${I}/sshd -t -d 2>&1 | head -n 1 | awk '{ print $4 }' | cut -d '_' -f2`
						if [ ! "`echo "${VERSION}" | grep "+"`" = "" ]; then
							VERSION=`echo "${VERSION}" | cut -d'+' -f1`
						fi
						;;
					*)
						displaytext "Unknown"
						VERSION="NA"
						;;
					esac

					logtext "${I}/${APPLICATION} found"

					VERSION=`echo ${VERSION} | tr -d '\r'`

					if [ "${VERSION}" = "" ]; then
						logtext "No version found of application ${APPLICATION}"
						APPLICATIONNAME=`echo ${APPLICATIONNAME} | tr -s '%' ' '`
						displaytext -n "   - ${APPLICATIONNAME} [unknown] "

						JUMPCOL=`expr ${defaultcolumn} - 12`
						SIZE=`echo \'${APPLICATIONNAME} [unknown]\' | wc -c | tr -s ' ' | tr -d ' '`
						jump=`expr ${JUMPCOL} - ${SIZE} + 11`
						insertlayout
						displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
					else
						APPLICATIONNAME=`echo ${APPLICATIONNAME} | tr -s '%' ' '`
						displaytext -n "   - ${APPLICATIONNAME} ${VERSION} "

						JUMPCOL=`expr ${defaultcolumn} - 12`
						SIZE=`echo \'${APPLICATIONNAME} ${VERSION}\' | wc -c | tr -s ' ' | tr -d ' '`
						jump=`expr ${JUMPCOL} - ${SIZE} + 11`
						insertlayout

						RE_VERSION=`echo "${VERSION}" | sed -e 's/\./\\\./g'`
						ISVULNERABLE=`echo ${VULNERABLE} | grep "%${RE_VERSION}%"`
						if [ "${ISVULNERABLE}" = "" ]; then
							ISNONVULNERABLE=`echo ${NONVULNERABLE} | grep "%${RE_VERSION}%"`
							if [ "${ISNONVULNERABLE}" = "" ]; then
								logtext "No information available. Unknown version number"
								displaytext $E "${LAYOUT}[ ${YELLOW}Unknown${NORMAL} ]"
								FOUNDUNKNOWN=1
							else
								logtext "Version ${VERSION} is available in non-vulnerable group and seems to be OK!"
								displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
							fi
						else
							logtext "Version ${VERSION} seems to be vulnerable (if unpatched)!"
							if [ ${USE_PATCHED_SOFTWARE} -eq 1 ]; then
								displaytext $E "${LAYOUT}[ ${YELLOW}Old or patched version${NORMAL} ]"
							else
								displaytext $E "${LAYOUT}[ ${RED}Vulnerable${NORMAL} ]"
							fi
							FOUND=1
							VULNERABLE_ITEM_COUNT=`expr ${VULNERABLE_ITEM_COUNT} + 1`
						fi
					fi
				fi
			done

			if [ ${FILEFOUND} -eq 0 ]; then
				logtext "Application not found"
			fi
		done

#		if [ `uname` = "Linux" ]; then
#			KERNELVERSION=`uname -r`
#			# Strip hypens (-)
#			if [ ! `echo ${KERNELVERSION} | grep '-'` = "" ]; then
#				KERNELVERSION=`echo ${KERNELVERSION} | cut -d '-' -f1`
#			fi

#			displaytext -n "Search information for Linux kernel ${KERNELVERSION}..."

#			FOUND=0
#			VULNERABLE=0
#			for I in ${LINUX_KERNELS}; do
#				TYPE=`echo ${I} | cut -d ':' -f1`
#				INFO=`echo ${I} | cut -d ':' -f2`

#				if [ "${TYPE}" = "nonvulnerable" ]; then
#					GOODVERSIONS=`echo ${INFO} | sed -e "s/%/, /g" | sed -e "s/^, //"  | sed -e "s/, $//"`
#				fi

#				KVERSION=`echo "${KERNELVERSION}" | sed -e 's/\./\\\./g'`
#				if [ ! "`echo ${INFO} | grep "${KVERSION}"`" = "" -o ! "`echo ${INFO} | grep "${KVERSION}-"`" = "" ]; then
#					if [ "${TYPE}" = "vulnerable" ]; then
#						FOUND=1
#						VULNERABLE=1
#						displaytext "Possible vulnerable kernel version!"
#					fi

#					if [ "${TYPE}" = "nonvulnerable" ]; then
#						FOUND=1
#						displaytext "Found a non-vulnerable kernel version"
#					fi
#				fi
#			done
#
#			if [ "${FOUND}" -eq 0 ]; then
#				displaytext "Unknown version"
#			else
#				if [ "${VULNERABLE}" -eq 1 ]; then
#					displaytext "Please upgrade to a higher version like ${GOODVERSIONS}"
#				fi
#			fi
#		else
#			displaytext "Linux kernel check skipped"
#		fi

		displaytext ""
		if [ $FOUNDUNKNOWN -eq 1 ]; then
			displaytext "Your system contains some unknown version numbers. Please run Rootkit Hunter"
			displaytext "with the --update parameter or contact us through the Rootkit Hunter mailing list"
			displaytext "at rkhunter-users@lists.sourceforge.net"
		fi

	fi
	# end of application test CHECK (application_check=1)



##################################################################################################
#
# Security advisories
#
##################################################################################################


	displaytext ""; displaytext ""
	displaytext "${YELLOW}Security advisories${NORMAL}"
	logtext "------------------------- Security advisories -------------------------"

	SIZE=30
	jump=`expr ${defaultcolumn} - ${SIZE}`


	displaytext "${test}* Check: Groups and Accounts${NORMAL}"
	displaytext -n "   Searching for /etc/passwd... "
	if [ -e "${ROOTDIR}etc/passwd" ]; then
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}Found${NORMAL} ]"
		displaytext -n "   Checking users with UID '0' (root)... "

		SIZE=39
		jump=`expr ${defaultcolumn} - ${SIZE}`

		users_with_uid0=`grep -v '^:0:0:::' ${ROOTDIR}etc/passwd | grep ":0:" | cut -d ":" -f1,3 | grep '0' | grep -v 'root:0'`
		if [ "${users_with_uid0}" = "" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${YELLOW}Warning!${NORMAL} (some users in root group) ]"
			displaytext "    info: ${users_with_uid0}"
		fi

	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${RED}Not Found${NORMAL} ]"
	fi

	displaytext "";
	displaytext "${test}* Check: SSH${NORMAL}"

	SIZE=39
	jump=`expr ${defaultcolumn} - ${SIZE}`

	displaytext "   Searching for sshd_config... "
	SSHDCONFIG_PLACES="${ROOTDIR}etc ${ROOTDIR}etc/ssh ${ROOTDIR}usr/local/etc ${ROOTDIR}usr/local/etc/ssh"
	for I in ${SSHDCONFIG_PLACES}; do
		if [ -e "${I}/sshd_config" ]; then
			FOUND=0
			displaytext "   Found ${I}/sshd_config"
			displaytext -n "   Checking for allowed root login... "
			permitrootlogin=`grep "PermitRootLogin" ${I}/sshd_config | grep -v "#"`
			if [ "${permitrootlogin}" = "PermitRootLogin yes" ]; then
				FOUND=1
				logtext "Info: Found 'PermitRootLogin yes'. Unsafe for production servers..."
				logtext "Tip: Change the option in your configuration file (${I}/sshd_config)."
				logtext "     Use normal user accounts and 'su' to obtain root permissions."
			else
				permitrootlogin2=`egrep "PermitRootLogin (no|without-password)" ${I}/sshd_config | grep -v "#"`
				if [ "${permitrootlogin2}" = "PermitRootLogin no" -o "${permitrootlogin2}" = "PermitRootLogin without-password" ]; then
					FOUND=0
					logtext "Info: Found 'PermitRootLogin no' or 'PermitRootLogin without-password' in SSH configuration file ${I}/sshd_config"
				else
					permitrootlogin2=`grep "PermitRootLogin forced-commands-only" ${I}/sshd_config | grep -v "#"`
					if [ "${permitrootlogin2}" = "PermitRootLogin forced-commands-only" ]; then
						FOUND=1
						logtext "Info: Found 'PermitRootLogin forced-commands-only'"
					else
						permitrootlogin3=`grep "#PermitRootLogin yes" ${I}/sshd_config`
						if [ -n "${permitrootlogin3}" ]; then
							FOUND=1
							logtext "Info: Found no PermitRootLogin value in file ${I}/sshd_config. Default value is 'yes'."
						else
							FOUND=0
							logtext "Unknown PermitRootLogin value found in file ${I}/sshd_config"
						fi
					fi
				fi
			fi

			if [ ${FOUND} -eq 1 ]; then
				if [ ${ALLOW_SSH_ROOT_USER} -eq 0 ]; then
					displaytext "${RED}Watch out ${NORMAL}Root login possible. Possible risk!"
					if [ -z "${permitrootlogin}" ]; then
						displaytext "    info: No 'PermitRootLogin' entry found in file ${I}/sshd_config"
					else
						displaytext "    info: \"${permitrootlogin}\" found in file ${I}/sshd_config"
					fi
					displaytext "    Hint: Check the logfile for more information about this issue"
					logtext "Warning: root login possible. Change for your safety the 'PermitRootLogin'"
					logtext "entry in the SSH configuration file ${I}/sshd_config to 'no', and use 'su -' to become root. "
				else
					logtext "Remote root login permitted, but allowed by using explicit option"
					SIZE=36
					jump=`expr ${defaultcolumn} - ${SIZE}`
					insertlayout
					displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (Remote root login permitted by explicit option) ]"
				fi
			else
				SIZE=36
				jump=`expr ${defaultcolumn} - ${SIZE}`
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (Remote root login disabled) ]"
			fi

			displaytext -n "   Checking for allowed protocols... "

			protocols=`grep 'Protocol 2' ${I}/sshd_config | grep -v '#'`
			if [ "${protocols}" = "Protocol 2" ]; then
				SIZE=35
				jump=`expr ${defaultcolumn} - ${SIZE}`
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (Only SSH2 allowed) ]"
			else
				if [ "${protocols}" = "Protocol 2,1" -o "${protocols}" = "Protocol 1,2" -o "${protocols}" = "Protocol 1" ]; then
					SIZE=35
					jump=`expr ${defaultcolumn} - ${SIZE}`
					insertlayout
					displaytext $E "${LAYOUT}[ ${YELLOW}Warning${NORMAL} ]"
					displaytext "    info: Users can use SSH1-protocol (Check the logfile for more information)."
					logtext "Hint: Change the 'Protocol xxx' line into 'Protocol 2'"
				else
					SIZE=35
					jump=`expr ${defaultcolumn} - ${SIZE}`
					insertlayout
					protocols=`grep "#Protocol" ${I}/sshd_config`
					if [ "${protocols}" = "#Protocol 2,1" -o "${protocols}" = "#Protocol 1,2" ]; then
						FOUND=1
						logtext "Found default option Protocol 2,1"
					fi
					if [ "${protocols}" = "#Protocol 1" ]; then
						FOUND=1
						logtext "Found default option Protocol 1"
					fi

					if [ ${FOUND} -eq 0 ];then
						displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (Only SSH2 allowed) ]"
						displaytext "    info: found no option, most times default value is used."
					else
						displaytext $E "${LAYOUT}[ ${YELLOW}Warning${NORMAL} (SSH v1 allowed) ]"
						logtext "Warning: SSH version 1 possible allowed!"
						logtext "Hint: Change the 'Protocol xxx' line into 'Protocol 2'"
					fi
				fi
			fi
		fi
	done


	displaytext ""
	displaytext "${test}* Check: Events and Logging${NORMAL}"
	displaytext -n "   Search for syslog configuration... "

	SIZE=36
	jump=`expr ${defaultcolumn} - ${SIZE}`


	if [ -e "/etc/syslog.conf" -o -e "/etc/syslog-ng/syslog-ng.conf" ]; then
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		SIZE=38
		jump=`expr ${defaultcolumn} - ${SIZE}`

		displaytext -n "   Checking for running syslog slave... "

		case "${OPERATING_SYSTEM}" in
		SunOS)
			syslogisrunning=`ps -ef | grep syslogd | grep -v "grep"`
			syslogngisrunning=`ps -ef | grep syslog-ng | grep -v "grep"`
			;;
		*)
			syslogisrunning=`ps ax | egrep "syslogd|syslog-ng|metalog" | grep -v "grep"`
			#syslogngisrunning=`ps ax | grep syslog-ng | grep -v "grep"`
			;;
		esac

		if [ ! "${syslogisrunning}" = "" -o ! "${syslogngisrunning}" = "" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
			displaytext "    Info: Cannot find syslog/syslog-ng daemon"
		fi

		SIZE=42
		jump=`expr ${defaultcolumn} - ${SIZE}`

		displaytext -n "   Checking for logging to remote system... "

		# First do syslog
		if [ -e /etc/syslog.conf ]; then
			logtoremote=`grep "@" /etc/syslog.conf | grep -v "#"`
		else
			# Second try syslog-ng
			if [ -e /etc/syslog-ng/syslog-ng.conf ]; then
				# Yes, we found the configuration file
				# Gready regex necessary due to allowed formatting (indentation, destination names, destinations)
				# As result logtxt below may contain partial lines.
				logtoremote=`egrep -iA1 "^destination.*{" /etc/syslog-ng/syslog-ng.conf | egrep "(udp|tcp).*\(.*" | grep -v "/"`
			else
				displaytext $E "${LAYOUT}[ ${YELLOW}NA${NORMAL} ]"
				displaytext "Warning: Cannot find syslog-ng configuration file"
				logtext "Info: Cannot find syslog-ng configuration file"
			fi
		fi

		if [ "${logtoremote}" = "" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (no remote logging) ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (remote logging) ]"
			displaytext "    info: ${logtoremote}"
			logtext "Info: line found with logging to remote host ($logtoremote)"
		fi
	fi


	keypresspause

	ENDTIME=`${PERL_CMD} -e 'printf "%d\n", time;'`

	TOTALTIME=`expr ${ENDTIME} - ${BEGINTIME}`
	TOTALMINS=`expr ${TOTALTIME} / 60`
	TOTALSECS=`expr ${TOTALTIME} % 60`

	if [ $TOTALMINS -gt 0 ]; then
		if [ $TOTALMINS -eq 1 ]; then
			TOTALTIME="${TOTALMINS} minute and "
		else
			TOTALTIME="${TOTALMINS} minutes and "
		fi
	else
		TOTALTIME=""
	fi

	if [ $TOTALSECS -eq 1 ]; then
		TOTALTIME="${TOTALTIME}${TOTALSECS} second"
	else
		TOTALTIME="${TOTALTIME}${TOTALSECS} seconds"
	fi

	displaytext ""; displaytext ""
	displaytext "---------------------------- Scan results ----------------------------"

	displaytext ""
	displaytext "${YELLOW}Hash scan${NORMAL}"
	if [ $SKIP_HASHCHECK -eq 0 ]; then
		displaytext "Scanned files: ${HASH_COUNT}"
		displaytext -n "Incorrect hash checksums: "
		if [ "${HASH_DIFFERENT}" -eq 0 ]; then
			displaytext -n "${GREEN}"
		else
			displaytext -n "${RED}"
		fi
		displaytext "${HASH_DIFFERENT}${NORMAL}"
	else
		displaytext "Skipped"
		logtext "Hash scan skipped"
	fi

	displaytext ""
	displaytext "${YELLOW}File scan${NORMAL}"
	displaytext "Scanned files: ${SCANNED_COUNT}"
	displaytext -n "Possible infected files: "
	if [ "${INFECTED_COUNT}" -eq 0 ]; then
		displaytext -n "${GREEN}"
	else
		displaytext -n "${RED}"
	fi
	displaytext "${INFECTED_COUNT}${NORMAL}"
	logtext "Rootkits scanned for: ${ROOTKIT_TESTS}"
	if [ ! "${INFECTED_NAMES}" = "" ]; then
		displaytext "Possible rootkits: ${INFECTED_NAMES}"
	fi

	displaytext ""
	displaytext "${YELLOW}Application scan${NORMAL}"
	if [ ${APPLICATION_CHECK} -eq 1 ]; then
		logtext "${VULNERABLE_ITEM_COUNT} vulnerable applications found"
		displaytext -n "Vulnerable applications: "
		if [ "${VULNERABLE_ITEM_COUNT}" -eq 0 ]; then
			displaytext -n "${GREEN}"
		else
			displaytext -n "${RED}"
		fi
		displaytext ${VULNERABLE_ITEM_COUNT}${NORMAL}
	else
		displaytext "Skipped"
		logtext "Application scan skipped"
	fi

	displaytext ""
	displaytext "Scanning took ${TOTALTIME}."

	if [ "${REPORTMODE}" -eq 0 ]; then
		if [ "${LOGFILE}" != "/dev/null" ]; then
			displaytext ""
			displaytext "Scan results written to logfile ($LOGFILE)"
		fi

		displaytext ""
		displaytext "-----------------------------------------------------------------------"
		displaytext ""
		displaytext "Do you have some problems, undetected rootkits, false positives, ideas"
	    displaytext "or suggestions? Please e-mail us through the Rootkit Hunter mailing list"
	    displaytext "at rkhunter-users@lists.sourceforge.net"
		displaytext ""
		displaytext "-----------------------------------------------------------------------"

	else

		# Force output (because we are in quiet mode)
		echo ""
		echo "* Hash scan"
		if [ $SKIP_HASHCHECK -eq 0 ]; then
			echo "Hash compared            : ${HASH_COUNT}"
			echo "Incorrect hash checksums : ${HASH_DIFFERENT}"
		else
			echo "Skipped"
		fi
		echo ""
		echo "* File scan"
		echo "Scanned files: ${SCANNED_COUNT}"
		echo "Possible infected files: ${INFECTED_COUNT}"
		echo ""
		echo "* Rootkits"
		echo "Possible rootkits: ${INFECTED_NAMES}"
		echo ""
		echo "* Application scan"
		if [ ${APPLICATION_CHECK} -eq 1 ]; then
			echo "Vulnerable applications: ${VULNERABLE_ITEM_COUNT}"
		else
			echo "Skipped"
		fi
		echo ""
		echo "Scanning took ${TOTALTIME}."
		echo ""
		echo "*important*"
		echo "Scan your system manually sometimes with full output enabled!"

		displaytext ""
		displaytext "-----------------------------------------------------------------------"
		displaytext ""
		displaytext "Do you have some problems, undetected rootkits, false positives, ideas"
	    displaytext "or suggestions? Please e-mail us through the Rootkit Hunter mailing list"
	    displaytext "at rkhunter-users@lists.sourceforge.net"
		displaytext ""
		displaytext "-----------------------------------------------------------------------"

	fi

	if [ $CATLOGFILE -eq 1 ]; then
		cat $LOGFILE
	fi

	if [ ${WARNING} -eq 1 ]; then
		if [ $SHOWWARNINGSONLY -eq 1 ]; then
# jh - rewrite this to look for the warnings 'stanza'.
			echo "-----------------------------------------------------------------"
			echo ""
			echo "Found warnings:"
			egrep "Warning|WARNING|BAD|Bad|Vulnerable" $LOGFILE
			echo ""
			echo "-----------------------------------------------------------------"
			echo ""
			echo "If you are unsure about the results above, please contact the"
			echo "Rootkit Hunter team through the Rootkit Hunter mailing list"
			echo "at rkhunter-users@lists.sourceforge.net"
		fi
		if [ -n "${MAILONWARNING}" ]; then
			eval "echo 'Please inspect this machine, because it may be infected' | ${MAIL_CMD} ${MAILONWARNING}"
		fi

		# If we use the --quiet option, tell the user he has to inspect the machine
		if [ ${QUIET} -eq 1 ]; then
			echo "Some errors have been found while checking. Please perform a manual check on this machine (${HOST_NAME})"
		fi

		# Something was wrong. So end with a nonzero exit state for scripters/coders ;-)
		RET_CODE=1
	fi

	return
}


check_os_info() {

	#
	# This function checks the current O/S information against
	# that stored in the rkhunter.dat file. Any change could
	# mean that file hash checks will give several false-positive
	# answers. As such we warn users that a change has occurred.
	#


	#
	# First check if the host name has changed.
	#

	RUNHASHUPD=0

	OLD_HOST=`grep '^Host:' ${DB_PATH}/rkhunter.dat | cut -d: -f2-`

	if [ "${HOST_NAME}" != "${OLD_HOST}" ]; then
		RUNHASHUPD=1
		logtext "Warning: The system hostname has changed since the last run:"
		logtext --indent "Old value: ${OLD_HOST}    New value: ${HOST_NAME}"
	fi


	#
	# Next check if the O/S name has changed.
	#

	OLD_OSNAME=`grep '^OS:' ${DB_PATH}/rkhunter.dat | cut -d: -f2-`

	if [ "${OSNAME}" != "${OLD_OSNAME}" ]; then
		RUNHASHUPD=1
		logtext "Warning: The operating system name or version has changed since the last run:"
		logtext --indent "Old value: ${OLD_OSNAME}    New value: ${OSNAME}"
	fi


	#
	# Check if the prelinking status has changed.
	#

	if [ -z "`grep '^Prelinked:Yes' ${DB_PATH}/rkhunter.dat`" ]; then
		OLD_PRELINK=0
	else
		OLD_PRELINK=1
	fi

	if [ $PRELINKED -ne $OLD_PRELINK ]; then
		RUNHASHUPD=1
		if [ $PRELINKED -eq 1 ]; then
			logtext "Warning: The system has changed to using prelinking since the last run."
		else
			logtext "Warning: The system has changed to not using prelinking since the last run."
		fi
	fi


	#
	# Check if the system architecture has changed. We treat
	# the i386-type architectures as the same. We also treat
	# the sun-type archictures the same as 'sparc'.
	#

	OLD_ARCH=`grep '^Arch:' ${DB_PATH}/rkhunter.dat | cut -d: -f2-`

	if [ -n "`echo ${OLD_ARCH} | grep 'i[0-9]86'`" ]; then
		OLD_ARCH_TYPE="i386"
	elif [ -n "`echo ${OLD_ARCH} | grep 'sun[0-9][a-z]'`" -o -n "`echo ${OLD_ARCH} | grep 'sparc'`" ]; then
		OLD_ARCH_TYPE="sparc"
	else
		OLD_ARCH_TYPE=${OLD_ARCH}
	fi

	if [ -n "`echo ${ARCH} | grep 'i[0-9]86'`" ]; then
		ARCH_TYPE="i386"
	elif [ -n "`echo ${ARCH} | grep 'sun[0-9][a-z]'`" -o -n "`echo ${ARCH} | grep 'sparc'`" ]; then
		ARCH_TYPE="sparc"
	else
		ARCH_TYPE=${ARCH}
	fi

	if [ "${OLD_ARCH_TYPE}" != "${ARCH_TYPE}" ]; then
		RUNHASHUPD=1
		logtext "Warning: The system seems to have changed CPU type:"
		logtext --indent "Old value: ${OLD_ARCH}    New value: ${ARCH}"
	fi


	if [ $RUNHASHUPD -eq 1 ]; then
		logtext --indent "The file hash check may give some false-positive results. If you are sure that none"
		logtext --indent "of the files have been tampered with, then you should re-run rkhunter with the '--hashupd' option."
	fi

	return
}


set_hash_dirs_files() {

	#
	# This function sets up the list of directories we look in,
	# and the list of files we look for, in order to perform
	# the file hash check.
	#

	HASHDIRS="${ROOTDIR}bin ${ROOTDIR}sbin ${ROOTDIR}usr/bin ${ROOTDIR}usr/sbin ${ROOTDIR}usr/local/bin ${ROOTDIR}usr/local/sbin"

	HASHFILES="adduser amd basename cat chattr checkproc chkconfig chmod
	    chown chroot cron csh date depmod df dirname dmesg du echo ed egrep
	    env fgrep file find grep groupadd groupdel groupmod groups grpck
	    head id ifconfig ifdown ifstatus ifup inetd init insmod ip kallsyms
	    kill killall kldload kldstat kldunload ksyms kudzu last lastlog
	    less locate logger login ls lsattr lsmod lynx md5 md5sum mlocate
	    modinfo modload modprobe modstat modunload more mount netstat
	    newgrp newsyslog nologin passwd ps pstree pwck rmmod runlevel sh
	    sha1 sha1sum size slocate sockstat sort stat strace strings su sudo
	    sulogin sysctl syslogd systat tail tcpd test top touch uname
	    useradd userdel usermod users vipw vmstat w watch wc wget whatis
	    whereis which who whoami xinetd"


	#
	# Under SunOS /bin is a link to /usr/bin, so there is no need
	# to look in it. Also add in some extra commands to check.
	#

	if [ "${OPERATING_SYSTEM}" = "SunOS" ]; then
		if [ -h ${ROOTDIR}bin ]; then
			B=""

			for DIR in ${HASHDIRS}; do
				test "${DIR}" != "${ROOTDIR}bin" && B="${B} ${DIR}"
			done

			HASHDIRS=`echo ${B} | sed -e 's/^ *//'`
		fi

		HASHFILES="${HASHFILES} gbasename gcat gchmod gchown gdate
		    gdirname gecho gfind gfile ggroups ghead gid glocate
		    gmd5sum gsize gtail gtest gtouch guname gusers truss"
	fi


	add_extra_dirs
	HASHDIRS="${HASHDIRS}{EXTRA_DIRS}"

	return
}


help() {

	echo ""
	echo "Usage: rkhunter (--check | --cronjob | --update | --hashupd |"
	echo "                 --versioncheck | --version | --help) [option]..."
	echo ""

	echo "Current options are:"
	echo "       --append-log                    Append to the logfile, do not overwrite"
	echo "       --bindir '<bindir>...'          Use <bindir> instead of default"
	echo "                                       command directories"
	echo "   -c, --check                         Check the local system"
	echo "       --color-set2                    Use second color set for output"
	echo "       --configfile <file>             Use specified configuration file"
	echo "       --cronjob                       Run as a cronjob"
	echo "                                       (implies -c, -sk and --nocolors options)"
	echo "       --dbdir <dir>                   Use specified database directory"
	echo "       --display-logfile               Display the logfile at the end"
	echo "       --hash                          Specify the hash function to use"
	echo "       --hashupd                       Update the local file hash database"
	echo "   -h, --help                          Display this help menu and exit"
	echo "   -l, --logfile [logfile]             Write to a logfile"
	echo "                                       (default is $DFLT_LOGFILE)"
	echo "       --md5                           Specify the MD5 command to use for the"
	echo "                                       'known bad' hash check"
	echo "       --noappend-log                  Do not append to the logfile, overwrite it"
	echo "       --nocolors                      Use black and white output"
	echo "       --nolog                         Do not write to a logfile"
	echo "   -q, --quiet                         Quiet mode (only show warnings)"
	echo "       --report-mode                   Only show interesting information"
	echo "       --report-warnings-only          Show only warnings (less output than"
	echo "                                       --report-mode more than --quiet)"
	echo "   -r, --rootdir <rootdir>             Use <rootdir> instead of '/'"
	echo "  -sk, --skip-keypress                 Don't wait for a keypress after each test"
	echo "       --tmpdir <tempdir>              Use specified temporary directory"
	echo "       --update                        Check for updates to database files"
	echo "   -V, --version                       Display version and exit"
	echo "       --versioncheck                  Check for latest version of program"
	echo "   -x                                  Do not automatically detect if X is in use"
	echo "   -X                                  Automatically detect if X is in use"
	echo ""

	echo "Specific scan options:"
	echo "       --allow-ssh-root-user           Allow the 'root can login via SSH' check"
	echo "       --check-deleted                 Perform a 'deleted files' check"
	echo "       --check-listen                  Perform a 'listening applications' check"
	echo "       --dac, --disable-application-check"
	echo "                                       Disable application version checks"
	echo "       --dhc, --disable-hash-check     Disable the hash checks"
	echo "       --dpc, --disable-passwd-check   Disable passwd/group file checks"
	echo "       --scan-knownbad-files           Perform a 'known bad' MD5 hash check"
	echo ""

	return
}


######################################################################
#
# Initialisation
#
######################################################################


#
# First we initialise variables used throughout the program.
#

PROGRAM_NAME="Rootkit Hunter"
PROGRAM_version="1.2.9"
PROGRAM_copyright_owner="Michael Boelen"
PROGRAM_copyright="Copyright (c) 2003-2006, ${PROGRAM_copyright_owner}"
PROGRAM_license="
${PROGRAM_NAME} ${PROGRAM_version}, ${PROGRAM_copyright}

Under active development by the ${PROGRAM_NAME} project team. For reporting
bugs, updates, patches, comments and questions please go to: http://rkhunter.sourceforge.net

${PROGRAM_NAME} comes with ABSOLUTELY NO WARRANTY. This is free software,
and you are welcome to redistribute it under the terms of the GNU General
Public License. See LICENSE for details.
"

# Set to run as a cronjob
CRONJOB=0
CHECK=0

# Set to display the logfile at the end
CATLOGFILE=0

NOLOG=0
LOGFILE=""
DFLT_LOGFILE="/var/log/rkhunter.log"

# Set to have the logfile appended to rather than overwritten.
APPEND_LOG=0
APPEND_OPT=0

DFLT_BINPATHS="/bin /usr/bin /sbin /usr/sbin /usr/local/bin /usr/local/sbin /usr/libexec /usr/local/libexec"

MD5_CMD=""
HASH_FUNC=""
HASHDIRS=""
HASHFILES=""

PRELINKED=0
PRELINK_CMD=""
PRELINK_WARN=""

UPDATE=0
HASH_UPDATE=0
VERSIONCHECK=0

# By default use coloured output.
COLORS=1
CLRSET2=0

# Set to automatically detect if X is in use, and
# hence use the second colour set.
AUTO_X_DTCT=0
AUTO_X_OPT=0

# Set to skip the hash checks
HASHOPT=0
SKIP_HASHCHECK=0
HASHCHECK_WARN=""

# Set to skip the passwd/group check
SKIP_PASSWDCHECK=0

# Perform the application check
APPLICATION_CHECK=1
VULNERABLE_ITEM_COUNT=0

CHKDEL=0
CHKLISTEN=0

PREVIOUSTEXT=""

# Set to be quiet (only show warnings)
QUIET=0

# Set to only show warnings
SHOWWARNINGSONLY=0

# Set to perform check of known bad checksums
# jh - allow user to whitelist/disable this
PERFORMKNOWNBAD=1

ROOTDIR="/"

# Set to use report mode (do not show footer and make a 'professional' report)
REPORTMODE=0

# Default 'id' command. Solaris will reset this.
ID_CMD="id"

# Wait for a keypress after each test
PAUSEAFTERTESTS=1

# Wait for a keypress after a warning
WAITONWARNING=1

# Is the operating system Gentoo?
GENTOO=0

# Set to allow SSH root login
ALLOW_SSH_ROOT_USER=0

INFECTED_COUNT=0
INFECTED_NAMES=""
SCANNED_COUNT=0
HASH_COUNT=0
HASH_DIFFERENT=0

FOUNDFILE=0
FOUNDRCSIGNS=0

# Set if grsec is installed
GRSECINSTALLED=0

# This is set if a problem is found
WARNING=0

# Default display column width
defaultcolumn=60

# Initialise default status
STATUS=0

# Ksyms or kallsyms file used in some checks
KSYMS_FILE=""

# Record for logging the command-line being used
CMD_LINE="$0 $*"

# Create a spaced-separated PATH variable
SPACEDPATH=`echo ${PATH} | tr : ' '`

# List of commands used during RKH. If a command does not exist, then
# the code may use an alternative method.
CMDLIST="curl elinks file find ifconfig ip links lsattr lsmod lsof lynx perl readlink stat strings wget GET"


HOST_NAME=`hostname`

if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
	USE_PATCHED_SOFTWARE=1
else
	USE_PATCHED_SOFTWARE=0
fi

# This is the return code for the program actions - update, check, etc.
RET_CODE=0


######################################################################
#
# Command-line option processing
#
######################################################################


#
# Display the help menu if no options were given.
#

if [ $# -eq 0 ]; then
	help
	exit 0
fi


#
# Check the command-line options. If set, these will override the
# configuration file options.
#

while [ $# -ge 1 ]; do
	case $1 in
	--allow-ssh-root-user)
		ALLOW_SSH_ROOT_USER=1
		;;
	--append-log | --appendlog)
		APPEND_LOG=1
		APPEND_OPT=1
		;;
	-c | --check | --checkall)
		CHECK=1
		;;
	--check-deleted)
		CHKDEL=1
		;;
	--check-listen)
		CHKLISTEN=1
		;;
	--cs2 | --colorset2 | --color-set2)
		CLRSET2=1
		;;
	--bindir)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			BINPATHS="$1"
			;;
		esac
		;;
	--configfile)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			CONFIGFILE="$1"
			;;
		esac
		;;
	--cronjob)
		CHECK=1
		CRONJOB=1
		COLORS=0
		PAUSEAFTERTESTS=0
		WAITONWARNING=0
		;;
	-l | --log | --logfile | --createlogfile | --createlog | --create-log | --create-logfile)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			LOGFILE="$1"
			;;
		esac
		;;
	--dbdir)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			DB_PATH="$1"
			;;
		esac
		;;
	--disable-application-check | --disable-applicationcheck | --dac | --skip-application-check | --skipapplicationcheck | --skip-applicationcheck)
		APPLICATION_CHECK=0
		;;
	--disable-hash-check | --disable-hashcheck | --dhc | --disable-md5-check | --disable-md5check | --dmc)
		HASHOPT=1
		SKIP_HASHCHECK=1
		;;
	--disable-passwd-check | --dpc)
		SKIP_PASSWDCHECK=1
		;;
	--display-logfile | --displaylogfile | --display-log | --displaylog)
		CATLOGFILE=1
		;;
	--hash)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			HASH_FUNC="$1"
			;;
		esac
		;;
	--hashupd | --hash-update | --hashupdate)
		HASH_UPDATE=1
		;;
	-h | --help)
		help
		exit 0
		;;
	--md5)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			MD5_CMD="$1"
			;;
		esac
		;;
	--noappend-log | --no-append-log | --noappendlog)
		APPEND_LOG=0
		APPEND_OPT=1
		;;
	--nocolors | --no-colors | --nocolor | --no-color)
		COLORS=0
		;;
	--nolog | --no-log)
		LOGFILE="/dev/null"
		;;
	-q | --quiet)
		QUIET=1
		;;
	--report-mode | --reportmode)
		QUIET=1
		REPORTMODE=1
		;;
	--report-warnings-only)
		QUIET=1
		SHOWWARNINGSONLY=1
		;;
	-r | --rootdir)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			ROOTDIR="$1"
			;;
		esac
		;;
	--scan-knownbad-files)
		PERFORMKNOWNBAD=1
		;;
	--skip-keypress | --skipkeypress | -sk | --sk)
		PAUSEAFTERTESTS=0
		WAITONWARNING=0
		;;
	--tmpdir)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			TMPDIR="$1"
			;;
		esac
		;;
	--update)
		UPDATE=1
		;;
	-V | --version)
		echo $ECHOOPT "${PROGRAM_NAME} ${PROGRAM_version}"
		exit 0
		;;
	--versioncheck)
		VERSIONCHECK=1
		;;
	-x)
		AUTO_X_OPT=1
		AUTO_X_DTCT=0
		;;
	-X)
		AUTO_X_OPT=1
		AUTO_X_DTCT=1
		;;
	*)
		echo "Invalid option specified: $1"
		exit 1
		;;
	esac

	shift
done


#
# We check that we are root. If we are not, then only the
# help and version command-line options are valid.
#

test "${OPERATING_SYSTEM}" = "SunOS" && ID_CMD="/usr/xpg4/bin/id"

if [ "`${ID_CMD} -u 2>/dev/null`" != "0" ]; then
	echo "You must be the root user to run this program."
	exit 1
fi


#
# Before going too much further we need to ensure that some basic
# commands are present on the system. We cannot do this using
# the BINDIR option because that requires processing the configuration
# file, which in turn requires the commands we want to check on. As
# such we use the default command directory list. We do not assign
# these commands to variables, but will do for other commands which we
# look for later on.
#

check_required_commands "${SPACEDPATH} ${DFLT_BINPATHS}"


######################################################################
#
# Configuration file processing
#
######################################################################


#
# Now we check for the configuration file, and then check the various
# options within it.
#

if [ -z "${CONFIGFILE}" ]; then
	if [ -f /etc/rkhunter.conf ]; then
		CONFIGFILE="/etc/rkhunter.conf"
	else
		CONFIGFILE="/usr/local/etc/rkhunter.conf"
	fi
fi

if [ ! -f "${CONFIGFILE}" ]; then
	echo "Unable to find configuration file: ${CONFIGFILE}"
	exit 1
elif [ ! -r "${CONFIGFILE}" ]; then
	echo "Configuration file is not readable: ${CONFIGFILE}"
	exit 1
fi


get_configfile_options


######################################################################
#
# Option processing
#
######################################################################


#
# Next set up some final variables based on the combination
# of options we have been given.
#

if [ $CHECK -eq 1 ]; then

	#
	# If the logfile has been disabled, then we cannot let the program
	# run when certain options are used. If we did, the user would see
	# no output and might assume that all was well.
	#

	if [ "${LOGFILE}" = "/dev/null" ]; then
		if [ $SHOWWARNINGSONLY -eq 1 ]; then
			echo "The logfile has been disabled - unable to report warnings."
			exit 1
		elif [ $CATLOGFILE -eq 1 ]; then
			echo "The logfile has been disabled - unable to display the log file."
			exit 1
		fi
	fi


	#
	# To perform the 'known bad' check requires an MD5 command.
	#

	if [ $PERFORMKNOWNBAD -eq 1 -a -z "${MD5_CMD}" ]; then
		echo "Unable to perform 'known bad' check - no MD5 command can be found."
		exit 1
	fi


	#
	# Set up the colors to be used.
	#

	if [ $COLORS -eq 1 ]; then
		NORMAL="[0;39m"		# Foreground colour to default

		if [ $CLRSET2 -eq 0 ]; then
			RED="[1;31m"		# Bright red
			GREEN="[1;32m"	# Bright green
			YELLOW="[1;33m"	# Bright yellow
			WHITE="[1;37m"	# White
		else
			RED="[1;31m"		# Bright red
			GREEN="[0;32m"	# Green
			YELLOW="[0;35m"	# Purple
			WHITE="[0;30m"	# Black
		fi
	fi


	#
	# Check if we have a ksyms or kallsyms file.
	#

	if [ -f "${ROOTDIR}proc/ksyms" ]; then
		KSYMS_FILE="${ROOTDIR}proc/ksyms"
	elif [ -f "${ROOTDIR}proc/kallsyms" ]; then
		KSYMS_FILE="${ROOTDIR}proc/kallsyms"
	fi
fi


#
# If we can find no hash function to use, then skip the
# check. Additionally, if no option is given for the
# program to action, then say so and exit.
#

if [ $HASH_UPDATE -eq 1 -o \( $CHECK -eq 1 -a $SKIP_HASHCHECK -eq 0 \) ]; then

	#
	# For a hash update we must have a valid hash function to use.
	#

	if [ $HASH_UPDATE -eq 1 ]; then
		if [ -z "${HASH_FUNC}" ]; then
			echo "Unable to find any hash function command to perform hash update."
			exit 1
		elif [ $PRELINKED -eq 1 ]; then
			HCMD=`echo "${HASH_FUNC}" | cut -d' ' -f1`
			if [ -z "`echo ${HCMD} | egrep -i 'sha1|md5'`" ]; then
				echo "This system uses prelinking, but the hash function (${HASH_FUNC}) does not look like SHA1 or MD5."
				exit 1
			fi
		fi
	fi


	#
	# We need to set the list of files to use for checking hash values.
	#

	set_hash_dirs_files


	if [ -z "${HASH_FUNC}" ]; then
		SKIP_HASHCHECK=1
		HASHCHECK_WARN="Warning: Unable to find any hash function command to perform hash checks.\n    The file hash check will be skipped."
	fi
elif [ $CHECK -eq 0 -a $VERSIONCHECK -eq 0 -a $UPDATE -eq 0 ]; then
	echo "You must enter an option for the program to perform."
	echo "Type in 'rkhunter --help' to see the available options,"
	echo "or read the rkhunter man page."
	exit 1
fi


#
# See if we have GRSEC installed.
#

if [ "${OPERATING_SYSTEM}" = "Linux" -a -n "`uname -a | grep 'grsec'`" ]; then
	GRSECINSTALLED=1
fi


#
# Sort out the logfile before we write to it. If we have no log file,
# then record this. The 'logtext' function will still be called, but
# will return straight away.
#

if [ "${LOGFILE}" = "/dev/null" ]; then
	NOLOG=1
else
	if [ $APPEND_LOG -eq 0 ]; then
		mv -f ${LOGFILE} ${LOGFILE}.old >/dev/null 2>&1
	else
		logtext --nodate ""
		logtext --nodate ""
	fi
fi


FOUNDTRACES="
-----------------------------------------------------------------------
Found parts of this rootkit/trojan by checking the default files and directories.
Please inspect the available files, by checking the logfile ($LOGFILE).
-----------------------------------------------------------------------
"


######################################################################
#
# Initial logging
#
######################################################################


test $CHECK -eq 1 && BEGINTIME=`${PERL_CMD} -e 'printf "%d\n", time;'`

#
# Write out various information messages to the logfile.
#

if [ -n "${HOST_NAME}" ]; then
	logtext --nodate "Running ${PROGRAM_NAME} ${PROGRAM_version} on ${HOST_NAME}"
else
	logtext --nodate "Running ${PROGRAM_NAME} ${PROGRAM_version}"
fi

logtext --nodate "${PROGRAM_license}"

logtext "Info: Start date is `date`"

logtext "Info: Environment shell is ${SHELL}; rkhunter is using ${MYSHELL}"

logtext "Info: Command line is ${CMD_LINE}"

logtext "Info: Using configuration file ${CONFIGFILE}"

logtext "Info: Installation directory is ${INSTALLDIR}"

if [ -z "${MAILONWARNING}" ]; then
	logtext "Info: No mail-on-warning address configured"
else
	logtext "Info: Emailing warnings to \"${MAILONWARNING}\" using command \"${MAIL_CMD}\""
fi

logtext "Info: Using ${TMPDIR} as temporary directory"

if [ "${TMPDIR}" = "/tmp" ]; then
	logtext "Warning: Do not use /tmp as your temporary directory. It will contain"
	logtext --indent "some important system files. Please set another directory in"
	logtext --indent "your configuration file, or use the --tmpdir command-line option."

	displaytext "Warning! Using /tmp as your temporary directory can be a security risk."
	displaytext "Check the logfile for more information about this issue."
fi

logtext "Info: Using ${DB_PATH} as database directory"

logtext "Info: Using ${SCRIPT_PATH} as script directory"

if [ $ALLOW_SSH_ROOT_USER -eq 1 ]; then
	logtext "Info: Explicit option set to allow root logins via SSH"
fi

logtext "Info: Using '${BINPATHS}' as command directories"

logtext "Info: Using '${ROOTDIR}' as the root directory"

test $AUTO_X_DTCT -eq 1 && logtext "Info: X is automatically detected"
test $CLRSET2 -eq 1 && logtext "Info: Using second color set"

for CMD in ${CMDLIST}; do
	UCMD=`echo ${CMD} | tr [a-z] [A-Z]`
	UCMD=`eval echo "\\$${UCMD}_CMD"`
	if [ -n "${UCMD}" ]; then
		logtext "Info: Found '${CMD}' command: ${UCMD}"
	else
		logtext "Info: Unable to find '${CMD}' command"
	fi
done

test -n "${PRELINK_WARN}" && logtext "${PRELINK_WARN}"

test -n "${HASHCHECK_WARN}" && logtext "${HASHCHECK_WARN}"


if [ $HASH_UPDATE -eq 1 -o \( $CHECK -eq 1 -a $SKIP_HASHCHECK -eq 0 \) ]; then
	if [ $PRELINKED -eq 1 ]; then
		UCMD=${PRELINK_CMD}
		test -n "${RUNCON_CMD}" && UCMD=`echo "${UCMD}" | cut -d' ' -f5`

		logtext "Info: Found 'prelink' command: ${UCMD}"

		if [ -n "${RUNCON_CMD}" ]; then
			logtext "Info: Found 'runcon' command: ${RUNCON_CMD}"
		else
			logtext "Info: Unable to find 'runcon' command"
		fi

		HCMD=`echo "${HASH_FUNC}" | cut -d' ' -f1`
		if [ -z "`echo ${HCMD} | egrep -i 'sha1|md5'`" ]; then
			SKIP_HASHCHECK=1
			logtext "Warning: This system uses prelinking, but the hash function (${HASH_FUNC}) does not look like SHA1 or MD5.\n    The file hash check will be skipped."
		elif [ -n "`echo ${HCMD} | egrep -i 'sha1'`" ]; then
			logtext "Info: System is using prelinking - using SHA1 (${HASH_FUNC}) for hash checks"
		else
			logtext "Info: System is using prelinking - using MD5 (${HASH_FUNC}) for hash checks"
		fi
	else
		logtext "Info: System is not using prelinking"

		if [ -n "`echo "${HASH_FUNC}" | grep '/filehashsha1\.pl$'`" ]; then
			logtext "Info: Using the perl script for SHA1 hash checks"
		elif [ -n "`echo "${HASH_FUNC}" | grep '/filehashmd5\.pl$'`" ]; then
			logtext "Info: Using the perl script for MD5 hash checks"
		else
			logtext "Info: Using ${HASH_FUNC} for the hash checks"
		fi
	fi

	if [ $PERFORMKNOWNBAD -eq 1 -a -n "${MD5_CMD}" ]; then
		if [ -n "`echo "${MD5_CMD}" | grep '/filehashmd5\.pl$'`" ]; then
			logtext "Info: Using the perl script for 'known bad' MD5 hash checks"
		else
			logtext "Info: Using ${MD5_CMD} for the 'known bad' MD5 hash checks"
		fi
	fi
fi

test $GRSECINSTALLED -eq 1 && logtext "Info: Found GRSEC installed"


######################################################################
#
# Start of program actions and checks
#
######################################################################


#
# We can now start to run the actions the user has requested on
# the command-line. We run the update type commands first before
# doing any full system check.
#

#
# If the user wants to run a system check, then the rkhunter.dat
# file must exist. If it does not, or is empty, then we log the
# fact and inform the user to run RKH with the --hashupd option.
# The program will continue, but without the file hash checking.
#

if [ $HASH_UPDATE -eq 0 ]; then
	if [ $CHECK -eq 1 -a $SKIP_HASHCHECK -eq 0 ]; then
		if [ ! -f "${DB_PATH}/rkhunter.dat" -o ! -s "${DB_PATH}/rkhunter.dat" ]; then
			SKIP_HASHCHECK=1
			logtext "Warning: This program needs to know certain information about your computer."

			if [ ! -f "${DB_PATH}/rkhunter.dat" ]; then
				logtext --indent "The file holding this information does not exist, and so must be created."
			else
				logtext --indent "The file holding this information is empty, and so must be recreated."
			fi

			logtext --indent "To do this type in 'rkhunter --hashupd'."
			logtext --indent ""
			logtext --indent "Continuing without the file hash checks."
		else

			#
			# We perform a simple check of some of the stored
			# O/S information, and compare it to the current
			# info. Basically we are just seeing if the system
			# has changed at all because it could affect the
			# file hash check. If it does then log it.
			#

			rkh_dat_get_os_info

			check_os_info
		fi
	fi
else
	#
	# The user wants to update the O/S and file hash data.
	#

	logtext ""
	logtext "Info: Starting file hash data update"

	do_hash_update

	logtext "Info: Finished file hash data update"
	logtext ""
fi


#
# The user wants to update the supplied RKH *.dat files.
#

test $UPDATE -eq 1 && do_update


#
# The user wants to check for the latest program version.
#

test $VERSIONCHECK -eq 1 && do_versioncheck


#
# The user wants to check the local system for anomalies.
#

test $CHECK -eq 1 && do_system_check

logtext "Info: End date is `date`"

exit $RET_CODE
