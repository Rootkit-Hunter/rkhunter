#!/bin/sh

#
# rkhunter -- Scan the system for rootkits and other known security issues.
#
# Copyright (c) 2003-2006, Michael Boelen ( michael AT rootkit DOT nl )
#
#     This program is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program; if not, write to the Free Software
#     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
#


#
# Unfortunately we must do some O/S checks at the very beginning.
# Otherwise SunOS will complain about some of the ksh/bash syntax.
#

OPERATING_SYSTEM=`uname 2>/dev/null`

if [ "${OPERATING_SYSTEM}" = "SunOS" ]; then
	if [ -z "$RANDOM" ]; then
		if [ -n "`which bash 2>/dev/null | grep '^/'`" ]; then
			exec bash $0 $*
		else
			exec ksh $0 $*
		fi

		exit 0
	fi
fi

if [ "$1" = "--debug" ]; then
	rm -f /tmp/rkhunter-debug >/dev/null 2>&1
	exec 1>/tmp/rkhunter-debug 2>&1
	set -x
fi

case "${OPERATING_SYSTEM}" in
AIX|OpenBSD|SunOS)
	# What is the default shell?
	if print >/dev/null 2>&1; then
		alias echo='print'
		E=""
		ECHOOPT="--"
		NEWECHOOPT="--"
		MYSHELL=ksh
	else
		E="-e"
		ECHOOPT=""
		NEWECHOOPT="-e"
		MYSHELL=bash
	fi
	;;
*)
	E="-e"
	ECHOOPT=""
	NEWECHOOPT="-e"


	#
	# We want to get the actual shell used by this program, and
	# so we need to test /bin/sh.
	#

	MYSHELL=/bin/sh
	test -h ${MYSHELL} && MYSHELL=`readlink ${MYSHELL} 2>/dev/null`
	MYSHELL=`basename ${MYSHELL} 2>/dev/null`

	if [ -z "${MYSHELL}" ]; then
		MYSHELL=bash
	elif [ "${MYSHELL}" = "dash" -o "${MYSHELL}" = "ash" ]; then
		E=""
		NEWECHOOPT=""
	fi
	;;
esac


######################################################################
#
# Global function definitions
#
######################################################################


display() {

	#
	# This function is used to display text messages on to the
	# users screen, as well as in to the log file. The same
	# message is written to both. However, the screen may have
	# a coloured result (green for good, red for bad, etc), and
	# the log file will have the time prefixed to the message and,
	# optionally, additional information messages after the main
	# message. All the messages are indexed in the language file.
	#
	# Syntax: display --to <destination> --type <type>
	#		  [--screen-indent <n>] [--log-indent <n>]
	#		  [--nl [<n>]] [--nl-after] [--log-nl]
	#		  [--result <result> --color <colour>]
	#		  <message index> [optional message arguments]
	#
	# where the destination can be one of SCREEN, LOG or SCREEN+LOG.
	# The type can be one of PLAIN, INFO or WARNING.
	# The language file will have all the current values.
	#
	# The --screen-indent and --log-indent options are used to
	# forcibly indent a message.
	# The --nl option causes a blank-line to be output before the
	# message both on the screen and in the log file. A following
	# number can be used to indicate how many blank lines should
	# be displayed on the screen.
	# The --log-nl option outputs a blank line only in the log file.
	# The --nl-after option outputs a blank line on the screen after
	# the message.
	#


	#
	# We first initialize some variables and then
	# process the switches used.
	#

	WARN_MSG=0; NL=0; NLAFTER=0; LOGINDENT=0; SCREENINDENT=0
	LOGNL=0
	WRITETO=''; TYPE=''; RESULT=''; COLOR=''; MSG=''
	LINE1=''; LOGLINE1=''; SPACES=''

	DISPLAY_LINE="display $*"

	if [ $# -le 0 ]; then
		echo "Error: Invalid display call - no arguments given"
		return
	fi

	while [ $# -ge 1 ]; do
		case "$1" in
		--to)
			case "$2" in
			SCREEN|LOG|SCREEN+LOG)
				WRITETO=$2
				;;
			*)
				echo "Error: Invalid display destination: $2   Display line: ${DISPLAY_LINE}"
				return
				;;
			esac

			shift
			;;
		--type)
			TYPE=`eval echo "\\$MSG_TYPE_$2"`

			if [ -z "${TYPE}" -a "$2" != "PLAIN" ]; then
				echo "Error: Invalid display type: $2   Display line: ${DISPLAY_LINE}"
				return
			fi

			test "$2" = "WARNING" && WARN_MSG=1

			shift
			;;
		--result)
			RESULT=`eval echo "\\$MSG_RESULT_$2"`

			if [ -z "${RESULT}" ]; then
				echo "Error: Invalid display result: $2   Display line: ${DISPLAY_LINE}"
				return
			fi

			shift
			;;
		--color)
			if [ $COLORS -eq 1 ]; then
				test -n "$2" && COLOR=`eval "echo \\${$2}"`

				if [ -z "${COLOR}" ]; then
					echo "Error: Invalid display color: $2   Display line: ${DISPLAY_LINE}"
					return
				fi
			fi

			shift
			;;
		--log-indent)
			LOGINDENT=$2

			if [ -z "${LOGINDENT}" ]; then
				echo "Error: No --log-indent value given.   Display line: ${DISPLAY_LINE}"
				return
			elif [ -z "`echo ${LOGINDENT} | grep '^[0-9]*$'`" ]; then
				echo "Error: Invalid --log-indent value given: $2   Display line: ${DISPLAY_LINE}"
				return
			fi

			shift
			;;
		--screen-indent)
			SCREENINDENT=$2

			if [ -z "${SCREENINDENT}" ]; then
				echo "Error: No --screen-indent value given.   Display line: ${DISPLAY_LINE}"
				return
			elif [ -z "`echo ${SCREENINDENT} | grep '^[0-9]*$'`" ]; then
				echo "Error: Invalid --screen-indent value given: $2   Display line: ${DISPLAY_LINE}"
				return
			fi

			shift
			;;
		--nl)
			NL=1

			case "$2" in
			[0-9])
				NL=$2
				shift
				;;
			esac
			;;
		--log-nl)
			LOGNL=1
			;;
		--nl-after)
			NLAFTER=1
			;;
		-*)
			echo "Error: Invalid display option given: $1   Display line: ${DISPLAY_LINE}"
			return
			;;
		*)
			MSG=$1
			shift
			break
			;;
		esac

		shift
	done


	#
	# Before anything we must record if this is a warning message.
	#

	test $WARN_MSG -eq 1 && WARNING_COUNT=`expr ${WARNING_COUNT} + 1`


	#
	# For simplicity we now set variables as to whether the output
	# goes to the screen and/or the log file. In some cases we do
	# not need to output anything, and so can just return.
	#

	if [ $NOLOG -eq 1 ]; then
		test "${WRITETO}" = "LOG" && return

		test "${WRITETO}" = "SCREEN+LOG" && WRITETO="SCREEN"
	fi

	if [ $NOTTY -eq 1 ]; then
		test "${WRITETO}" = "SCREEN" && return

		test "${WRITETO}" = "SCREEN+LOG" && WRITETO="LOG"
	fi


	if [ "${WRITETO}" = "SCREEN" -o "${WRITETO}" = "SCREEN+LOG" ]; then
		WRITETOTTY=1
	else
		WRITETOTTY=0
	fi

	if [ "${WRITETO}" = "LOG" -o "${WRITETO}" = "SCREEN+LOG" ]; then
		WRITETOLOG=1
	else
		WRITETOLOG=0
	fi


	#
	# Now check that the options we have been given make sense.
	#

	if [ $WRITETOTTY -eq 0 -a $WRITETOLOG -eq 0 ]; then
		echo "Error: Invalid display destination: Display line: ${DISPLAY_LINE}"
		return
	elif [ $WRITETOTTY -eq 1 -a -n "${RESULT}" -a -z "${COLOR}" ]; then
		echo "Error: Invalid display - no color given: Display line: ${DISPLAY_LINE}"
		return
	fi


	#
	# We set the variable LINE1 to contain the first line of the message.
	# For the log file we use the variable LOGLINE1. We also set
	# where the language file is located. If a message cannot be found
	# in the file, then we look in the English file. This will allow RKH
	# to still work even when the language files change.
	#

	LANG_FILE="${DB_PATH}/i18n/${LANGUAGE}"

	if [ -n "${MSG}" ]; then
		LINE1=`grep "^${MSG}:" ${LANG_FILE} 2>/dev/null | head -n 1 | cut -d: -f2-`

		if [ -z "${LINE1}" ]; then
			LANG_FILE="${DB_PATH}/i18n/en"
			LINE1=`grep "^${MSG}:" ${LANG_FILE} 2>/dev/null | head -n 1 | cut -d: -f2-`

			if [ -z "${LINE1}" ]; then
				echo "Error: Invalid display - keyword cannot be found: Display line: ${DISPLAY_LINE}"
				return
			fi
		fi

		test -n "${LINE1}" && LINE1=`eval "echo \"${LINE1}\" | sed -e 's/;/\\;/g'"`
	fi


	#
	# At this point LINE1 is the text of the message. We have to
	# see if the message is to be indented, and must prefix the
	# time to log file messages. We must do the log file first
	# because it uses LINE1.
	#

	if [ $WRITETOLOG -eq 1 ]; then
		LOGLINE1=`date '+[%H:%M:%S]'`

		test $NL -gt 0 -o $LOGNL -eq 1 && echo "${LOGLINE1}" >>${LOGFILE}

		if [ -n "${TYPE}" ]; then
			LOGLINE1="${LOGLINE1} ${TYPE}: ${LINE1}"
		else
			if [ $LOGINDENT -gt 0 ]; then
				SPACES=`echo "${BLANK_LINE}" | cut -c1-$LOGINDENT`
			fi

			LOGLINE1="${LOGLINE1} ${SPACES}${LINE1}"
		fi
	fi

	if [ $WRITETOTTY -eq 1 -a $SCREENINDENT -gt 0 ]; then
		SPACES=`echo "${BLANK_LINE}" | cut -c1-$SCREENINDENT`
		LINE1="${SPACES}${LINE1}"
	fi


	#
	# We now check to see if a result is to be output. If it is,
	# then we need to space-out the line and color the result.
	#
	if [ -n "${RESULT}" ]; then
		if [ $WRITETOTTY -eq 1 ]; then
			LINE1_NUM=`echo "${LINE1}" | wc -c | tr -d ' '`
			NUM_SPACES=`expr 62 - ${LINE1_NUM}`
			LINE1="${LINE1}\033[${NUM_SPACES}C[ ${COLOR}${RESULT}${NORMAL} ]"
		fi

		if [ $WRITETOLOG -eq 1 ]; then
			LOGLINE1_NUM=`echo "${LOGLINE1}" | wc -c | tr -d ' '`
			NUM_SPACES=`expr 62 - ${LOGLINE1_NUM}`
			test $NUM_SPACES -lt 1 && NUM_SPACES=1
			SPACES=`echo "${BLANK_LINE}" | cut -c1-$NUM_SPACES`

			LOGLINE1="${LOGLINE1}${SPACES}[ ${RESULT} ]"
		fi
	elif [ $WRITETOTTY -eq 1 -a -n "${COLOR}" ]; then
		LINE1="${COLOR}${LINE1}${NORMAL}"
	fi


	#
	# We can now output the message. We start with any required blank
	# lines, and then the first line. If this is a warning message we
	# write to the log file any additional lines.
	#

	if [ $WRITETOTTY -eq 1 ]; then
		NLLOOP=$NL
		while test $NLLOOP -gt 0; do
			echo ""
			NLLOOP=`expr ${NLLOOP} - 1`
		done

		echo $NEWECHOOPT "${LINE1}"
	fi

	if [ $WRITETOLOG -eq 1 ]; then
		echo $NEWECHOOPT "${LOGLINE1}" >>${LOGFILE}

		if [ $WARN_MSG -eq 1 ]; then
			test $SHOWWARNINGSONLY -eq 1 && echo $NEWECHOOPT "${LOGLINE1}" | cut -d' ' -f2-

			LINE1=1

			grep "^${MSG}:" ${LANG_FILE} 2>/dev/null | cut -d: -f2- | while read LOGLINE1; do
				if [ $LINE1 -eq 1 ]; then
					LINE1=0
					continue
				else
					test $SHOWWARNINGSONLY -eq 1 && echo $NEWECHOOPT "         ${LOGLINE1}"
					echo $NEWECHOOPT "           ${LOGLINE1}" >>${LOGFILE}
				fi
			done
		elif [ $SHOWWARNINGSONLY -eq 1 -a -n "`echo \"${LOGLINE1}\" | egrep '^\[([0-9][0-9]:){2}[0-9][0-9]\]         '`" ]; then
			echo $NEWECHOOPT "${LOGLINE1}" | cut -d' ' -f2-
		fi
	fi

	#
	# Output a final blank line if requested to do so.
	#

	test $WRITETOTTY -eq 1 -a $NLAFTER -eq 1 && echo ""

	return
}


keypresspause() {

	#
	# This function will display a prompt message to the user.
	#

	if [ $SKIP_KEY_PRESS -eq 0 -a $QUIET -eq 0 ]; then
		display --to SCREEN --type PLAIN --nl PRESSENTER
		read RKHTMPVAR
	fi

	return
}


# Logtext: add text to logfile
logtext() {
	test $NOLOG -eq 1 && return

	# Add date/time to logfile
	if [ "$1" = "--nodate" ]; then
		:
	elif [ "$1" = "--indent" ]; then
		echo -n "           " >>${LOGFILE}
	else
		echo -n "`date '+[%H:%M:%S] '`" >>${LOGFILE}
	fi

	NE1="n"
	[ "$1" = "-n" ] && NE1="y"
	[ "$1" = "-e" ] && NE1="y"

	if [ "$NE1" = "y" ]; then
		if [ "$MYSHELL" = "ksh" ]; then
			[ "$1" = "-n" ] &&  echo -n "$2" >>$LOGFILE || echo $ECHOOPT $2 >>$LOGFILE
		else
			echo $1 "$2" >>$LOGFILE
		fi
	else
		if [ "$1" = "--nodate" -o "$1" = "--indent" ]; then
			echo $ECHOOPT "$2" >>$LOGFILE
		else
			echo $ECHOOPT "$1" >>$LOGFILE
		fi
	fi
}


# Displaytext: display text to STDOUT
displaytext() {
	DODISPLAY=0
	FOUNDWARNING=0

	FOUNDWARNING1=`echo $ECHOOPT $1 | egrep 'BAD|Warning|WARNING'`
	FOUNDWARNING2=`echo $2 | egrep 'BAD|Warning|WARNING'`
	FOUNDWARNING3=`echo $3 | egrep 'BAD|Warning|WARNING'`

	if [ ! "${FOUNDWARNING1}" = "" -o ! "${FOUNDWARNING2}" = "" -o ! "${FOUNDWARNING3}" = "" ]; then
		FOUNDWARNING=1
		WARNING_COUNT=`expr ${WARNING_COUNT} + 1`
	fi

	[ $QUIET -eq 0 -o $FOUNDWARNING -eq 1 ] && DODISPLAY=1

	# Small change below to cater for OpenBSd with ksh.
	if [ "X$1" = "X-n" -o "X$1" = "X-e" ]; then
		if [ $DODISPLAY -eq 1 ]; then
			if [ -n "$PREVIOUSTEXT" ]; then
				echo -n "${PREVIOUSTEXT}"
				PREVIOUSTEXT=""
			fi
			if [ "$MYSHELL" = "ksh" ]; then
				[ "$1" = "-n" ] && echo -n "$2" || echo $ECHOOPT "$2"
			else
				echo $ECHOOPT $1 "$2"
			fi
		else
			[ "$1" = "-n" ] && PREVIOUSTEXT=`echo "$2" | sed -e 's/^ *//'`
		fi
	else
		if [ $DODISPLAY -eq 1 ]; then
			if [ -n "$PREVIOUSTEXT" ]; then
				echo -n "${PREVIOUSTEXT}"
				PREVIOUSTEXT=""
			fi
			echo $ECHOOPT "$1"
		fi
	fi
}


insertlayout() {
	if [ ${CRONJOB} -eq 0 ]; then
		LAYOUT="\033[${jump}C"
	else
		LAYOUT="  "
	fi
}


get_temp_file() {

	#
	# This function will create an empty, unique temporary file.
	#
	# It takes one argument which is the pathname for the file,
	# excluding the suffix. The function will return the pathname
	# in TEMPFILE.
	#

	TEMPFILE=""

	TEMPFILE_BASE=$1


	if [ -n "${MKTEMP_CMD}" ]; then
		TEMPFILE=`${MKTEMP_CMD} ${TEMPFILE_BASE}.XXXXXX`
	elif [ -n "$RANDOM" ]; then
		TEMPFILE="${TEMPFILE_BASE}.$RANDOM"
	else
		TEMPFILE="${TEMPFILE_BASE}.`date +%N%s%N`"
	fi


	#
	# Remove the file just in case it does already exist!
	#

	rm -f ${TEMPFILE} >/dev/null 2>&1

	return
}


suckit_extra_checks() {

	#
	# This function carries out some extra checks of the suckit rootkit.
	# There are 3 extra checks, but we only display the result after
	# all the checks have completed. As such we store the result of
	# each check in a variable, and display the final result based on
	# the value of those variables.
	#

	if [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --log-indent 2 --nl ROOTKIT_ADD_SUCKIT_LOG
	fi


	ROOTKIT_COUNT=`expr ${ROOTKIT_COUNT} + 1`

	#
	# The first check tests the link count of the /sbin/init file.
	# We use the NLINKs variable to indicate the test result:
	#	-1 means that no stat command was available
	#	 0 means that the stat command gave an error
	#	 1 is okay
	#	>1 means that suckit may be installed
	#

	NLINKS=-1

	if [ -n "${STAT_CMD}" ]; then
		if [ -n "`echo \"${STAT_CMD}\" | grep '\.pl$'`" ]; then
			NLINKS=`${STAT_CMD} --nlink /sbin/init 2>/dev/null`
		else
			NLINKS=`${STAT_CMD} -t /sbin/init 2>/dev/null | cut -d' ' -f9`
		fi

		test -z "${NLINKS}" && NLINKS=0

		if [ $VERBOSE_LOGGING -eq 1 ]; then
			if [ $NLINKS -eq 0 ]; then
				display --to LOG --type PLAIN --result WARNING --log-indent 4 ROOTKIT_ADD_SUCKIT_LINK
			elif [ $NLINKS -eq 1 ]; then
				display --to LOG --type PLAIN --result OK --log-indent 4 ROOTKIT_ADD_SUCKIT_LINK
			else
				display --to LOG --type PLAIN --result WARNING --log-indent 4 ROOTKIT_ADD_SUCKIT_LINK
			fi
		fi
	else
		display --to LOG --type PLAIN --result SKIPPED --log-indent 4 ROOTKIT_ADD_SUCKIT_LINK
	fi


	#
	# The next test checks to see if certain files are being
	# hidden. These files have the '.xrk' or '.mem' suffix.
	# The HIDDEN variable will be used to indicate the result:
	#	<null> is okay
	#	'xrk' means that the 'xrk' suffix is hidden
	#	'mem' means that the 'mem' suffix is hidden
	#

	HIDDEN=""

	for EXT in xrk mem; do
		get_temp_file "${TMPDIR}/suckitexttest"

		touch ${TEMPFILE}
		rm -f ${TEMPFILE}.${EXT} >/dev/null 2>&1
		mv ${TEMPFILE} ${TEMPFILE}.${EXT}

		if [ ! -f "${TEMPFILE}.${EXT}" ]; then
			if [ -n "${HIDDEN}" ]; then
				HIDDEN="${HIDDEN} and ${EXT}"
			else
				HIDDEN=${EXT}
			fi
		fi

		rm -f "${TEMPFILE}.${EXT}" >/dev/null 2>&1
	done

	if [ $VERBOSE_LOGGING -eq 1 ]; then
		if [ -z "${HIDDEN}" ]; then
			display --to LOG --type PLAIN --result NOT_FOUND --log-indent 4 ROOTKIT_ADD_SUCKIT_EXT
		else
			display --to LOG --type PLAIN --result FOUND --log-indent 4 ROOTKIT_ADD_SUCKIT_EXT
		fi
	fi


	#
	# Finally we perform a check using the skdet command, if it
	# is present. The SKDET variable will be used to indicate
	# the result:
	#	-1 means that skdet is not available
	#	 0 means that skdet found nothing
	#	 1 means that skdet found something
	#	 2 means that the version of skdet is unknown
	#
	# The variable SKDET_OUTPUT will contain any output from
	# the command.
	#

	SKDET=-1
	SKDET_OUTPUT=""
	SKDET_CMD=`find_cmd skdet`

	if [ -n "${SKDET_CMD}" ]; then
		#
		# We need to check the skdet version first.
		#

		SKDET=0
		SKDETOPT=""
		SKDETVER=`${SKDET_CMD} -v 2>&1 | grep '^skdet.v' | awk -F'.' '{ print $1 }'`

		case "${SKDETVER}" in
		*v0)
			SKDETOPT="-a"
			;;
		*v1)
			SKDETOPT="-c"
			;;
		*)
			SKDET=2
			SKDET_OUTPUT=`${SKDET_CMD} -v 2>&1`
			;;
		esac

		if [ $SKDET -eq 0 ]; then
			SKDET_OUTPUT=`${SKDET_CMD} ${SKDETOPT} 2>&1 | tr -s ' ' | grep -i 'invis'`

			test -n "${SKDET_OUTPUT}" && SKDET=1
		fi

		if [ $VERBOSE_LOGGING -eq 1 ]; then
			if [ $SKDET -eq 0 ]; then
				display --to LOG --type PLAIN --result OK --log-indent 4 ROOTKIT_ADD_SUCKIT_SKDET
			else
				display --to LOG --type PLAIN --result WARNING --log-indent 4 ROOTKIT_ADD_SUCKIT_SKDET
			fi
		fi
	elif [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --result SKIPPED --log-indent 4 ROOTKIT_ADD_SUCKIT_SKDET
		display --to LOG --type INFO NOT_FOUND_CMD "skdet"
	fi


	#
	# Now we can display the results.
	#

	if [ $NLINKS -eq 1 -a -z "${HIDDEN}" -a $SKDET -le 0 ]; then
		display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --screen-indent 4 --log-indent 2 ROOTKIT_ADD_SUCKIT
	else
		ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
		ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}Suckit Rookit (extra checks), "

		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 --log-indent 2 ROOTKIT_ADD_SUCKIT

		if [ $NLINKS -eq -1 ]; then
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_ADD_SUCKIT_LINK_NOCMD
		elif [ $NLINKS -eq 0 ]; then
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_ADD_SUCKIT_LINK_ERR
		elif [ $NLINKS -gt 1 ]; then
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_ADD_SUCKIT_LINK_FOUND "$NLINKS"
		fi

		if [ -n "${HIDDEN}" ]; then
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_ADD_SUCKIT_EXT_FOUND "${HIDDEN}"
		fi

		if [ $SKDET -eq 1 ]; then
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_ADD_SUCKIT_SKDET_FOUND "${SKDET_OUTPUT}"
		elif [ $SKDET -eq 2 ]; then
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_ADD_SUCKIT_SKDET_VER "${SKDET_OUTPUT}"
		fi
	fi

	return
}


scanrootkit() {

	#
	# This function performs the actual check for a rootkit.
	# It uses the variables SCAN_ROOTKIT, SCAN_FILES, SCAN_DIRS
	# and SCAN_KSYMS. These will have been set before the
	# function is called.
	#

	SCAN_STATUS=0

	ROOTKIT_COUNT=`expr ${ROOTKIT_COUNT} + 1`

	if [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --nl ROOTKIT_FILES_DIRS_NAME_LOG "${SCAN_ROOTKIT}"
	fi


	#
	# First check to see if any of the known files exist.
	#

	FILE_FOUND=""

	for RKHTMPVAR in ${SCAN_FILES}; do
		RKHTMPVAR=`echo "${RKHTMPVAR}" | tr -s '%' ' '`

		if [ -f "${RKHTMPVAR}" ]; then
			SCAN_STATUS=1
			FILE_FOUND="${FILE_FOUND} ${RKHTMPVAR}"

			if [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result FOUND --log-indent 2 ROOTKIT_FILES_DIRS_FILE "${RKHTMPVAR}"
			fi
		elif [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --result NOT_FOUND --log-indent 2 ROOTKIT_FILES_DIRS_FILE "${RKHTMPVAR}"
		fi
	done


	#
	# Next check to see if any of the directories exist.
	#

	DIR_FOUND=""

	for RKHTMPVAR in ${SCAN_DIRS}; do
		RKHTMPVAR=`echo "${RKHTMPVAR}" | tr -s '%' ' '`

		if [ -d "${RKHTMPVAR}" ]; then
			SCAN_STATUS=1
			DIR_FOUND="${DIR_FOUND} ${RKHTMPVAR}"

			if [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result FOUND --log-indent 2 ROOTKIT_FILES_DIRS_DIR "${RKHTMPVAR}"
			fi
		elif [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --result NOT_FOUND --log-indent 2 ROOTKIT_FILES_DIRS_DIR "${RKHTMPVAR}"
		fi
	done


	#
	# Next check the ksyms or kallsyms file.
	#

	KSYM_FOUND=""

	if [ -n "${SCAN_KSYMS}" ]; then
		for KS in ${SCAN_KSYMS}; do
			if [ -n "${KSYMS_FILE}" ]; then
				KSYM=`echo "${KS}" | sed -e 's/\./\\\./g'`

				if [ -n "`grep \"${KSYM}\" ${KSYMS_FILE}`" ]; then
					SCAN_STATUS=1
					KSYM_FOUND="${KSYM_FOUND} ${KS}"

					if [ $VERBOSE_LOGGING -eq 1 ]; then
						display --to LOG --type PLAIN --result FOUND  --log-indent 2 ROOTKIT_FILES_DIRS_KSYM "${KS}"
					fi
				elif [ $VERBOSE_LOGGING -eq 1 ]; then
					display --to LOG --type PLAIN --result NOT_FOUND --log-indent 2 ROOTKIT_FILES_DIRS_KSYM "${KS}"
				fi
			elif [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result SKIPPED --log-indent 2 ROOTKIT_FILES_DIRS_KSYM "${KS}"
			fi
		done
	fi


	#
	# Now display the results.
	#

	if [ $SCAN_STATUS -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 ROOTKIT_FILES_DIRS_NAME "${SCAN_ROOTKIT}"
	else
		ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
		ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}${SCAN_ROOTKIT}, "

		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 ROOTKIT_FILES_DIRS_NAME "${SCAN_ROOTKIT}"


		#
		# Log any files, directories or ksyms found.
		#

		for RKHTMPVAR in ${FILE_FOUND}; do
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_FILE_FOUND "${RKHTMPVAR}"
		done

		for RKHTMPVAR in ${DIR_FOUND}; do
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_DIR_FOUND "${RKHTMPVAR}"
		done

		for RKHTMPVAR in ${KSYM_FOUND}; do
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_KSYM_FOUND "${RKHTMPVAR}"
		done
	fi

	return
}


check_required_commands() {

	#
	# This function checks that some required commands are
	# present on the system. The function takes one argument
	# which is a list of directories to look in.
	#

	for CMD in ${REQCMDS}; do
		SEEN=0

		for DIR in $1; do
			if [ -f "${DIR}/${CMD}" -a -x "${DIR}/${CMD}" ]; then
				SEEN=1
				break
			fi
		done

		if [ $SEEN -eq 0 ]; then
			echo "The command '$CMD' must be present on the system in order to run rkhunter."
			exit 1
		fi
	done

	return
}


check_commands() {

	#
	# We check for some commands used in the tests. If the command
	# is found then a variable including the command name is set.
	# These commands are not 'required', so nothing happens if the
	# command is not found.
	#

	for CMD in ${CMDLIST}; do
		RKHTMPVAR=`echo ${CMD} | tr '[a-z]' '[A-Z]'`
		RKHTMPVAR="${RKHTMPVAR}_CMD"


		#
		# See if the user has defined the command in
		# the configuration file.
		#

		CFG_CMD=`grep "^${RKHTMPVAR}=" ${CONFIGFILE} | tail -1`

		if [ -n "${CFG_CMD}" ]; then
			CFG_CMD=`echo "${CFG_CMD}" | sed -e "s/${RKHTMPVAR}=//" | sed -e 's/^"\(.*\)"$/\1/' | tr -s ' '`

			if [ -z "${CFG_CMD}" -o "${CFG_CMD}" = " " ]; then
				CFG_CMD=""
			else
				#
				# check that the command is executable.
				#

				MCMD=`echo "${CFG_CMD}" | cut -d' ' -f1`

				if [ -n "`find_cmd ${MCMD}`" ]; then
					eval ${RKHTMPVAR}=\"${CFG_CMD}\"
				else
					CFG_CMD=""
				fi
			fi
		fi


		#
		# If the command has not been predefined, or is not
		# executable, then go find the command to use.
		#

		if [ -z "${CFG_CMD}" ]; then
			eval ${RKHTMPVAR}=`find_cmd ${CMD}`
		fi
	done


	#
	# If we cannot find a stat command, then see if we can use the
	# supplied perl script.
	#

	if [ -z "${STAT_CMD}" -a -n "${PERL_CMD}" ]; then
		MOD_INSTALLED=`${PERL_CMD} ${SCRIPT_PATH}/check_modules.pl File::stat Getopt::Long 2>&1 | grep 'NOT'`

		if [ -z "${MOD_INSTALLED}" ]; then
			STAT_CMD="${PERL_CMD} ${SCRIPT_PATH}/stat.pl"
		fi
	fi

	return
}


get_installdir_option() {

	#
	# This function obtains the RKH installation directory. It must
	# be set by the installer script, and has no default.
	#

	INSTALLDIR=`grep '^INSTALLDIR=' ${CONFIGFILE} | tail -1 | sed -e 's/INSTALLDIR=//' | tr -d '"' | tr -s ' '`

	if [ -z "${INSTALLDIR}" -o "${INSTALLDIR}" = " " ]; then
		echo "Invalid INSTALLDIR configuration option - no installation directory specified."
		exit 1
	elif [ ! -d "${INSTALLDIR}" ]; then
		echo "Installation directory does not exist: ${INSTALLDIR}"
		exit 1
	elif [ ! -r "${INSTALLDIR}" ]; then
		echo "Installation directory is not readable: ${INSTALLDIR}"
		exit 1
	fi

	return
}


get_language_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${LANGUAGE}" ]; then
		LANGUAGE=`echo "${LANGUAGE}" | tr -s ' '`

		if [ "${LANGUAGE}" = " " ]; then
			echo "Invalid --language option - no language given."
			exit 1
		fi
	else
		LANGUAGE=`grep '^LANGUAGE=' ${CONFIGFILE} | tail -1`

		if [ -n "${LANGUAGE}" ]; then
			LANGUAGE=`echo "${LANGUAGE}" | sed -e 's/LANGUAGE=//' | tr -d '"' | tr -s ' '`

			if [ -z "${LANGUAGE}" -o "${LANGUAGE}" = " " ]; then
				echo "Invalid LANGUAGE configuration option - no language specified."
				exit 1
			fi
		fi
	fi

	#
	# Now check that the language is available.
	#

	if [ ! -d "${DB_PATH}/i18n" ]; then
		echo "The internationalisation directory does not exist: ${DB_PATH}/i18n"
		exit 1
	elif [ ! -f "${DB_PATH}/i18n/${LANGUAGE}" ]; then
		echo "The language specified is not available: ${LANGUAGE}"
		echo "Use the '--list languages' option to see the list of available languages."
		exit 1
	fi

	return
}


get_logfile_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${LOGFILE}" ]; then
		LOGFILE=`echo "${LOGFILE}" | tr -s ' '`

		if [ "${LOGFILE}" = " " ]; then
			echo "Invalid --logfile option - no logfile name given."
			exit 1
		fi
	else
		LOGFILE=`grep '^LOGFILE=' ${CONFIGFILE} | tail -1`

		if [ -n "${LOGFILE}" ]; then
			LOGFILE=`echo "${LOGFILE}" | sed -e 's/LOGFILE=//' | tr -d '"' | tr -s ' '`

			if [ -z "${LOGFILE}" -o "${LOGFILE}" = " " ]; then
				echo "Invalid LOGFILE configuration option - no logfile name specified."
				exit 1
			fi
		else
			echo "Default logfile will be used ($DFLT_LOGFILE)."
			LOGFILE=$DFLT_LOGFILE
		fi
	fi

	#
	# Now check that the given option is useable.
	#

	if [ "${LOGFILE}" = "/dev/null" ]; then
		APPEND_LOG=0
	else
		LOGDIR=`echo "${LOGFILE}" | sed -e 's/\/[^/][^/]*$//'`

		if [ -z "`echo ${LOGDIR} | grep '/'`" ]; then
			LOGDIR="."
		fi

		if [ "${LOGDIR}" = "${LOGFILE}" ]; then
			echo "No log filename given: ${LOGFILE}"
			exit 1
		elif [ ! -d "${LOGDIR}" ]; then
			echo "Logfile directory does not exist: ${LOGFILE}"
			exit 1
		elif [ ! -w "${LOGDIR}" ]; then
			echo "Logfile directory is not writable: ${LOGFILE}"
			exit 1
		elif [ ! -r "${LOGDIR}" ]; then
			echo "Logfile directory is not readable: ${LOGFILE}"
			exit 1
		elif [ -h "${LOGFILE}" ]; then
			echo "Logfile is a symbolic link: ${LOGFILE}"
			echo "This is a security problem. The link points to another file, and that file is about to be modified by rkhunter."
			exit 1
		elif [ -e "${LOGFILE}" -a ! -f "${LOGFILE}" ]; then
			echo "Logfile already exists but it is not a file: ${LOGFILE}"
			exit 1
		fi

		#
		# Now check whether we should append to the logfile
		# or overwrite it. We check the configuration file
		# option, if it is given, and ensure that it is valid.
		#

		if [ $APPEND_OPT -eq 0 ]; then
			APPEND_LOG=`grep '^APPEND_LOG=' ${CONFIGFILE} | tail -1`

			if [ -n "${APPEND_LOG}" ]; then
				APPEND_LOG=`echo "${APPEND_LOG}" | sed -e 's/APPEND_LOG=//' | tr -d '"' | tr -s ' '`

				if [ -z "${APPEND_LOG}" -o "${APPEND_LOG}" = " " ]; then
					echo "Invalid APPEND_LOG configuration option - no value specified."
					exit 1
				elif [ "${APPEND_LOG}" != "0" -a "${APPEND_LOG}" != "1" ]; then
					echo "Invalid APPEND_LOG configuration option: ${APPEND_LOG}"
					exit 1
				fi
			else
				APPEND_LOG=0
			fi
		fi
	fi

	return
}


get_tmpdir_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${TMPDIR}" ]; then
		TMPDIR=`echo "${TMPDIR}" | tr -s ' '`

		if [ "${TMPDIR}" = " " ]; then
			echo "Invalid --tmpdir option - no directory name given."
			exit 1
		fi
	else
		TMPDIR=`grep '^TMPDIR=' ${CONFIGFILE} | tail -1`

		if [ -n "${TMPDIR}" ]; then
			TMPDIR=`echo "${TMPDIR}" | sed -e 's/TMPDIR=//' | tr -d '"' | tr -s ' '`

			if [ -z "${TMPDIR}" -o "${TMPDIR}" = " " ]; then
				echo "Invalid TMPDIR configuration option - no directory name specified."
				exit 1
			fi
		else
			TMPDIR="${INSTALLDIR}/lib/rkhunter/tmp"
		fi
	fi

	#
	# Now check that the given option is useable.
	#

	if [ ! -d "${TMPDIR}" ]; then
		echo "Temporary directory does not exist: ${TMPDIR}"
		exit 1
	elif [ ! -w "${TMPDIR}" ]; then
		echo "Temporary directory is not writable: ${TMPDIR}"
		exit 1
	elif [ ! -r "${TMPDIR}" ]; then
		echo "Temporary directory is not readable: ${TMPDIR}"
		exit 1
	elif [ "${TMPDIR}" = "${ROOTDIR}/tmp" -o "${TMPDIR}" = "${ROOTDIR}/var/tmp" ]; then
		echo "Do not use ${TMPDIR} as the temporary directory."
		echo "This directory will be used by rkhunter to contain system files, so it must be secure."
		exit 1
	elif [ "${TMPDIR}" = "${ROOTDIR}/etc" ]; then
		echo "Do not use ${TMPDIR} as the temporary directory."
		echo "This directory will be used by rkhunter to copy and delete certain system files."
		exit 1
	fi

	return
}


get_dbdir_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${DB_PATH}" ]; then
		DB_PATH=`echo "${DB_PATH}" | tr -s ' '`

		if [ "${DB_PATH}" = " " ]; then
			echo "Invalid --dbdir option - no directory name given."
			exit 1
		fi
	else
		DB_PATH=`grep '^DBDIR=' ${CONFIGFILE} | tail -1`

		if [ -n "${DB_PATH}" ]; then
			DB_PATH=`echo "${DB_PATH}" | sed -e 's/DBDIR=//' | tr -d '"' | tr -s ' '`

			if [ -z "${DB_PATH}" -o "${DB_PATH}" = " " ]; then
				echo "Invalid DBDIR configuration option - no directory name specified."
				exit 1
			fi
		else
			DB_PATH="${INSTALLDIR}/lib/rkhunter/db"
		fi
	fi

	#
	# Now check that the given option is useable.
	#

	if [ ! -d "${DB_PATH}" ]; then
		echo "Database directory does not exist: ${DB_PATH}"
		exit 1
	elif [ ! -w "${DB_PATH}" ]; then
		echo "Database directory is not writable: ${DB_PATH}"
		exit 1
	elif [ ! -r "${DB_PATH}" ]; then
		echo "Database directory is not readable: ${DB_PATH}"
		exit 1
	fi

	return
}


add_extra_dirs() {

	#
	# This functions takes care of any additional directories
	# that may exist on some systems. After the function is called
	# the value of EXTRA_DIRS must be added to whatever variable
	# is being used.
	#

	EXTRA_DIRS=""

	if [ "${OPERATING_SYSTEM}" = "SunOS" ]; then
		#
		# Add in some other directories, and those which
		# contain the Sun 'companion' software.
		#

		test -d /usr/sfw && EXTRA_DIRS="${EXTRA_DIRS} /usr/sfw/bin /usr/sfw/sbin /usr/sfw/libexec"

		test -d /opt/sfw && EXTRA_DIRS="${EXTRA_DIRS} /opt/sfw/bin /opt/sfw/sbin /opt/sfw/libexec"

		test -d /usr/xpg4/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/xpg4/bin"

		test -d /usr/ccs/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/ccs/bin"


		#
		# OpenSolaris distributions (e.g. BeleniX) may use
		# other directories.
		#

		test -d /usr/foss && EXTRA_DIRS="${EXTRA_DIRS} /usr/foss/bin /usr/foss/sbin /usr/foss/libexec"
	elif [ "${OPERATING_SYSTEM}" = "NetBSD" ]; then
		test -d /usr/pkg/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/pkg/bin"
		test -d /usr/pkg/sbin && EXTRA_DIRS="${EXTRA_DIRS} /usr/pkg/sbin"
		test -d /usr/pkg/libexec && EXTRA_DIRS="${EXTRA_DIRS} /usr/pkg/libexec"
	elif [ "${OPERATING_SYSTEM}" = "Darwin" ]; then
		#
		# Cater for Fink (Mac OS X) additional software.
		#

		test -d /sw/bin && EXTRA_DIRS="${EXTRA_DIRS} /sw/bin"
		test -d /sw/sbin && EXTRA_DIRS="${EXTRA_DIRS} /sw/sbin"
	fi


	#
	# Finally check if there are any optional
	# bin and sbin directories present.
	#

	test -d /usr/opt/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/opt/bin"
	test -d /usr/opt/sbin && EXTRA_DIRS="${EXTRA_DIRS} /usr/opt/sbin"
	test -d /opt/bin && EXTRA_DIRS="${EXTRA_DIRS} /opt/bin"
	test -d /opt/sbin && EXTRA_DIRS="${EXTRA_DIRS} /opt/sbin"

	return
}


get_bindir_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	USE_DFLT=0

	if [ -n "${BINPATHS}" ]; then
		BINPATHS=`echo "${BINPATHS}" | tr -s ' '`

		if [ "${BINPATHS}" = " " ]; then
			echo "Invalid --bindir option - no directory names given."
			exit 1
		fi
	else
		BINPATHS=`grep '^BINDIR=' ${CONFIGFILE} | tail -1`

		if [ -n "${BINPATHS}" ]; then
			BINPATHS=`echo "${BINPATHS}" | sed -e 's/BINDIR=//' | tr -d '"' | tr -s ' '`

			if [ -z "${BINPATHS}" -o "${BINPATHS}" = " " ]; then
				echo "Invalid BINDIR configuration option - no directory names specified."
				exit 1
			fi
		else
			USE_DFLT=1

			BINPATHS="${DFLT_BINPATHS}"


			#
			# Under SunOS /bin is a link to /usr/bin, so
			# there is no need to look in it.
			#

			if [ "${OPERATING_SYSTEM}" = "SunOS" -o "${OPERATING_SYSTEM}" = "AIX" ]; then
				if [ -h /bin ]; then
					B=""

					for DIR in ${BINPATHS}; do
						test "${DIR}" != "/bin" && B="${B} ${DIR}"
					done

					BINPATHS=`echo ${B} | sed -e 's/^ *//'`
				fi
			fi


			add_extra_dirs
			BINPATHS="${BINPATHS}${EXTRA_DIRS}"
		fi
	fi


	#
	# This is a simple check that each directory begins with
	# a '.' or '/'. We allow non-existent directories because
	# this list may be used with ROOTDIR. As such the directory
	# may not exist on the local host, but may exist on a
	# remotely diagnosed system.
	#

	for DIR in ${BINPATHS}; do
		if [ -z "`echo ${DIR} | grep '^[./]'`" ]; then
			echo "Invalid BINDIR directory: ${DIR}"
			exit 1
		fi
	done

	return
}


get_scriptdir_option() {

	#
	# Get the value from the configuration file, and do a simple
	# check on whether it is empty or a space.
	#
	# Note: The installer will set this option. As such there
	# is no default.
	#

	SCRIPT_PATH=`grep '^SCRIPTDIR=' ${CONFIGFILE} | tail -1`

	if [ -n "${SCRIPT_PATH}" ]; then
		SCRIPT_PATH=`echo "${SCRIPT_PATH}" | sed -e 's/SCRIPTDIR=//' | tr -d '"' | tr -s ' '`

		if [ -z "${SCRIPT_PATH}" -o "${SCRIPT_PATH}" = " " ]; then
			echo "Invalid SCRIPTDIR configuration option - no directory name specified."
			exit 1
		fi
	else
		echo "The SCRIPTDIR configuration option has not been set by the installer."
		exit 1
	fi

	#
	# Now check that the given option is useable.
	#

	if [ ! -d "${SCRIPT_PATH}" ]; then
		echo "Script directory does not exist: ${SCRIPT_PATH}"
		exit 1
	elif [ ! -r "${SCRIPT_PATH}" ]; then
		echo "Script directory is not readable: ${SCRIPT_PATH}"
		exit 1
	fi

	return
}


find_cmd() {

	#
	# This function performs a search of the PATH and BINPATHS
	# directories looking for the requested command. The full
	# pathname is returned if the command is found.
	#
	# If a full pathname is provided then we simply check that
	# it is executable.
	#

	CMD=$1

	test -z "${CMD}" && return

	if [ -n "`echo ${CMD} | grep '/'`" ]; then
		test -f "${CMD}" -a -x "${CMD}" && echo "${CMD}"
	else
		for CMDDIR in ${SPACEDPATH} ${BINPATHS}; do
			if [ -f "${CMDDIR}/${CMD}" -a -x "${CMDDIR}/${CMD}" ]; then
				echo "${CMDDIR}/${CMD}"
				return
			fi
		done
	fi

	return
}


get_rootdir_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${ROOTDIR}" ]; then
		ROOTDIR=`echo "${ROOTDIR}" | tr -s ' '`

		if [ "${ROOTDIR}" = " " ]; then
			echo "Invalid --rootdir option - no directory name given."
			exit 1
		fi
	else
		ROOTDIR=`grep '^ROOTDIR=' ${CONFIGFILE} | tail -1`

		if [ -n "${ROOTDIR}" ]; then
			ROOTDIR=`echo "${ROOTDIR}" | sed -e 's/ROOTDIR=//' | tr -d '"' | tr -s ' '`

			if [ -z "${ROOTDIR}" -o "${ROOTDIR}" = " " ]; then
				echo "Invalid ROOTDIR configuration option - no directory name specified."
				exit 1
			fi
		fi
	fi

	#
	# Now check that the given option is useable.
	#

	if [ -n "${ROOTDIR}" ]; then
		if [ ! -d "${ROOTDIR}" ]; then
			echo "The root directory does not exist: ${ROOTDIR}"
			exit 1
		elif [ ! -r "${ROOTDIR}" ]; then
			echo "The root directory is not readable: ${ROOTDIR}"
			exit 1
		fi
	fi

	return
}


get_mailonwarn_option() {

	#
	# Get the option from the configuration file, and do a simple
	# check on whether it is empty or a space.
	#

	MAILONWARNING=`grep '^MAIL-ON-WARNING=' ${CONFIGFILE} | tail -1`

	if [ -n "${MAILONWARNING}" ]; then
		MAILONWARNING=`echo "${MAILONWARNING}" | sed -e 's/MAIL-ON-WARNING=//' | tr -d '"' | tr -s ' '`

		if [ -z "${MAILONWARNING}" -o "${MAILONWARNING}" = " " ]; then
			echo "Invalid MAIL-ON-WARNING configuration option - no email address specified."
			exit 1
		fi
	fi


	if [ -n "${MAILONWARNING}" ]; then
		MAIL_CMD=`grep '^MAIL_CMD=' ${CONFIGFILE} | tail -1`

		if [ -n "${MAIL_CMD}" ]; then
			MAIL_CMD=`echo "${MAIL_CMD}" | sed -e 's/MAIL_CMD=//' | sed -e 's/^"\(.*\)"$/\1/' | tr -s ' '`

			if [ -z "${MAIL_CMD}" -o "${MAIL_CMD}" = " " ]; then
				echo "Invalid MAIL_CMD configuration option - no command specified."
				exit 1
			fi
		else
			MAIL_CMD="mail -s \"[rkhunter] Warnings found for \${HOST_NAME}\""
		fi


		#
		# Check that the mail command is executable.
		#

		MCMD=`echo "${MAIL_CMD}" | cut -d' ' -f1`
		MC=`find_cmd ${MCMD}`

		if [ -n "${MC}" ]; then
			#
			# We rebuild the command to use the full pathname.
			#

			MCMD=`echo "${MAIL_CMD}" | cut -d' ' -f2-`

			if [ -z "${MCMD}" -o "${MCMD}" = "${MAIL_CMD}" ]; then
				MAIL_CMD=$MC
			else
				MAIL_CMD="${MC} ${MCMD}"
			fi
		else
			echo "Invalid MAIL_CMD configuration option - command '${MCMD}' is non-existent or not executable."
			exit 1
		fi
	fi

	return
}


get_syslog_option() {

	#
	# First see if we want to use syslog or not from the command-line
	# or configuration file.
	#

	if [ -n "${USE_SYSLOG}" ]; then
		USE_SYSLOG=`echo "${USE_SYSLOG}" | tr -s ' '`

		if [ "${USE_SYSLOG}" = " " ]; then
			echo "Invalid --syslog option - no facility/priority names given."
			exit 1
		fi
	else
		USE_SYSLOG=`grep '^USE_SYSLOG=' ${CONFIGFILE} | tail -1`

		if [ -n "${USE_SYSLOG}" ]; then
			USE_SYSLOG=`echo "${USE_SYSLOG}" | sed -e 's/USE_SYSLOG=//' | tr -d '"' | tr -s ' '`

			if [ -z "${USE_SYSLOG}" -o "${USE_SYSLOG}" = " " ]; then
				echo "Invalid USE_SYSLOG configuration option - no value specified."
				exit 1
			fi
		fi
	fi


	#
	# If we are to use syslog, then get the facility and priority levels.
	# Additionally, test that they are valid.
	#

	if [ -n "${USE_SYSLOG}" ]; then
		USE_SYSLOG=`echo "${USE_SYSLOG}" | tr '[A-Z]' '[a-z]'`

		if [ "${USE_SYSLOG}" = "none" ]; then
			return
		elif [ -z "`echo \"${USE_SYSLOG}\" | grep '^[a-z][a-z0-7]*\.[a-z][a-z]*$'`" ]; then
			echo "Invalid syslog facility/priority value: ${USE_SYSLOG}"
			exit 1
		fi

		FOUND=0

		SYSLOG_F=`echo "${USE_SYSLOG}" | cut -d. -f1`
		SYSLOG_P=`echo "${USE_SYSLOG}" | cut -d. -f2`

		for RKHTMPVAR in auth authpriv cron daemon kern user local0 local1 local2 local3 local4 local5 local6 local7; do
			if [ "${SYSLOG_F}" = "${RKHTMPVAR}" ]; then
				FOUND=1
				break
			fi
		done

		if [ $FOUND -eq 0 ]; then
			echo "Invalid syslog facility name: ${SYSLOG_F}"
			exit 1
		fi


		FOUND=0

		for RKHTMPVAR in debug info notice warning err crit alert emerg; do
			if [ "${SYSLOG_P}" = "${RKHTMPVAR}" ]; then
				FOUND=1
				break
			fi
		done

		if [ $FOUND -eq 0 ]; then
			echo "Invalid syslog priority name: ${SYSLOG_P}"
			exit 1
		fi
	fi

	return
}


get_ssh_options() {

	#
	# We check for two SSH options in this function. Both can only
	# be set in the configuration file.
	#

	#
	# See if the ALLOW_SSH_ROOT_USER option is specified in the
	# configuration file. If it is then we do a simple check on
	# whether it is empty, a space, or not 0 or 1.
	#

	ALLOW_SSH_ROOT_USER=`grep '^ALLOW_SSH_ROOT_USER=' ${CONFIGFILE} | tail -1`

	if [ -n "${ALLOW_SSH_ROOT_USER}" ]; then
		ALLOW_SSH_ROOT_USER=`echo "${ALLOW_SSH_ROOT_USER}" | sed -e 's/ALLOW_SSH_ROOT_USER=//' | tr -d '"' | tr -s ' '`

		if [ -z "${ALLOW_SSH_ROOT_USER}" -o "${ALLOW_SSH_ROOT_USER}" = " " ]; then
			echo "Invalid ALLOW_SSH_ROOT_USER configuration option - no value specified."
			exit 1
		elif [ "${ALLOW_SSH_ROOT_USER}" != "0" -a "${ALLOW_SSH_ROOT_USER}" != "1" ]; then
			echo "Invalid ALLOW_SSH_ROOT_USER configuration option: ${ALLOW_SSH_ROOT_USER}"
			exit 1
		fi
	else
		ALLOW_SSH_ROOT_USER=0
	fi


	#
	# See if the ALLOW_SSH_PROT_V1 option is specified in the
	# configuration file. If it is then we do a simple check on
	# whether it is empty, a space, or not 0 or 1.
	#

	ALLOW_SSH_PROT_V1=`grep '^ALLOW_SSH_PROT_V1=' ${CONFIGFILE} | tail -1`

	if [ -n "${ALLOW_SSH_PROT_V1}" ]; then
		ALLOW_SSH_PROT_V1=`echo "${ALLOW_SSH_PROT_V1}" | sed -e 's/ALLOW_SSH_PROT_V1=//' | tr -d '"' | tr -s ' '`

		if [ -z "${ALLOW_SSH_PROT_V1}" -o "${ALLOW_SSH_PROT_V1}" = " " ]; then
			echo "Invalid ALLOW_SSH_PROT_V1 configuration option - no value specified."
			exit 1
		elif [ "${ALLOW_SSH_PROT_V1}" != "0" -a "${ALLOW_SSH_PROT_V1}" != "1" ]; then
			echo "Invalid ALLOW_SSH_PROT_V1 configuration option: ${ALLOW_SSH_PROT_V1}"
			exit 1
		fi
	else
		ALLOW_SSH_PROT_V1=0
	fi

	return
}


get_auto_x_option() {

	#
	# For the second colour set we first see if the auto X detect option
	# has been set. If it is set, and X is in use, then the second colour
	# set is used. If X is not in use, or the auto detect option is not
	# set, then we only use the second colour set if the command-line
	# option is used or it is configured in the configuration file.
	#

	if [ $AUTO_X_OPT -eq 0 ]; then
		AUTO_X_DTCT=`grep '^AUTO_X_DETECT=' ${CONFIGFILE} | tail -1`

		if [ -n "${AUTO_X_DTCT}" ]; then
			AUTO_X_DTCT=`echo "${AUTO_X_DTCT}" | sed -e 's/AUTO_X_DETECT=//' | tr -d '"' | tr -s ' '`

			if [ -z "${AUTO_X_DTCT}" -o "${AUTO_X_DTCT}" = " " ]; then
				echo "Invalid AUTO_X_DETECT configuration option - no value specified."
				exit 1
			elif [ "${AUTO_X_DTCT}" != "0" -a "${AUTO_X_DTCT}" != "1" ]; then
				echo "Invalid AUTO_X_DETECT configuration option: ${AUTO_X_DTCT}"
				exit 1
			fi
		else
			AUTO_X_DTCT=0
		fi
	fi


	if [ $AUTO_X_DTCT -eq 1 -a -n "$DISPLAY" ]; then
		CLRSET2=1
	fi


	if [ $CLRSET2 -eq 0 ]; then
		CLRSET2=`grep '^COLOR_SET2=' ${CONFIGFILE} | tail -1`

		if [ -n "${CLRSET2}" ]; then
			CLRSET2=`echo "${CLRSET2}" | sed -e 's/COLOR_SET2=//' | tr -d '"' | tr -s ' '`

			if [ -z "${CLRSET2}" -o "${CLRSET2}" = " " ]; then
				echo "Invalid COLOR_SET2 configuration option - no value specified."
				exit 1
			elif [ "${CLRSET2}" != "0" -a "${CLRSET2}" != "1" ]; then
				echo "Invalid COLOR_SET2 configuration option: ${CLRSET2}"
				exit 1
			fi
		else
			CLRSET2=0
		fi
	fi

	return
}


get_enable_option() {

	#
	# If the option is not specified on the command-line, then
	# get it from the configuration file. We validate the test
	# names given against the list of known test names. By default
	# all tests are enabled.
	#

	if [ $ENDIS_OPT -eq 1 ]; then
		if [ -n "${ENABLE_TESTS}" ]; then
			ENABLE_TESTS=`echo "${ENABLE_TESTS}" | tr ',' ' ' | tr -s ' ' | tr '[A-Z]' '[a-z]'`

			if [ "${ENABLE_TESTS}" = " " ]; then
				echo "Invalid --enable option - no test names given."
				exit 1
			fi


			#
			# We do a simple test here to see if just one test
			# name was given. If it was then we skip the key
			# press feature since it is most likely that the user
			# doesn't want that. We also check that only the
			# --enable option has been given, and that the test
			# name is not 'all'.
			#

			if [ "${ENABLE_TESTS}" != "all" -a -z "`echo \"${ENABLE_TESTS}\" | grep ' '`" ]; then
				SKIP_KEY_PRESS=1
			fi
		fi
	else
		ENABLE_TESTS=`grep '^ENABLE_TESTS=' ${CONFIGFILE} | tail -1`

		if [ -n "${ENABLE_TESTS}" ]; then
			ENABLE_TESTS=`echo "${ENABLE_TESTS}" | sed -e 's/ENABLE_TESTS=//' | tr -d '"' | tr ',' ' ' | tr -s ' ' | tr '[A-Z]' '[a-z]'`

			if [ -z "${ENABLE_TESTS}" -o "${ENABLE_TESTS}" = " " ]; then
				echo "Invalid ENABLE_TESTS configuration option - no test names specified."
				exit 1
			fi
		fi
	fi

	test -z "${ENABLE_TESTS}" && ENABLE_TESTS="all"


	#
	# We now need to look for group names in our list, and expand
	# them to the individual test names. This allows us to then
	# check against specific test names as well as group names.
	# We also need to check if a given test name is part of a group.
	# If it is, then we must add the group name.
	#

	for TEST_NAME in ${ENABLE_TESTS}; do
		if [ "${TEST_NAME}" = "all" ]; then
			ENABLE_TESTS="all"
			break
		fi

		for RKHTMPVAR in ${GROUPED_TESTS}; do
			GROUP_NAME=`echo "${RKHTMPVAR}" | cut -d: -f1`

			if [ -n "`echo \"${RKHTMPVAR}\" | grep ':'`" ]; then
				GROUP_TESTS=`echo "${RKHTMPVAR}" | cut -d: -f2-`
			else
				GROUP_TESTS=""
			fi

			if [ "${TEST_NAME}" = "${GROUP_NAME}" ]; then
				ENABLE_TESTS="${ENABLE_TESTS} `echo \"${GROUP_TESTS}\" | tr ':' ' '`"
				break
			elif [ -z "${GROUP_TESTS}" ]; then
				continue
			elif [ -n "`echo \"${GROUP_TESTS}\" | egrep \"(^|:)${TEST_NAME}(:|$)\"`" ]; then
				ENABLE_TESTS="${ENABLE_TESTS} ${GROUP_NAME}"
			fi
		done
	done


	#
	# Check that the names we have been given are valid.
	#

	for TEST_NAME in ${ENABLE_TESTS}; do
		if [ "${TEST_NAME}" = "none" ]; then
			echo "'none' cannot be used in the enable test list."
			exit 1
		elif [ -z "`echo \"all ${KNOWN_TESTS}\" | egrep \"(^| )${TEST_NAME}( |$)\"`" ]; then
			echo "Unknown enable test name given: ${TEST_NAME}"
			exit 1
		fi
	done

	return
}


get_disable_option() {

	#
	# If the option is not specified on the command-line, then
	# get it from the configuration file. We validate the test
	# names given against the list of known test names. By default
	# no tests are disabled.
	#
	# Note: disabled tests are always compared against the list
	# of enabled tests. Hence, if we used
	#      'rkhunter -c --enable system_commands --disable apps'
	# then only the system command tests are run. Any other test is
	# not run because it is not in the '--enable' list. As such
	# the '--disable' option in the example above is not necessary.
	#

	if [ $ENDIS_OPT -eq 1 ]; then
		if [ -n "${DISABLE_TESTS}" ]; then
			DISABLE_TESTS=`echo "${DISABLE_TESTS}" | tr ',' ' ' | tr -s ' ' | tr '[A-Z]' '[a-z]'`

			if [ "${DISABLE_TESTS}" = " " ]; then
				echo "Invalid --disable option - no test names given."
				exit 1
			fi
		fi
	else
		DISABLE_TESTS=`grep '^DISABLE_TESTS=' ${CONFIGFILE} | tail -1`

		if [ -n "${DISABLE_TESTS}" ]; then
			DISABLE_TESTS=`echo "${DISABLE_TESTS}" | sed -e 's/DISABLE_TESTS=//' | tr -d '"' | tr ',' ' ' | tr -s ' ' | tr '[A-Z]' '[a-z]'`

			if [ -z "${DISABLE_TESTS}" -o "${DISABLE_TESTS}" = " " ]; then
				echo "Invalid DISABLE_TESTS configuration option - no test names specified."
				exit 1
			fi
		fi
	fi

	test -z "${DISABLE_TESTS}" && DISABLE_TESTS="none"


	#
	# Note that we do not need to check the disabled test names
	# against the group names. If a disabled test name does not appear
	# in the enabled list then it will, by default, be ignored. If
	# a group name appears in the enabled and disabled lists, then
	# it will be disabled.
	#
	# Check that the names we have been given are valid.
	#

	for TEST_NAME in ${DISABLE_TESTS}; do
		if [ "${TEST_NAME}" = "all" ]; then
			echo "'all' cannot be used in the disable test list."
			exit 1
		elif [ "${TEST_NAME}" = "none" ]; then
			DISABLE_TESTS="none"
			break
		elif [ -z "`echo \"all none ${KNOWN_TESTS}\" | egrep \"(^| )${TEST_NAME}( |$)\"`" ]; then
			echo "Unknown disable test name given: ${TEST_NAME}"
			exit 1
		fi
	done

	return
}


get_xinetd_option() {

	#
	# This function obtains the inetd and xinetd configuration
	# file pathnames from the config file. It also get the
	# whitelisted services.
	#

	FNAME=`grep '^INETD_CONF_PATH=' ${CONFIGFILE} | tail -1`

	if [ -n "${FNAME}" ]; then
		INETD_CONF_PATH=`echo "${FNAME}" | sed -e 's/INETD_CONF_PATH=//' | tr -d '"' | tr -s ' '`

		if [ -z "${INETD_CONF_PATH}" -o "${INETD_CONF_PATH}" = " " ]; then
			echo "Invalid INETD_CONF_PATH configuration option - no pathname specified."
			exit 1
		fi
	fi

	INETDALLOWEDSVCS=`grep '^INETD_ALLOWED_SVC=' ${CONFIGFILE} | sed -e 's/INETD_ALLOWED_SVC=//g' | tr -d '"'`


	#
	# Now do the same for xinetd.
	#

	FNAME=`grep '^XINETD_CONF_PATH=' ${CONFIGFILE} | tail -1`

	if [ -n "${FNAME}" ]; then
		XINETD_CONF_PATH=`echo "${FNAME}" | sed -e 's/XINETD_CONF_PATH=//' | tr -d '"' | tr -s ' '`

		if [ -z "${XINETD_CONF_PATH}" -o "${XINETD_CONF_PATH}" = " " ]; then
			echo "Invalid XINETD_CONF_PATH configuration option - no pathname specified."
			exit 1
		fi
	fi

	XINETDALLOWEDSVCS=`grep '^XINETD_ALLOWED_SVC=' ${CONFIGFILE} | sed -e 's/XINETD_ALLOWED_SVC=//g' | tr -d '"'`

	return
}


get_if_prelinked() {

	#
	# If the system appears to be using prelinking, but no
	# prelink command can be found, then we simply skip the
	# file properties hash check.
	#
	LIBSAFE_TEST1=""
	LIBSAFE_TEST2=""

	if [ -f "${ROOTDIR}/etc/prelink.cache" ]; then
		PRELINK_CMD=`find_cmd prelink`

		# Test (twice) for existance of Libsafe since this seems to
		# riddle prelink test results with "dependency cycle" errors.
		# Don't test for existance of /lib/libsafe since it may be
		# installed elsewhere.
		# If Libsafe is found *and* this is a prelink system, we'll
		# skip the prelink test.
		#
		if [ -f "${ROOTDIR}/etc/ld.so.preload" ]; then
			LIBSAFE_TEST1=`grep libsafe ${ROOTDIR}/etc/ld.so.preload 2>&1`
		fi

		if [ -n "${LDD_CMD}" -a -f "${ROOTDIR}/lib/libdl.so.?" ]; then
			LIBSAFE_TEST2=`${LDD_CMD} ${ROOTDIR}/lib/libdl.so.? | grep libsafe 2>&1`
		fi

		if [ -z "${PRELINK_CMD}" ]; then
			SKIP_HASH_MSG=1
		elif [ -z "${LIBSAFE_TEST1}" -a -z "${LIBSAFE_TEST2}" ]; then
			PRELINKED=1

			RUNCON_CMD=`find_cmd runcon`

			if [ -n "${RUNCON_CMD}" ]; then
				PRELINK_CMD="${RUNCON_CMD} -t unconfined_t -- ${PRELINK_CMD}"
			fi
		elif [ -n "${LIBSAFE_TEST1}" -a -n "${LIBSAFE_TEST2}" ]; then
			SKIP_HASH_MSG=3
		fi
	fi

	return
}


get_hash_function() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${HASH_FUNC}" ]; then
		HASH_FUNC=`echo "${HASH_FUNC}" | tr -s ' '`

		if [ "${HASH_FUNC}" = " " ]; then
			echo "Invalid --hash option - no command given."
			exit 1
		fi
	else
		HASH_FUNC=`grep '^HASH_FUNC=' ${CONFIGFILE} | tail -1`

		if [ -n "${HASH_FUNC}" ]; then
			HASH_FUNC=`echo "${HASH_FUNC}" | sed -e 's/HASH_FUNC=//' | sed -e 's/^"\(.*\)"$/\1/' | tr -s ' '`

			if [ -z "${HASH_FUNC}" -o "${HASH_FUNC}" = " " ]; then
				echo "Invalid HASH_FUNC configuration option - no command specified."
				exit 1
			fi
		fi
	fi


	#
	# At this point we have either been given a hash function
	# command, one of the reserved words 'SHA1' or 'MD5', or
	# nothing. For the reserved words we must find the SHA1 or
	# MD5 command or use the supplied perl scripts.
	#

	if [ -z "${HASH_FUNC}" -o "${HASH_FUNC}" = "SHA1" ]; then
		HF=`find_cmd sha1sum`

		if [ -z "${HF}" ]; then
			HF=`find_cmd sha1`

			if [ "${HF}" = "/usr/bin/sha1" -a "${OPERATING_SYSTEM}" = "NetBSD" ]; then
				HF="${HF} -n"
			fi
		fi

		if [ -z "${HF}" -a -n "${PERL_CMD}" ]; then
			MOD_INSTALLED=`${PERL_CMD} ${SCRIPT_PATH}/check_modules.pl Digest::SHA1 2>&1 | grep 'Digest::SHA1 installed'`

			if [ -n "${MOD_INSTALLED}" ]; then
				HASH_FUNC="${PERL_CMD} ${SCRIPT_PATH}/filehashsha1.pl"
			else
				HASH_FUNC=""
			fi
		else
			HASH_FUNC=$HF
		fi
	fi


	#
	# If we still have no hash function, then look for an MD5 command.
	#

	if [ -z "${HASH_FUNC}" -o "${HASH_FUNC}" = "MD5" ]; then
		HF=`find_cmd md5sum`

		if [ -z "${HF}" ]; then
			HF=`find_cmd md5`

			if [ "${OPERATING_SYSTEM}" = "NetBSD" -a "${HF}" = "/usr/bin/md5" ]; then
				HF="${HF} -n"
			fi
		fi

		if [ -z "${HF}" -a -n "${PERL_CMD}" ]; then
			MOD_INSTALLED=`${PERL_CMD} ${SCRIPT_PATH}/check_modules.pl Digest::MD5 2>&1 | grep 'Digest::MD5 installed'`

			if [ -n "${MOD_INSTALLED}" ]; then
				HASH_FUNC="${PERL_CMD} ${SCRIPT_PATH}/filehashmd5.pl"
			else
				HASH_FUNC=""
			fi
		else
			HASH_FUNC=$HF
		fi
	fi


	#
	# A final check that the command is actually executable.
	# This will ensure that the sha1/md5 perl scripts have been
	# installed correctly, should they be needed.
	#

	if [ -n "${HASH_FUNC}" ]; then
		HCMD=`echo "${HASH_FUNC}" | cut -d' ' -f1`
		HF=`find_cmd ${HCMD}`

		if [ -n "${HF}" ]; then
			#
			# We rebuild the command to use the full pathname.
			#

			HCMD=`echo "${HASH_FUNC}" | cut -d' ' -f2-`

			if [ -z "${HCMD}" -o "${HCMD}" = "${HASH_FUNC}" ]; then
				HASH_FUNC=$HF
			else
				HASH_FUNC="${HF} ${HCMD}"
			fi
		else
			echo "Invalid hash option - command '${HCMD}' is non-existent or not executable."
			exit 1
		fi
	fi

	return
}


get_scan_mode_dev_option() {

	#
	# SCAN_MODE_DEV governs how we scan /dev for suspicious files.
	# The two allowed options are "commented out" or LAZY.
	# If commented out, the default, we do a thorough scan which
	# will increase the runtime of rkhunter.
	#

	#
	# See if the option is specified in the configuration file.
	# If it is then we do a simple check on whether it is empty,
	# a space.
	#

	SCAN_MODE_DEV=`grep '^SCAN_MODE_DEV=' ${CONFIGFILE} | tail -1`

	if [ -n "${SCAN_MODE_DEV}" ]; then
		SCAN_MODE_DEV=`echo "${SCAN_MODE_DEV}" | sed -e 's/SCAN_MODE_DEV=//' | tr -d '"' | tr -s ' ' | tr '[a-z]' '[A-Z]'`

		case "${SCAN_MODE_DEV}" in
		THOROUGH|LAZY)
			SCAN_MODE_DEV="${SCAN_MODE_DEV}"
			;;
		*)	# Don't make this fatal.
			echo "Invalid SCAN_MODE_DEV configuration option: ${SCAN_MODE_DEV}"
			echo "Defaulting to THOROUGH mode."

			SCAN_MODE_DEV="THOROUGH"
			;;
		esac
	else
		SCAN_MODE_DEV="THOROUGH"
	fi

	return
}


get_configfile_options() {

	#
	# We call separate functions to process each option. The option
	# is checked first to see if it has been given on the command-line,
	# and, if not, then if it is specified in the configuration file.
	# Note that some of these functions are in a specific order. If you
	# change them around, then make sure the functions still work
	# correctly.
	#

	get_installdir_option

	get_bindir_option

	get_logfile_option

	get_rootdir_option

	get_tmpdir_option

	get_dbdir_option

	get_language_option

	get_scriptdir_option

	get_auto_x_option

	#
	# Now that we have processed BINDIR, we will recheck the
	# required commands.
	#
	# Before proceeding too far we also check that we have certain
	# commands available. Typically these are commands which might
	# not have been installed as part of the core system, but are
	# used by RKH. These commands are not 'required' though.
	#

	check_required_commands "${BINPATHS}"

	check_commands


	#
	# Some options are only required when checking the system.
	#

	if [ $CHECK -eq 1 ]; then
		test $NOMOW -eq 0 && get_mailonwarn_option

		get_ssh_options

		get_syslog_option

		get_scan_mode_dev_option


		#
		# See if we are only to perform specific tests.
		#

		get_enable_option
		get_disable_option

		check_test hashes && HASH_CHECK_ENABLED=1

		check_test trojan && get_xinetd_option
	fi


	#
	# We only need the hash function option if we are going
	# to be checking the system or updating the file
	# properties database.
	#

	if [ $HASH_CHECK_ENABLED -eq 1 -o $PROP_UPDATE -eq 1 ]; then

		#
		# For the file properties hash check we need to find out
		# if we are a prelinked system, and if so, then find out
		# which hash function to use. We also need to find the
		# 'stat' command.
		#

		get_if_prelinked

		test $SKIP_HASH_MSG -eq 0 && get_hash_function
	fi

	return
}


rkh_dat_set_version() {

	#
	# This function calculates and writes out the 'Version:' value
	# for the rkhunter.dat file. It looks for an old value, and adds
	# one to it. If there is no value then simply start at one.
	#

	TODAY=`date +%Y%m%d`

	OLDVER=`grep -i '^Version:' ${RKHDAT_FILE} 2>/dev/null | tail -1 | cut -d: -f2`

	if [ -n "${OLDVER}" ]; then
		OLDVER=`echo "${OLDVER}" | cut -c9-10`

		if [ "${OLDVER}" = "99" ]; then
			NEWVER="00"
		else
			NEWVER=`expr ${OLDVER} + 1`
			test $NEWVER -lt 10 && NEWVER="0${NEWVER}"
		fi
	else
		NEWVER="00"
	fi

	echo "Version:${TODAY}${NEWVER}" >>${RKHDAT_FILE}

	return
}


rkh_dat_get_os_info() {

	#
	# This function obtains information about the local computer
	# system. This is then written into the rkhunter.dat file
	# using a simple 'keyword:<value>' format. The OSNAME and
	# ARCH values are not important, but are simply used to check
	# whether they have changed since RKH was last run.
	#
	# Obtaining the OSNAME is somewhat tricky. There is no sure
	# way of finding the information, so we have to use some tricks
	# to locate the correct file. First we look for certain specific
	# O/S release files, and then at the /etc/release file, but not
	# if it is a link. Next we look for a generic /etc/*-release
	# file, again not as a link. This should find most O/S versions.
	# Overall this should also save users having to ask us to support
	# their O/S. In other cases, we will have to ask what file does
	# contain their O/S release information.
	#

	ARCH=`uname -m 2>/dev/null`

	REL_FILES="${ROOTDIR}/etc/lsb-release ${ROOTDIR}/etc/debian_version ${ROOTDIR}/etc/slackware-version ${ROOTDIR}/var/ipcop/general-functions.pl ${ROOTDIR}/etc/release ${ROOTDIR}/etc/*-release"

	for FNAME in ${REL_FILES}; do
		if [ -f "${FNAME}" -a ! -h "${FNAME}" ]; then
			RELEASE=$FNAME

			case "${RELEASE}" in
			${ROOTDIR}/etc/lsb-release)
				OSNAME=`cat ${RELEASE} | grep '^DISTRIB_DESCRIPTION=' | sed -e 's/DISTRIB_DESCRIPTION=//' | tr -d '"'`
				;;
			${ROOTDIR}/etc/gentoo-release)
				GENTOO=1
				if [ -h ${ROOTDIR}/etc/make.profile ]; then
					OSNAME="Gentoo `ls -l ${ROOTDIR}/etc/make.profile 2>/dev/null | sed -e 's/^.*\/\([^\/]*\)$/\1/'`"
				else
					OSNAME=`head -n 1 ${RELEASE} | tr -s ' '`
				fi
				;;
			${ROOTDIR}/var/ipcop/general-functions.pl)
				OSNAME=`grep 'version *=' ${RELEASE} | head -n 1`
				;;
			${ROOTDIR}/etc/debian_version)
				OSNAME="Debian `cat ${RELEASE}`"
				;;
			*)
				OSNAME=`head -n 1 ${RELEASE} | tr -s ' '`
				;;
			esac

			test "${OSNAME}" = " " && OSNAME=""


			#
			# If we have a release file but the first line seems
			# to be blank, we take a quick look at the second
			# line.
			#

			if [ -z "${OSNAME}" -a `wc -l ${RELEASE} | awk '{ print $1 }'` -gt 1 ]; then
				OSNAME=`head -n 2 ${RELEASE} | tail -1 | tr -s ' '`
			fi

			test -n "${OSNAME}" && break
		fi
	done


	test -z "${OSNAME}" && RELEASE=""

	case "${OPERATING_SYSTEM}" in
	SunOS)
		ARCH=`uname -p 2>/dev/null`
		;;
	FreeBSD)
		ARCH=`sysctl -n hw.machine_arch 2>/dev/null`
		OSNAME=`uname -v 2>/dev/null | cut -d' ' -f1,2`
		;;
	OpenBSD)
		OSNAME="OpenBSD `uname -r 2>/dev/null`"
		;;
	Darwin)
		OSNAME=`sw_vers 2>/dev/null | grep '^ProductName:' | sed -e 's/ProductName: *//'`
		OSNAME="${OSNAME} `sw_vers 2>/dev/null | grep '^ProductVersion:' | sed -e 's/ProductVersion: *//'`"
#		OSNAME="${OSNAME} `sysctl kern.version 2>/dev/null | sed -e 's/^kern.version = //' | cut -d: -f1`"
		;;
	AIX)
		ARCH=`uname -p 2>/dev/null`
		OSNAME="IBM AIX `oslevel 2>/dev/null`"
		;;
	esac

	return
}


rkh_dat_set_file_properties() {

	#
	# This function obtains various bits of information about the
	# files to be checked. The format in the rkhunter.dat file is:
	#
	#     File:<pathname>:<hash value>:<inode>:<permissions>:<uid>:<gid>:
	#          <date/time modified>
	#
	# To save time in the loops below, we determine the exact commands
	# required before entering them.
	#

	DIR_FILE_COUNT=0
	PROP_FILE_LIST_COUNT=0

	display --to LOG --type PLAIN SET_FILE_PROP_START


	if [ -z "${STAT_CMD}" ]; then
		SCMD=""
		FDATA=":::::"
	else
		if [ -n "`echo ${STAT_CMD} | grep '\.pl$'`" ]; then
			SCMD="${STAT_CMD} --modeoct --raw --mode --ino -uid -gid -Mtime"
		else
			if [ "${OPERATING_SYSTEM}" = "NetBSD" ]; then
				SCMD="${STAT_CMD} -f '%i %Mp%Lp %u %g %m:'"
			else
				SCMD="${STAT_CMD} --format='%i 0%a %u %g %Y:'"
			fi
		fi
	fi

	if [ -z "${HASH_FUNC}" ]; then
		HCMD=""
		SYSHASH=""
	else
		if [ $PRELINKED -eq 0 ]; then
			HCMD=$HASH_FUNC
		else
			if [ -n "`echo ${HASH_FUNC} | grep 'md5'`" ]; then
				HCMD="${PRELINK_CMD} --verify --md5"
			else
				HCMD="${PRELINK_CMD} --verify --sha"
			fi
		fi

		if [ "${OPERATING_SYSTEM}" = "OpenBSD" -a "${HCMD}" = "/bin/md5" ]; then
			HSH_FLD_IDX=4
		else
			HSH_FLD_IDX=1
		fi
	fi


	#
	# Now loop through the directories looking for the files.
	#

	for DIR in ${PROP_DIR_LIST}; do
		test ! -d "${DIR}" && continue

		DIR_FILE_COUNT=0

		for FNAME in ${PROP_FILE_LIST}; do
			test ! -f "${DIR}/${FNAME}" -o -h "${DIR}/${FNAME}" && continue

			DIR_FILE_COUNT=`expr ${DIR_FILE_COUNT} + 1`
			PROP_FILE_LIST_COUNT=`expr ${PROP_FILE_LIST_COUNT} + 1`

			if [ -n "${HCMD}" ]; then
				SYSHASH=`${HCMD} ${DIR}/${FNAME} 2>/dev/null | cut -d' ' -f $HSH_FLD_IDX`
			fi

			if [ -n "${SCMD}" ]; then
				FDATA=`eval ${SCMD} ${DIR}/${FNAME} 2>/dev/null | tr ' ' ':'`
			fi

			echo "File:${DIR}/${FNAME}:${SYSHASH}:${FDATA}" >>${RKHDAT_FILE}
		done

		display --to LOG --type INFO SET_FILE_PROP_DIR_FILE_COUNT $DIR_FILE_COUNT "${DIR}"
	done


	if [ -f ${DB_PATH}/rkhunter.dat ]; then
		RKHTMPVAR="updated"
	else
		RKHTMPVAR="created"
	fi

	display --to SCREEN+LOG --type INFO SET_FILE_PROP_FILE_COUNT "${RKHTMPVAR}" $PROP_FILE_LIST_TOTAL $PROP_FILE_LIST_COUNT

	return
}


do_prop_update() {

	#
	# This function updates the local hosts rkhunter.dat file
	# with O/S information and file properties.
	#

	display --to LOG --type INFO --nl PROPUPD_START

	#
	# First we need to get a temporary file name to use.
	#

	get_temp_file "${TMPDIR}/rkhunter.dat"
	RKHDAT_FILE=$TEMPFILE

	display --to LOG --type INFO CREATED_TEMP_FILE "${RKHDAT_FILE}"


	#
	# We now start to write out information about this system
	# to the file. Some information we already have available,
	# but for others we call functions to obtain what is wanted.
	#

	ARCH=""
	OSNAME=""
	RELEASE=""

	rkh_dat_set_version


	display --to LOG --type PLAIN PROPUPD_OSINFO_START

	rkh_dat_get_os_info

	echo "Host:${HOST_NAME}" >>${RKHDAT_FILE}

	if [ -n "${ARCH}" ]; then
		echo "Arch:${ARCH}" >>${RKHDAT_FILE}
		display --to LOG --type INFO PROPUPD_ARCH_FOUND "${ARCH}"
	fi

	if [ -n "${RELEASE}" ]; then
		display --to LOG --type INFO PROPUPD_REL_FILE "${RELEASE}"
	else
		display --to LOG --type INFO PROPUPD_NO_REL_FILE
		display --to LOG --type PLAIN PROPUPD_NO_REL_FILE2 "      `ls -d ${ROOTDIR}/etc/*release* ${ROOTDIR}/etc/*version* 2>/dev/null | tr '\n' ' '`"
	fi

	if [ -n "${OSNAME}" ]; then
		echo "OS:${OSNAME}" >>${RKHDAT_FILE}
		display --to LOG --type INFO PROPUPD_OSNAME_FOUND "${OSNAME}"
	fi

	if [ $PRELINKED -eq 0 ]; then
		echo "Prelinked:No" >>${RKHDAT_FILE}
	else
		echo "Prelinked:Yes" >>${RKHDAT_FILE}
	fi


	rkh_dat_set_file_properties


	#
	# Now put the new rkhunter.dat file in place.
	#

	cp -f ${DB_PATH}/rkhunter.dat ${DB_PATH}/rkhunter.dat.old >/dev/null 2>&1
	cp ${RKHDAT_FILE} ${DB_PATH}/rkhunter.dat >/dev/null 2>&1
	RKHTMPVAR=$?

	if [ $RKHTMPVAR -ne 0 ]; then
		RET_CODE=1
		display --to SCREEN+LOG --type WARNING PROPUPD_ERROR $RKHTMPVAR
	else
		display --to LOG --type INFO PROPUPD_NEW_DAT_FILE
	fi

	chmod 600 ${DB_PATH}/rkhunter.dat >/dev/null 2>&1

	rm -f ${RKHDAT_FILE} >/dev/null 2>&1

	return
}


get_next_mirror() {

	#
	# This function will obtain the next mirror in the mirrors file
	# if no mirror is currently being used. It then rotates the
	# mirrors in the mirrors file.
	#


	#
	# Return if there is no mirrors file.
	#

	if [ ! -f "${DB_PATH}/mirrors.dat" ]; then
		display --to LOG --type INFO MIRRORS_NO_FILE "${DB_PATH}/mirrors.dat"
		return
	fi


	#
	# Return if there are no defined mirrors.
	#

	MIRROR=`grep -i '^mirror=http://' ${DB_PATH}/mirrors.dat | head -n 1 | cut -d= -f2`

	if [ -z "${MIRROR}" ]; then
		display --to LOG --type INFO MIRRORS_NO_MIRRORS "${DB_PATH}/mirrors.dat"
		return
	fi


	#
	# Now get the version number of the mirrors file. If the version
	# does not exist or is corrupt, then we reset it to zero. This
	# then allows the file to be updated next time the '--update'
	# option is used.
	#

	MIRRORSVERSION=`egrep -i '^version:[0-9]{10}$' ${DB_PATH}/mirrors.dat | tail -1`

	if [ -z "${MIRRORSVERSION}" ]; then
		display --to LOG --type INFO MIRRORS_NO_VERSION "${DB_PATH}/mirrors.dat"
		MIRRORSVERSION="version:0000000000"
	fi


	#
	# Next get the remaining mirrors.
	#

	OTHERMIRRORS=`grep '^mirror=http://' ${DB_PATH}/mirrors.dat | grep -v ${MIRROR}`


	#
	# We need to get a temporary file name to use.
	#

	get_temp_file "${TMPDIR}/mirrors.dat"
	MIRRORS_FILE=$TEMPFILE

	display --to LOG --type INFO CREATED_TEMP_FILE "${MIRRORS_FILE}"


	#
	# Output to the temporary file the mirrors version, the other
	# mirrors, and finally the mirror we are about to use.
	#

	echo "${MIRRORSVERSION}" >${MIRRORS_FILE}

	for M in ${OTHERMIRRORS}; do
		echo "${M}" >>${MIRRORS_FILE}
	done;

	echo "mirror=${MIRROR}" >>${MIRRORS_FILE}


	#
	# Move the new file into place, and delete the temporary file.
	#

	cat ${MIRRORS_FILE} >${DB_PATH}/mirrors.dat

	rm -f ${MIRRORS_FILE} >/dev/null 2>&1

	display --to LOG --type INFO MIRRORS_ROTATED "${DB_PATH}/mirrors.dat"

	return
}


download_file() {

	# This function downloads a specified file. It takes three parameters:
	#     1=mirror, 2=url, 3=output file
	#
	# The function sets a return code (DNLOADERR).
	#

	#
	# We loop round through the mirrors until the file is downloaded.
	# We do this by first seeing how many mirrors are available. Then
	# we call a function to get the next mirror, which also rotates
	# the mirror file. If a mirror has already been set, then that
	# mirror is used. That way, in effect, once we find a good mirror
	# then it will be used for all the downloads.
	#

	MIRROR=$1
	URL=$2
	OUTPUT_FILE=$3

	DNLOADERR=0
	MIRROR_COUNT=0

	if [ -f "${DB_PATH}/mirrors.dat" ]; then
		MIRROR_COUNT=`grep -i '^mirror=http://' ${DB_PATH}/mirrors.dat | wc -l | tr -d ' '`
		test -z "${MIRROR_COUNT}" && MIRROR_COUNT=0
	fi

	test $MIRROR_COUNT -eq 0 && MIRROR_COUNT=1


	while test $MIRROR_COUNT -gt 0; do
		MIRROR_COUNT=`expr $MIRROR_COUNT - 1`

		if [ -z "${MIRROR}" ]; then
			get_next_mirror
			test -z "${MIRROR}" && MIRROR="http://rkhunter.sourceforge.net"
		fi


		#
		# Now we can download the data into the temporary file.
		#

		# uns - WGET_CMD (cmd, version tested, comments):
		#       wget, *, none.
		#       bget, 1.2, appends output.
		#       curl, 7.15.3: none.
		#       links/elinks, 0.4.2, decompresses output.
		#       lynx, 2.8.5dev.7, decompresses output.

		CMD=""
		DNLOADERR=0

		rm -f ${OUTPUT_FILE} >/dev/null 2>&1

		if [ -n "${WGET_CMD}" ]; then
			CMD="${WGET_CMD} -q -O ${OUTPUT_FILE} ${MIRROR}${URL}"
		elif [ -n "${CURL_CMD}" ]; then
			CMD="${CURL_CMD} --fail --output ${OUTPUT_FILE} ${MIRROR}${URL} 2>/dev/null"
		elif [ -n "${BGET_CMD}" ]; then
			CMD="${BGET_CMD} --out ${OUTPUT_FILE} ${MIRROR}${URL} 2>/dev/null"
		elif [ -n "${ELINKS_CMD}" ]; then
			CMD="${ELINKS_CMD} -no-home 1 -source ${MIRROR}${URL} >${OUTPUT_FILE}"
		elif [ -n "${LINKS_CMD}" ]; then
			CMD="${LINKS_CMD} -no-home 1 -source ${MIRROR}${URL} >${OUTPUT_FILE}"
		elif [ -n "${LYNX_CMD}" ]; then
			CMD="${LYNX_CMD} -source ${MIRROR}${URL} >${OUTPUT_FILE}"
		elif [ -n "${GET_CMD}" ]; then
			CMD="${GET_CMD} ${MIRROR}${URL} >${OUTPUT_FILE}"
		fi

		display --to LOG --type INFO DOWNLOAD_CMD "${CMD}"

		eval ${CMD}
		DNLOADERR=$?

		test $DNLOADERR -gt 1 && DNLOADERR=1


		#
		# Some of these commands do not set the return code. As such we
		# need to look in the output file to see if an error occurred.
		#

		if [ $DNLOADERR -eq 0 ]; then
			if [ -n "`echo \"${URL}\" | grep '/i18n\.ver$'`" ]; then
				#
				# The i18n.ver file is of a different
				# format from the other files.
				#

				:
			elif [ -n "`echo \"${URL}\" | grep '/rkhunter_latest\.dat$'`" ]; then
				#
				# The versioncheck file should just be a version number.
				#

				if [ -z "`grep '^[0-9][0-9]*\.[0-9][.0-9]*$' ${OUTPUT_FILE}`" ]; then
					DNLOADERR=1
				fi
			else
				#
				# All other files should have a normal
				# version number as the first line in them.
				#

				if [ -z "`head -n 1 ${OUTPUT_FILE} | egrep -i '^version:[0-9]{10}$'`" ]; then
					DNLOADERR=1
				fi
			fi
		fi

		test ! -s "${OUTPUT_FILE}" && DNLOADERR=1

		if [ $DNLOADERR -eq 0 ]; then
			break
		elif [ $MIRROR_COUNT -gt 0 ]; then
			MIRROR=""
			display --to LOG --type INFO DOWNLOAD_FAIL $MIRROR_COUNT
		fi
	done

	return $DNLOADERR
}


do_i18n_update() {

	#
	# This function updates the i18n language files.
	#
	# We do not know which i18n files should be checked until we
	# have downloaded the i18n/i18n.ver file. This file will tell
	# us which i18n files are available, and their latest version
	# number. We loop through the files, and check each version
	# number against the installed file.
	#

	download_file "${MIRROR}" "/1.3/i18n/i18n.ver" "${RKHUPD_FILE}"

	if [ $? -eq 0 ]; then
		#
		# Check that we have some version numbers. There
		# should always be at least one, for the English
		# language! Once we have the list of files, we can
		# remove the temporary file and re-use it when
		# downloading the language files.
		#

		FOUNDFILES=`egrep '^[a-zA-Z][a-zA-Z]*:[0-9]{10}$' ${RKHUPD_FILE}`

		rm -f ${RKHUPD_FILE} >/dev/null 2>&1

		if [ -z "${FOUNDFILES}" ]; then
			RET_CODE=1
			UPD_ERROR=1

			display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color RED --result UPD_FAILED UPDATE_CHECKING_FILE "i18n"

			display --to LOG --type WARNING UPDATE_I18N_NO_VERS

			return
		fi


		#
		# Now loop through the language files checking their
		# version numbers.
		#

		for FNAME in ${FOUNDFILES}; do
			LANGFILE=`echo "${FNAME}" | cut -d: -f1`
			LATEST_VERS=`echo "${FNAME}" | cut -d: -f2`

			PROG_VERS=0

			if [ -f "${DB_PATH}/i18n/${LANGFILE}" -a -s "${DB_PATH}/i18n/${LANGFILE}" ]; then
				PROG_VERS=`head -n 1 ${DB_PATH}/i18n/${LANGFILE} | egrep -i '^version:[0-9]{10}$' | sed -e 's/[vV]ersion://'`

				if [ -z "${PROG_VERS}" ]; then
					PROG_VERS=0
					display --to LOG --type INFO UPDATE_FILE_NO_VERS "${DB_PATH}/i18n/${LANGFILE}"
				fi
			else
				touch ${DB_PATH}/i18n/${LANGFILE} >/dev/null 2>&1
				chmod 600 ${DB_PATH}/i18n/${LANGFILE} >/dev/null 2>&1

				display --to LOG --type INFO UPDATE_FILE_MISSING "${DB_PATH}/i18n/${LANGFILE}"
			fi


			display --to LOG --type INFO VERSIONCHECK_CURRENT "${PROG_VERS}"
			display --to LOG --type INFO VERSIONCHECK_LATEST "${LATEST_VERS}"


			if [ $PROG_VERS -lt $LATEST_VERS ]; then
				download_file "${MIRROR}" "/1.3/i18n/${LANGFILE}" "${RKHUPD_FILE}"

				if [ $? -eq 0 ]; then
					test $RET_CODE -eq 0 && RET_CODE=2

					display --to LOG --type INFO VERSIONCHECK_UPDT_AVAIL

					cat ${RKHUPD_FILE} >${DB_PATH}/i18n/${LANGFILE}

					display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color GREEN --result UPD UPDATE_CHECKING_FILE "i18n/${LANGFILE}"
				else
					RET_CODE=1
					UPD_ERROR=1

					display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color RED --result UPD_FAILED UPDATE_CHECKING_FILE "i18n/${LANGFILE}"

					display --to LOG --type WARNING UPDATE_DOWNLOAD_FAIL "i18n/${LANGFILE}"
				fi

				rm -f ${RKHUPD_FILE} >/dev/null 2>&1
			else
				display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color GREEN --result NO_UPD UPDATE_CHECKING_FILE "i18n/${LANGFILE}"
			fi
		done
	else
		RET_CODE=1
		UPD_ERROR=1

		display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color RED --result UPD_FAILED UPDATE_CHECKING_FILE "i18n"

		display --to LOG --type WARNING UPDATE_DOWNLOAD_FAIL "i18n.ver"
	fi


	rm -f ${RKHUPD_FILE} >/dev/null 2>&1

	return
}


do_update() {

	#
	# This function checks to see if any of the supplied RKH
	# *.dat and i18n files needs updating. If it does, then the
	# file is overwritten with the new version.
	#

	display --to SCREEN+LOG --type PLAIN --color YELLOW --nl UPDATE_START


	#
	# First we need to get a temporary file name to use.
	#

	get_temp_file "${TMPDIR}/rkhunter.upd"
	RKHUPD_FILE=$TEMPFILE

	display --to LOG --type INFO CREATED_TEMP_FILE "${RKHUPD_FILE}"


	#
	# Now we loop round through the files we need to check. Each file
	# will use the first mirror, and if necessary loop through the
	# remaining mirrors until the file is downloaded. In theory this
	# could take some time if the mirror sites are all experiencing
	# problems and this is affecting all the files.
	#
	# For each file we look at the current version number. If there
	# is a problem doing this, then we just try and download a new
	# copy of the file. If the version number is okay, then we
	# download the file to find the latest version number. If
	# that is successful, we then update the file if necessary.
	#

	UPD_ERROR=0
	MIRROR=""

	for UPDFILE in mirrors.dat programs_bad.dat backdoorports.dat; do
		PROG_VERS=0
		LATEST_VERS=0

		if [ -f "${DB_PATH}/${UPDFILE}" -a -s "${DB_PATH}/${UPDFILE}" ]; then
			PROG_VERS=`head -n 1 ${DB_PATH}/${UPDFILE} | egrep -i '^version:[0-9]{10}$' | sed -e 's/[vV]ersion://'`

			if [ -z "${PROG_VERS}" ]; then
				PROG_VERS=0
				display --to LOG --type INFO UPDATE_FILE_NO_VERS "${UPDFILE}"
			fi
		else
			touch ${DB_PATH}/${UPDFILE} >/dev/null 2>&1
			chmod 600 ${DB_PATH}/${UPDFILE} >/dev/null 2>&1

			display --to LOG --type INFO UPDATE_FILE_MISSING "${UPDFILE}"
		fi


		#
		# Now download the file.
		#
		# Note: To avoid any backward incompatability we
		# get the files from a specific directory which
		# previous versions do not use.
		#

		download_file "${MIRROR}" "/1.3/${UPDFILE}" "${RKHUPD_FILE}"


		#
		# Next we compare the current and downloaded
		# file version numbers.
		#

		if [ $? -eq 0 ]; then
			LATEST_VERS=`head -n 1 ${RKHUPD_FILE} | egrep -i '^version:[0-9]{10}$' | sed -e 's/[vV]ersion://'`

			test -z "${LATEST_VERS}" && LATEST_VERS=0


			display --to LOG --type INFO VERSIONCHECK_CURRENT "${PROG_VERS}"
			display --to LOG --type INFO VERSIONCHECK_LATEST "${LATEST_VERS}"

			if [ $LATEST_VERS -eq 0 ]; then
				RET_CODE=1
				UPD_ERROR=1

				display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color RED --result VCHK_FAILED UPDATE_CHECKING_FILE "${UPDFILE}"

				LATEST_VERS=`head -n 1 ${RKHUPD_FILE}`

				display --to LOG --type WARNING VERSIONCHECK_CONV_FAIL "${PROG_VERS}" "${LATEST_VERS}"
			elif [ $PROG_VERS -lt $LATEST_VERS ]; then
				test $RET_CODE -eq 0 && RET_CODE=2

				display --to LOG --type INFO VERSIONCHECK_UPDT_AVAIL

				cat ${RKHUPD_FILE} >${DB_PATH}/${UPDFILE}

				display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color GREEN --result UPD UPDATE_CHECKING_FILE "${UPDFILE}"
			else
				display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color GREEN --result NO_UPD UPDATE_CHECKING_FILE "${UPDFILE}"
			fi
		else
			RET_CODE=1
			UPD_ERROR=1

			display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color RED --result UPD_FAILED UPDATE_CHECKING_FILE "${UPDFILE}"

			display --to LOG --type WARNING UPDATE_DOWNLOAD_FAIL "${UPDFILE}"
		fi

		rm -f ${RKHUPD_FILE} >/dev/null 2>&1
	done


	#
	# We now need to update the i18n files. Since this is a little
	# more complicated, it is handled in a separate function.
	#

	do_i18n_update


	if [ $UPD_ERROR -eq 1 ]; then
		if [ $NOLOG -eq 1 ]; then
			display --to SCREEN --type PLAIN --nl --nl-after CHECK_WARNINGS_FOUND_RERUN
		else
			display --to SCREEN --type PLAIN --nl --nl-after CHECK_WARNINGS_FOUND_CHK_LOG "${LOGFILE}"
		fi
	fi

	return
}


do_versioncheck() {

	#
	# This function performs a program version check.
	#
	# It will set the return code in some instances:
	#       0 - (implied) no error, no update available
	#	1 - a download error occurred
	#	2 - no error occurred, but an update is available
	#

	MIRROR=""
	LATESTVERSION=""

	display --to SCREEN+LOG --type PLAIN --color YELLOW --nl VERSIONCHECK_START


	#
	# First we need to get a temporary file name to use.
	#

	get_temp_file "${TMPDIR}/rkhunter.vc"
	RKHVC_FILE=$TEMPFILE

	display --to LOG --type INFO CREATED_TEMP_FILE "${RKHVC_FILE}"


	#
	# Next we get the current program version number.
	#

	PROG_VERS=`echo "${PROGRAM_version}" | cut -d. -f1-3 | sed -e 's/\.\([0-9]\)\./.0\1./' | sed -e 's/\.\([0-9]\)$/.0\1/' | tr -d '.'`

	test -z "${PROG_VERS}" && PROG_VERS=0

	display --to SCREEN+LOG --type PLAIN --screen-indent 2 VERSIONCHECK_CURRENT "${PROGRAM_version}"


	#
	# To get the URL to use we must process this as a configuration
	# file option.
	#

	URL=`grep '^LATESTVERSION=' ${CONFIGFILE} | tail -1 | sed -e 's/LATESTVERSION=//' | tr -d '"' | tr -s ' '`

	if [ -z "`echo \"${URL}\" | grep '^/'`" ]; then
		URL="/rkhunter_latest.dat"
	fi


	#
	# Download the file, and then compare the current value
	# with the downloaded one.
	#

	download_file "${MIRROR}" "${URL}" "${RKHVC_FILE}"

	if [ $? -eq 0 ]; then
		LATESTVERSION=`cat ${RKHVC_FILE} 2>/dev/null`

		#
		# Convert the version string to zero-spaced numbers.
		# This allows us to numerically compare the versions,
		# even when the numbers go above ten.
		#
		# E.g. '1.2.10' => 10210,   '1.3.2' => 10302.
		#

		LATEST_VERS=`echo "${LATESTVERSION}" | cut -d. -f1-3 | sed -e 's/\.\([0-9]\)\./.0\1./' | sed -e 's/\.\([0-9]\)$/.0\1/' | tr -d '.'`

		test -z "${LATEST_VERS}" && LATEST_VERS=0

		display --to SCREEN+LOG --type PLAIN --screen-indent 2 VERSIONCHECK_LATEST "${LATESTVERSION}"

		if [ $LATEST_VERS -eq 0 ]; then
			RET_CODE=1
			display --to SCREEN+LOG --type WARNING --screen-indent 2 VERSIONCHECK_CONV_FAIL "${PROGRAM_version}" "${LATESTVERSION}"
		elif [ $PROG_VERS -lt $LATEST_VERS ]; then
			test $RET_CODE -eq 0 && RET_CODE=2
			display --to SCREEN+LOG --type PLAIN --screen-indent 2 VERSIONCHECK_UPDT_AVAIL
		fi
	else
		RET_CODE=1

		display --to SCREEN+LOG --type PLAIN --screen-indent 2 VERSIONCHECK_LATEST_FAIL
		display --to LOG --type WARNING VERSIONCHECK_FAIL_ALL
	fi

	rm -f ${RKHVC_FILE} >/dev/null 2>&1

	return
}


do_system_check_initialisation() {

	#
	# This function simply initialises the default rootkit
	# files and directories.
	#


	# 55808 Variant A
	W55808A_FILES="${ROOTDIR}/tmp/.../r
		       ${ROOTDIR}/tmp/.../a"


	# AjaKit Rootkit
	AJAKIT_FILES="${ROOTDIR}/dev/tux/.addr
		      ${ROOTDIR}/dev/tux/.proc
		      ${ROOTDIR}/dev/tux/.file
		      ${ROOTDIR}/lib/.libgh-gh/cleaner
		      ${ROOTDIR}/lib/.libgh-gh/Patch/patch
		      ${ROOTDIR}/lib/.libgh-gh/sb0k"
	AJAKIT_DIRS="${ROOTDIR}/dev/tux
		     ${ROOTDIR}/lib/.libgh-gh"


	# aPa Kit Rootkit
	APAKIT_FILES="${ROOTDIR}/usr/share/.aPa"


	# Apache Worm
	APACHEWORM_FILES="${ROOTDIR}/bin/.log"


	# Ambient (ark) Rootkit
	ARK_FILES="${ROOTDIR}/usr/lib/.ark?
		   ${ROOTDIR}/dev/ptyxx/.log
		   ${ROOTDIR}/dev/ptyxx/.file"
	ARK_DIRS="${ROOTDIR}/dev/ptyxx"


	# Balaur Rootkit 2.0 (LRK5 based)
	BALAUR_FILES="${ROOTDIR}/usr/lib/liblog.o"
	BALAUR_DIRS="${ROOTDIR}/usr/lib/.kinetic
		     ${ROOTDIR}/usr/lib/.egcs
		     ${ROOTDIR}/usr/lib/.wormie"


	# Beastkit Rootkit
	BEASTKIT_FILES="${ROOTDIR}/usr/sbin/arobia
			${ROOTDIR}/usr/sbin/idrun
			${ROOTDIR}/usr/lib/elm/arobia/elm
			${ROOTDIR}/usr/lib/elm/arobia/elm/hk
			${ROOTDIR}/usr/lib/elm/arobia/elm/hk.pub
			${ROOTDIR}/usr/lib/elm/arobia/elm/sc
			${ROOTDIR}/usr/lib/elm/arobia/elm/sd.pp
			${ROOTDIR}/usr/lib/elm/arobia/elm/sdco
			${ROOTDIR}/usr/lib/elm/arobia/elm/srsd"
	BEASTKIT_DIRS="${ROOTDIR}/lib/ldd.so/bktools"


	# beX2 Rootkit
	BEX_DIRS="${ROOTDIR}/usr/include/bex"


	# BOBkit Rootkit
	BOBKIT_FILES="${ROOTDIR}/usr/sbin/ntpsx
		      ${ROOTDIR}/usr/lib/.../ls
		      ${ROOTDIR}/usr/lib/.../netstat
		      ${ROOTDIR}/usr/lib/.../lsof
		      ${ROOTDIR}/usr/lib/.../bkit-ssh/bkit-shdcfg
		      ${ROOTDIR}/usr/lib/.../bkit-ssh/bkit-shhk
		      ${ROOTDIR}/usr/lib/.../bkit-ssh/bkit-pw
		      ${ROOTDIR}/usr/lib/.../bkit-ssh/bkit-shrs
		      ${ROOTDIR}/usr/lib/.../uconf.inv
		      ${ROOTDIR}/usr/lib/.../psr
		      ${ROOTDIR}/usr/lib/.../find
		      ${ROOTDIR}/usr/lib/.../pstree
		      ${ROOTDIR}/usr/lib/.../slocate
		      ${ROOTDIR}/usr/lib/.../du
		      ${ROOTDIR}/usr/lib/.../top"
	BOBKIT_DIRS="${ROOTDIR}/usr/lib/...
		     ${ROOTDIR}/usr/lib/.../bkit-ssh
		     ${ROOTDIR}/usr/lib/.bkit-
		     ${ROOTDIR}/tmp/.bkp"


	# CiNIK Worm (Slapper.B variant)
	CINIK_DIRS="${ROOTDIR}/tmp/.font-unix/.cinik"
	CINIK_FILES="${ROOTDIR}/tmp/.cinik"


	# Danny-Boy's Abuse Kit
	DANNYBOYS_FILES="${ROOTDIR}/dev/mdev
			 ${ROOTDIR}/usr/lib/libX.a"


	# Devil Rootkit
	DEVIL_FILES="${ROOTDIR}/var/lib/games/.src
		     ${ROOTDIR}/dev/dsx
		     ${ROOTDIR}/dev/caca"


	# Dica-Kit (T0rn variant) Rootkit
	DICA_FILES="${ROOTDIR}/lib/.sso
		    ${ROOTDIR}/lib/.so
		    ${ROOTDIR}/var/run/...dica/clean
		    ${ROOTDIR}/var/run/...dica/xl
		    ${ROOTDIR}/var/run/...dica/xdr
		    ${ROOTDIR}/var/run/...dica/psg
		    ${ROOTDIR}/var/run/...dica/secure
		    ${ROOTDIR}/var/run/...dica/rdx
		    ${ROOTDIR}/var/run/...dica/va
		    ${ROOTDIR}/var/run/...dica/cl.sh
		    ${ROOTDIR}/usr/bin/.etc"
	DICA_DIRS="${ROOTDIR}/var/run/...dica
		   ${ROOTDIR}/var/run/...dica/mh
		   ${ROOTDIR}/var/run/...dica/scan"


	# Dreams Rootkit
	DREAMS_FILES="${ROOTDIR}/dev/ttyoa
		      ${ROOTDIR}/dev/ttyof
		      ${ROOTDIR}/dev/ttyop
		      ${ROOTDIR}/usr/bin/sense
		      ${ROOTDIR}/usr/bin/sl2
		      ${ROOTDIR}/usr/bin/logclear
		      ${ROOTDIR}/usr/bin/(swapd)
		      ${ROOTDIR}/usr/bin/snfs
		      ${ROOTDIR}/usr/lib/libsss"
	DREAMS_DIRS="${ROOTDIR}/dev/ida/.hpd"


	# Duarawkz Rootkit
	DUARAWKZ_FILES="${ROOTDIR}/usr/bin/duarawkz/loginpass"
	DUARAWKZ_DIRS="${ROOTDIR}/usr/bin/duarawkz"

	# ENYE LKM v1.1
	# Installer default.
	ENYELKM_FILES="${ROOTDIR}/etc/.enyelkmHIDE^IT.ko"

	# Flea Linux Rootkit
	FLEA_FILES="${ROOTDIR}/etc/ld.so.hash
		    ${ROOTDIR}/lib/security/.config/ssh/ssh_host_key
		    ${ROOTDIR}/lib/security/.config/ssh/ssh_host_key.pub
		    ${ROOTDIR}/lib/security/.config/ssh/ssh_random_seed
		    ${ROOTDIR}/usr/bin/ssh2d
		    ${ROOTDIR}/usr/lib/ldlibns.so
		    ${ROOTDIR}/usr/lib/ldlibpst.so
		    ${ROOTDIR}/usr/lib/ldlibdu.so
		    ${ROOTDIR}/usr/lib/ldlibct.so"
	FLEA_DIRS="${ROOTDIR}/lib/security/.config/ssh
		   ${ROOTDIR}/dev/..0
		   ${ROOTDIR}/dev/..0/backup"


	# FreeBSD Rootkit
	FREEBSD_RK_FILES="${ROOTDIR}/usr/lib/.fx/sched_host.2
			  ${ROOTDIR}/usr/lib/.fx/random_d.2
			  ${ROOTDIR}/usr/lib/.fx/set_pid.2
			  ${ROOTDIR}/usr/lib/.fx/cons.saver
			  ${ROOTDIR}/usr/lib/.fx/adore/adore/adore.ko
			  ${ROOTDIR}/bin/sysback
			  ${ROOTDIR}/usr/local/bin/sysback"
	FREEBSD_RK_DIRS="${ROOTDIR}/usr/lib/.fx
			 ${ROOTDIR}/usr/lib/.fx/adore"


	# Fuckit Rootkit
	FUCKIT_FILES="${ROOTDIR}/dev/proc/fuckit/hax0r
		      ${ROOTDIR}/dev/proc/fuckit/hax0rshell
		      ${ROOTDIR}/dev/proc/fuckit/config/lports
		      ${ROOTDIR}/dev/proc/fuckit/config/rports
		      ${ROOTDIR}/dev/proc/fuckit/config/rkconf
		      ${ROOTDIR}/dev/proc/fuckit/config/password
		      ${ROOTDIR}/dev/proc/fuckit/config/progs
		      ${ROOTDIR}/dev/proc/system-bins/init"


	# GasKit Rootkit
	GASKIT_FILES="${ROOTDIR}/dev/dev/gaskit/sshd/sshdd"
	GASKIT_DIRS="${ROOTDIR}/dev/dev
		     ${ROOTDIR}/dev/dev/gaskit
		     ${ROOTDIR}/dev/dev/gaskit/sshd"


	# Heroin LKM
	HEROIN_KSYMS="heroin"


	# HjC Kit Rootkit
	HJCKIT_DIRS="${ROOTDIR}/dev/.hijackerz"


	# ignoKit Rootkit
	IGNOKIT_FILES="${ROOTDIR}/lib/defs/p
		       ${ROOTDIR}/lib/defs/q
		       ${ROOTDIR}/lib/defs/r
		       ${ROOTDIR}/lib/defs/s
		       ${ROOTDIR}/lib/defs/t
		       ${ROOTDIR}/usr/lib/defs/p
		       ${ROOTDIR}/usr/lib/defs/q
		       ${ROOTDIR}/usr/lib/defs/r
		       ${ROOTDIR}/usr/lib/defs/s
		       ${ROOTDIR}/usr/lib/defs/t
		       ${ROOTDIR}/usr/lib/.libigno/pkunsec
		       ${ROOTDIR}/usr/lib/.libigno/.igno/psybnc/psybnc"
	IGNOKIT_DIRS="${ROOTDIR}/usr/lib/.libigno
		      ${ROOTDIR}/usr/lib/.libigno/.igno/"


	# ImperalsS-FBRK (FreeBSD Rootkit)
	IMPFRB_DIRS="${ROOTDIR}/dev/fd/.88
		     ${ROOTDIR}/dev/fd/.99"


	# Irix Rootkit (for Irix 6.x)
	IRIXRK_DIRS="${ROOTDIR}/dev/pts/01
		     ${ROOTDIR}/dev/pts/01/backup
		     ${ROOTDIR}/dev/pts/01/etc
		     ${ROOTDIR}/dev/pts/01/tmp"


	# Kitko Rootkit
	KITKO_DIRS="${ROOTDIR}/usr/src/redhat/SRPMS/..."


	# Knark Rootkit
	KNARK_FILES="${ROOTDIR}/proc/knark/pids"
	KNARK_DIRS="${ROOTDIR}/proc/knark"


	# Lion Worm
	LION_FILES="${ROOTDIR}/bin/in.telnetd
		    ${ROOTDIR}/bin/mjy
		    ${ROOTDIR}/usr/man/man1/man1/lib/.lib/mjy
		    ${ROOTDIR}/usr/man/man1/man1/lib/.lib/in.telnetd
		    ${ROOTDIR}/usr/man/man1/man1/lib/.lib/.x
		    ${ROOTDIR}/dev/.lib/lib/scan/1i0n.sh
		    ${ROOTDIR}/dev/.lib/lib/scan/hack.sh
		    ${ROOTDIR}/dev/.lib/lib/scan/bind
		    ${ROOTDIR}/dev/.lib/lib/scan/randb
		    ${ROOTDIR}/dev/.lib/lib/scan/scan.sh
		    ${ROOTDIR}/dev/.lib/lib/scan/pscan
		    ${ROOTDIR}/dev/.lib/lib/scan/star.sh
		    ${ROOTDIR}/dev/.lib/lib/scan/bindx.sh
		    ${ROOTDIR}/dev/.lib/lib/scan/bindname.log
		    ${ROOTDIR}/dev/.lib/lib/1i0n.sh
		    ${ROOTDIR}/dev/.lib/lib/lib/netstat
		    ${ROOTDIR}/dev/.lib/lib/lib/dev/.1addr
		    ${ROOTDIR}/dev/.lib/lib/lib/dev/.1logz
		    ${ROOTDIR}/dev/.lib/lib/lib/dev/.1proc
		    ${ROOTDIR}/dev/.lib/lib/lib/dev/.1file"


	# Lockit (a.k.a. LJK2) Rootkit
	LOCKIT_FILES="${ROOTDIR}/usr/lib/libmen.oo/.LJK2/ssh_config
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/ssh_host_key
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/ssh_host_key.pub
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/ssh_random_seed*
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/sshd_config
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backdoor/RK1bd
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/du
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/ifconfig
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/inetd.conf
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/locate
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/login
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/ls
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/netstat
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/ps
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/pstree
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/rc.sysinit
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/syslogd
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/tcpd
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/top
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/clean/RK1sauber
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/clean/RK1wted
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/hack/RK1parser
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/hack/RK1sniff
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/hide/.RK1addr
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/hide/.RK1dir
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/hide/.RK1log
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/hide/.RK1proc
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/hide/RK1phidemod.c
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/modules/README.modules
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/modules/RK1hidem.c
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/modules/RK1phide
		      ${ROOTDIR}/usr/lib/libmen.oo/.LJK2/sshconfig/RK1ssh"
	LOCKIT_DIRS="${ROOTDIR}/usr/lib/libmen.oo/.LJK2"


	# MRK (MiCrobul?) RootKit (based on Devil RootKit)
	MRK_FILES="${ROOTDIR}/dev/ida/.inet/pid
		   ${ROOTDIR}/dev/ida/.inet/ssh_host_key
		   ${ROOTDIR}/dev/ida/.inet/ssh_random_seed
		   ${ROOTDIR}/dev/ida/.inet/tcp.log"
	MRK_DIRS="${ROOTDIR}/dev/ida/.inet
		  ${ROOTDIR}/var/spool/cron/.sh"


	# Mood-NT Rootkit
	# Binary is by default called "mood-nt" but can be anywhere.
	# Here we look for collaterals, from include/prefs.h defaults
	# until sig-based dirscan() is added.
	MOODNT_FILES="${ROOTDIR}/sbin/init__mood-nt-_-_cthulhu
		      ${ROOTDIR}/_cthulhu/mood-nt.init
		      ${ROOTDIR}/_cthulhu/mood-nt.conf
		      ${ROOTDIR}/_cthulhu/mood-nt.sniff"
	MOODNT_DIRS="${ROOTDIR}/_cthulhu"


	# Ni0 Rootkit
	NIO_FILES="${ROOTDIR}/var/lock/subsys/...datafile.../...net...
		   ${ROOTDIR}/var/lock/subsys/...datafile.../...port...
		   ${ROOTDIR}/var/lock/subsys/...datafile.../...ps...
		   ${ROOTDIR}/var/lock/subsys/...datafile.../...file..."
	NIO_DIRS="${ROOTDIR}/tmp/waza
		  ${ROOTDIR}/var/lock/subsys/...datafile...
		  ${ROOTDIR}/usr/sbin/es"


	# Ohhara Rootkit
	OHHARA_FILES="${ROOTDIR}/var/lock/subsys/...datafile.../...datafile.../in.smbd.log"
	OHHARA_DIRS="${ROOTDIR}/var/lock/subsys/...datafile...
		     ${ROOTDIR}/var/lock/subsys/...datafile.../...datafile...
		     ${ROOTDIR}/var/lock/subsys/...datafile.../...datafile.../bin
		     ${ROOTDIR}/var/lock/subsys/...datafile.../...datafile.../usr/bin
		     ${ROOTDIR}/var/lock/subsys/...datafile.../...datafile.../usr/sbin
		     ${ROOTDIR}/var/lock/subsys/...datafile.../...datafile.../lib/security"


	# Optic Kit (Tux variant) Rootkit
	OPTICKIT_DIRS="${ROOTDIR}/dev/tux
		       ${ROOTDIR}/usr/bin/xchk
		       ${ROOTDIR}/usr/bin/xsf
		       ${ROOTDIR}/usr/bin/ssh2d"


	# Oz Rootkit
	OZ_FILES="${ROOTDIR}/dev/.oz/.nap/rkit/terror"
	OZ_DIRS="${ROOTDIR}/dev/.oz"


	# PHALANX Rootkit
	PHALANX_FILES="${ROOTDIR}/usr/share/.home.ph1/cb
		       ${ROOTDIR}/etc/host.ph1
		       ${ROOTDIR}/bin/host.ph1
		       ${ROOTDIR}/usr/share/.home.ph1/phalanx"
	PHALANX_DIRS="${ROOTDIR}/usr/share/.home.ph1"


	# Portacelo Rootkit
	PORTACELO_FILES="${ROOTDIR}/var/lib/.../.ak
			 ${ROOTDIR}/var/lib/.../.hk
			 ${ROOTDIR}/var/lib/.../.rs
			 ${ROOTDIR}/var/lib/.../.p
			 ${ROOTDIR}/var/lib/.../getty
			 ${ROOTDIR}/var/lib/.../lkt.o
			 ${ROOTDIR}/var/lib/.../show
			 ${ROOTDIR}/var/lib/.../nlkt.o
			 ${ROOTDIR}/var/lib/.../ssshrc
			 ${ROOTDIR}/var/lib/.../sssh_equiv
			 ${ROOTDIR}/var/lib/.../sssh_known_hosts
			 ${ROOTDIR}/var/lib/.../sssh_pid ~/.sssh/known_hosts"


	# R3dstorm Toolkit
	REDSTORM_FILES="${ROOTDIR}/var/log/tk02/see_all
			${ROOTDIR}/bin/.../sshd/sbin/sshd1
			${ROOTDIR}/bin/.../hate/sk
			${ROOTDIR}/bin/.../see_all"
	REDSTORM_DIRS="${ROOTDIR}/var/log/tk02
		       ${ROOTDIR}/var/log/tk02/old
		       ${ROOTDIR}/bin/..."


	# RH-Sharpe's Rootkit
	RHSHARPES_FILES="${ROOTDIR}/bin/lps
			 ${ROOTDIR}/usr/bin/lpstree
			 ${ROOTDIR}/usr/bin/ltop
			 ${ROOTDIR}/usr/bin/lkillall
			 ${ROOTDIR}/usr/bin/ldu
			 ${ROOTDIR}/usr/bin/lnetstat
			 ${ROOTDIR}/usr/bin/wp
			 ${ROOTDIR}/usr/bin/shad
			 ${ROOTDIR}/usr/bin/vadim
			 ${ROOTDIR}/usr/bin/slice
			 ${ROOTDIR}/usr/bin/cleaner
			 ${ROOTDIR}/usr/include/rpcsvc/du"


	# RSHA's Rootkit
	RSHA_FILES="${ROOTDIR}/bin/kr4p
		    ${ROOTDIR}/usr/bin/n3tstat
		    ${ROOTDIR}/usr/bin/chsh2
		    ${ROOTDIR}/usr/bin/slice2
		    ${ROOTDIR}/usr/src/linux/arch/alpha/lib/.lib/.1proc
		    ${ROOTDIR}/etc/rc.d/arch/alpha/lib/.lib/.1addr"
	RSHA_DIRS="${ROOTDIR}/etc/rc.d/rsha
		   ${ROOTDIR}/etc/rc.d/arch/alpha/lib/.lib"


	# Shutdown Rootkit
	# The '%%' characters represent a space.
	SHUTDOWN_FILES="${ROOTDIR}/usr/man/man5/..%%/.dir/scannah/asus
			${ROOTDIR}/usr/man/man5/..%%/.dir/see
			${ROOTDIR}/usr/man/man5/..%%/.dir/nscd
			${ROOTDIR}/usr/man/man5/..%%/.dir/alpd
			${ROOTDIR}/etc/rc.d/rc.local%%"
	SHUTDOWN_DIRS="${ROOTDIR}/usr/man/man5/..%%/.dir/
		       ${ROOTDIR}/usr/man/man5/..%%/.dir/scannah
		       ${ROOTDIR}/etc/rc.d/rc0.d/..%%/.dir"


	# Scalper (FreeBSD.Scalper.Worm) Worm
	SCALPER_FILES="${ROOTDIR}/tmp/.a
		       ${ROOTDIR}/tmp/.uua"


	# SHV4 Rootkit
	SHV4_FILES="${ROOTDIR}/etc/ld.so.hash
		    ${ROOTDIR}/lib/libext-2.so.7
		    ${ROOTDIR}/lib/lidps1.so
		    ${ROOTDIR}/usr/sbin/xntps"
	SHV4_DIRS="${ROOTDIR}/lib/security/.config
		   ${ROOTDIR}/lib/security/.config/ssh"


	# SHV5 Rootkit
	SHV5_FILES="${ROOTDIR}/etc/sh.conf
		    ${ROOTDIR}/dev/srd0"
	SHV5_DIRS="${ROOTDIR}/usr/lib/libsh"


	# Sin Rootkit
	SINROOTKIT_FILES="${ROOTDIR}/dev/.haos/haos1/.f/Denyed
			  ${ROOTDIR}/dev/ttyoa
			  ${ROOTDIR}/dev/ttyof
			  ${ROOTDIR}/dev/ttyop
			  ${ROOTDIR}/dev/ttyos
			  ${ROOTDIR}/usr/lib/.lib
			  ${ROOTDIR}/usr/lib/sn/.X
			  ${ROOTDIR}/usr/lib/sn/.sys
			  ${ROOTDIR}/usr/lib/ld/.X
			  ${ROOTDIR}/usr/man/man1/...
			  ${ROOTDIR}/usr/man/man1/.../.m
			  ${ROOTDIR}/usr/man/man1/.../.w"
	SINROOTKIT_DIRS="${ROOTDIR}/usr/lib/sn
			 ${ROOTDIR}/usr/lib/man1/...
			 ${ROOTDIR}/dev/.haos"


	# Slapper Worm
	SLAPPER_FILES="${ROOTDIR}/tmp/.bugtraq
		       ${ROOTDIR}/tmp/.uubugtraq
		       ${ROOTDIR}/tmp/.bugtraq.c
		       ${ROOTDIR}/tmp/httpd
		       ${ROOTDIR}/tmp/.unlock
		       ${ROOTDIR}/tmp/update
		       ${ROOTDIR}/tmp/.cinik
		       ${ROOTDIR}/tmp/.b"


	# Sneakin Rootkit
	SNEAKIN_DIRS="${ROOTDIR}/tmp/.X11-unix/.../rk"


	# Suckit Rootkit
	SUCKIT_FILES="${ROOTDIR}/sbin/initsk12
		      ${ROOTDIR}/sbin/initxrk
		      ${ROOTDIR}/usr/bin/null
		      ${ROOTDIR}/usr/share/locale/sk/.sk12/sk
		      ${ROOTDIR}/etc/rc.d/rc0.d/S23kmdac
		      ${ROOTDIR}/etc/rc.d/rc1.d/S23kmdac
		      ${ROOTDIR}/etc/rc.d/rc2.d/S23kmdac
		      ${ROOTDIR}/etc/rc.d/rc3.d/S23kmdac
		      ${ROOTDIR}/etc/rc.d/rc4.d/S23kmdac
		      ${ROOTDIR}/etc/rc.d/rc5.d/S23kmdac
		      ${ROOTDIR}/etc/rc.d/rc6.d/S23kmdac"
	SUCKIT_DIRS="${ROOTDIR}/dev/sdhu0/tehdrakg
		     ${ROOTDIR}/etc/.MG
		     ${ROOTDIR}/usr/share/locale/sk/.sk12
		     ${ROOTDIR}/usr/lib/perl5/site_perl/i386-linux/auto/TimeDate/.packlist"


	# SunOS / NSDAP Rootkit
	NSDAP_FILES="${ROOTDIR}/usr/lib/vold/nsdap/.kit
		     ${ROOTDIR}/usr/lib/vold/nsdap/defines
		     ${ROOTDIR}/usr/lib/vold/nsdap/patcher
		     ${ROOTDIR}/usr/lib/vold/nsdap/pg
		     ${ROOTDIR}/usr/lib/vold/nsdap/cleaner
		     ${ROOTDIR}/usr/lib/vold/nsdap/utime
		     ${ROOTDIR}/usr/lib/vold/nsdap/crypt
		     ${ROOTDIR}/usr/lib/vold/nsdap/findkit
		     ${ROOTDIR}/usr/lib/vold/nsdap/sn2
		     ${ROOTDIR}/usr/lib/vold/nsdap/sniffload
		     ${ROOTDIR}/usr/lib/vold/nsdap/runsniff
		     ${ROOTDIR}/usr/lib/lpset"
	NSDAP_DIRS="${ROOTDIR}/usr/lib/vold/nsdap"


	# SunOS Rootkit
	SUNOSROOTKIT_FILES="${ROOTDIR}/etc/ld.so.hash
			    ${ROOTDIR}/lib/libext-2.so.7
			    ${ROOTDIR}/usr/bin/ssh2d
			    ${ROOTDIR}/bin/xlogin
			    ${ROOTDIR}/usr/lib/crth.o
			    ${ROOTDIR}/usr/lib/crtz.o
			    ${ROOTDIR}/sbin/login
			    ${ROOTDIR}/lib/security/.config/sn
			    ${ROOTDIR}/lib/security/.config/lpsched
			    ${ROOTDIR}/dev/kmod
			    ${ROOTDIR}/dev/dos"


	# Superkit Rootkit
	SUPERKIT_FILES="${ROOTDIR}/usr/man/.sman/sk"


	# Telnet Backdoor
	TBD_FILES="${ROOTDIR}/usr/lib/.tbd"


	# TeLeKiT Rootkit
	TELEKIT_FILES="${ROOTDIR}/usr/man/man3/.../TeLeKiT/bin/sniff
		       ${ROOTDIR}/usr/man/man3/.../TeLeKiT/bin/telnetd
		       ${ROOTDIR}/usr/man/man3/.../TeLeKiT/bin/teleulo
		       ${ROOTDIR}/usr/man/man3/.../cl
		       ${ROOTDIR}/dev/ptyr
		       ${ROOTDIR}/dev/ptyp
		       ${ROOTDIR}/dev/ptyq
		       ${ROOTDIR}/dev/hda06
		       ${ROOTDIR}/usr/info/libc1.so"
	TELEKIT_DIRS="${ROOTDIR}/usr/man/man3/...
		      ${ROOTDIR}/usr/man/man3/.../lsniff
		      ${ROOTDIR}/usr/man/man3/.../TeLeKiT"


	# Torn (and misc) Rootkit
	TORN_FILES="${ROOTDIR}/dev/.lib/lib/lib/t0rns
		    ${ROOTDIR}/dev/.lib/lib/lib/du
		    ${ROOTDIR}/dev/.lib/lib/lib/ls
		    ${ROOTDIR}/dev/.lib/lib/lib/t0rnsb
		    ${ROOTDIR}/dev/.lib/lib/lib/ps
		    ${ROOTDIR}/dev/.lib/lib/lib/t0rnp
		    ${ROOTDIR}/dev/.lib/lib/lib/find
		    ${ROOTDIR}/dev/.lib/lib/lib/ifconfig
		    ${ROOTDIR}/dev/.lib/lib/lib/pg
		    ${ROOTDIR}/dev/.lib/lib/lib/ssh.tgz
		    ${ROOTDIR}/dev/.lib/lib/lib/top
		    ${ROOTDIR}/dev/.lib/lib/lib/sz
		    ${ROOTDIR}/dev/.lib/lib/lib/login
		    ${ROOTDIR}/dev/.lib/lib/lib/in.fingerd
		    ${ROOTDIR}/dev/.lib/lib/lib/1i0n.sh
		    ${ROOTDIR}/dev/.lib/lib/lib/pstree
		    ${ROOTDIR}/dev/.lib/lib/lib/in.telnetd
		    ${ROOTDIR}/dev/.lib/lib/lib/mjy
		    ${ROOTDIR}/dev/.lib/lib/lib/sush
		    ${ROOTDIR}/dev/.lib/lib/lib/tfn
		    ${ROOTDIR}/dev/.lib/lib/lib/name
		    ${ROOTDIR}/dev/.lib/lib/lib/getip.sh
		    ${ROOTDIR}/usr/info/.torn/sh*
		    ${ROOTDIR}/usr/src/.puta/
		    ${ROOTDIR}/usr/src/.puta/.1addr
		    ${ROOTDIR}/usr/src/.puta/.1file
		    ${ROOTDIR}/usr/src/.puta/.1proc
		    ${ROOTDIR}/usr/src/.puta/.1logz
		    ${ROOTDIR}/usr/info/.t0rn/"
	TORN_DIRS="${ROOTDIR}/dev/.lib/
		   ${ROOTDIR}/dev/.lib/lib/
		   ${ROOTDIR}/dev/.lib/lib/lib/
		   ${ROOTDIR}/dev/.lib/lib/lib/dev/
		   ${ROOTDIR}/dev/.lib/lib/scan/
		   ${ROOTDIR}/usr/src/.puta/
		   ${ROOTDIR}/usr/man/man1/man1/
		   ${ROOTDIR}/usr/man/man1/man1/lib/
		   ${ROOTDIR}/usr/man/man1/man1/lib/.lib/
		   ${ROOTDIR}/usr/man/man1/man1/lib/.lib/.backup/"


	# Trojanit Kit Rootkit
	TROJANIT_FILES="${ROOTDIR}/bin/.ls
			${ROOTDIR}/bin/.ps
			${ROOTDIR}/bin/.netstat
			${ROOTDIR}/usr/bin/.nop
			${ROOTDIR}/usr/bin/.who"


	# Tuxtendo (Tuxkit) Rootkit
	TUXTENDO_FILES="${ROOTDIR}/dev/tux/.addr
			${ROOTDIR}/dev/tux/.cron
			${ROOTDIR}/dev/tux/.file
			${ROOTDIR}/dev/tux/.log
			${ROOTDIR}/dev/tux/.proc
			${ROOTDIR}/dev/tux/backup/crontab
			${ROOTDIR}/dev/tux/backup/df
			${ROOTDIR}/dev/tux/backup/dir
			${ROOTDIR}/dev/tux/backup/find
			${ROOTDIR}/dev/tux/backup/ifconfig
			${ROOTDIR}/dev/tux/backup/locate
			${ROOTDIR}/dev/tux/backup/netstat
			${ROOTDIR}/dev/tux/backup/ps
			${ROOTDIR}/dev/tux/backup/pstree
			${ROOTDIR}/dev/tux/backup/syslogd
			${ROOTDIR}/dev/tux/backup/tcpd
			${ROOTDIR}/dev/tux/backup/top
			${ROOTDIR}/dev/tux/backup/updatedb
			${ROOTDIR}/dev/tux/backup/vdir"
	TUXTENDO_DIRS="${ROOTDIR}/dev/tux
		       ${ROOTDIR}/dev/tux/ssh2
		       ${ROOTDIR}/dev/tux/backup"


	# URK - Universal Rootkit
	URK_FILES="${ROOTDIR}/usr/man/man1/xxxxxxbin/find
		   ${ROOTDIR}/usr/man/man1/xxxxxxbin/du
		   ${ROOTDIR}/usr/man/man1/xxxxxxbin/ps
		   ${ROOTDIR}/tmp/conf.inf"
	URK_DIRS="${ROOTDIR}/usr/man/man1/xxxxxxbin"


	# VcKit Rootkit
	VCKIT_DIRS="${ROOTDIR}/usr/include/linux/modules/lib.so
		    ${ROOTDIR}/usr/include/linux/modules/lib.so/bin"


	# Volc Rootkit
	VOLC_DIRS="${ROOTDIR}/var/spool/.recent
		   ${ROOTDIR}/var/spool/.recent/.files
		   ${ROOTDIR}/usr/lib/volc
		   ${ROOTDIR}/usr/lib/volc/backup"


	# X-Org SunOS Rootkit
	XORGSUNOS_FILES="${ROOTDIR}/usr/lib/libX.a/bin/tmpfl
			 ${ROOTDIR}/usr/lib/libX.a/bin/rps
			 ${ROOTDIR}/usr/bin/srload
			 ${ROOTDIR}/usr/lib/libX.a/bin/sparcv7/rps
			 ${ROOTDIR}/usr/sbin/modcheck"
	XORGSUNOS_DIRS="${ROOTDIR}/usr/lib/libX.a
			${ROOTDIR}/usr/lib/libX.a/bin
			${ROOTDIR}/usr/lib/libX.a/bin/sparcv7
			${ROOTDIR}/usr/share/man..."


	# zaRwT.KiT Rootkit
	ZARWT_FILES="${ROOTDIR}/dev/rd/s/sendmeil
		     ${ROOTDIR}/dev/ttyf
		     ${ROOTDIR}/dev/ttyp
		     ${ROOTDIR}/dev/ttyn
		     ${ROOTDIR}/rk/tulz"
	ZARWT_DIRS="${ROOTDIR}/rk
		    ${ROOTDIR}/dev/rd/s"


	# Miscellaneous login backdoors
	LOGIN_BACKDOOR_FILES="${ROOTDIR}/bin/.login
			      ${ROOTDIR}/sbin/.login"


	# Suspicious directories
	SUSPICIOUS_DIRS="${ROOTDIR}/usr/X11R6/bin/.,/copy
			 ${ROOTDIR}/dev/rd/cdb"


	# Evil strings
	STRINGSCAN="init:/dev/proc/fuckit:Fuckit Rootkit
		    init:FUCK:Possible Suckit Rootkit found
		    init:backdoor:Possible backdoored init file (Suckit)
		    login:vt200:Possible Linux Rootkit (LRK4)
		    login:/usr/bin/xstat:Possible Linux Rootkit (LRK4)
		    login:/bin/envpc:Possible Linux Rootkit (LRK4)
		    login:L4m3r0x:Possible Linux Rootkit (LRK4)
		    login:/usr/lib/.tbd:TBD Rootkit
		    ls:/dev/ptyxx/.file:Dica-Kit Rootkit
		    ls:/dev/sgk:Possible Linux Rootkit (LRK4)
		    ls:/var/lock/subsys/...datafile...:Ohhara Rootkit
		    ls:/usr/lib/.tbd:TBD Rootkit
		    netstat:/dev/proc/fuckit:Fuckit Rootkit
		    netstat:/lib/.sso:Dica-Kit Rootkit
		    netstat:/var/lock/subsys/...datafile...:Ohhara Rootkit
		    netstat:/dev/caca:MRK Rootkit
		    netstat:/dev/ttyoa:Sin Rootkit
		    netstat:syg:Possible trojaned netstat
		    nscd:sshd_config:Possible backdoor shell installed (SSH)
		    ps:/dev/pts/01:SunOS Rootkit
		    ps:tw33dl3:SunOS Rootkit
		    ps:psniff:SunOS Rootkit
		    ps:/var/lock/subsys/...datafile...:Ohhara Rootkit or Ni0 Rootkit
		    rpc.nfsd:cant open log:Possible sniffer installed
		    rpc.nfsd:sniff.pid:Possible sniffer installed
		    rpc.nfsd:tcp.log:Possible sniffer installed
		    sshd:/dev/ptyxx:OpenBSD Rootkit
		    syslogd:promiscuous:Possible sniffer installed
		    syslogd:/usr/lib/.tbd:TBD Rootkit
		    tcpd:/dev/xdta:Dica-Kit Rootkit
		    top:/usr/lib/.tbd:TBD Rootkit
		    xtty:/bin/sh:Possible backdoor shell installed
		    rcfile:in.inetd:SHV4 Rootkit
		    rcfile:#<HIDE_.*>:Enye LKM
		    rcfile:bin/xchk:Optic Kit (Tux) Worm
		    rcfile:bin/xsf:Optic Kit (Tux) Worm"


	# Possible rootkit files and directories
	FILESCAN="file:${ROOTDIR}/dev/sdr0:Possible T0rn Rootkit MD5 hash database
		  file:${ROOTDIR}/tmp/.syshackfile:Trojaned syslog daemon
		  file:${ROOTDIR}/tmp/.bash_history:Possible Lite5-r Rootkit
		  file:${ROOTDIR}/usr/info/.clib:Possible backdoor
		  file:${ROOTDIR}/usr/sbin/tcp.log:Possible sniffer
		  file:${ROOTDIR}/usr/bin/take/pid:Trojaned SSH daemon
		  file:${ROOTDIR}/sbin/create:MzOzD Local backdoor
		  file:${ROOTDIR}/dev/ttypz:spwn login backdoor
		  dir:${ROOTDIR}/usr/bin/take:Trojaned SSH daemon
		  dir:${ROOTDIR}/usr/src/.lib:Unusual directory
		  dir:${ROOTDIR}/usr/share/man/man1/.1c:Possible Eggdrop installed
		  dir:${ROOTDIR}/lib/lblip.tk:Possible T0rn Rootkit directory with backdoored SSH-configuration
		  dir:${ROOTDIR}/usr/sbin/...:Unusual directory
		  dir:${ROOTDIR}/usr/share/.gun:Unusual directory"


	# Evil strings for FreeBSD KLD (Dynamic Kernel Linker modules)
	KLDSTATKEYWORDS="backd00r backdoor"


	RCLOCAL_STRINGS="/usr/bin/rpc.wall:Unknown
			 sshdd:Possible%%GasKit
			 hidef:Possible%%part%%of%%Knark%%found"

	# Suspicious open files
	SUSP_FILES_INFO="backdoor:Generic backdoor
			 adore.o:Adore LKM rootkit
			 mod_rootme.so:Apache mod_rootme backdoor
			 phide_mod.o:PID hider LKM
			 lbk.ko:LBK FreeBSD kernel module
			 vlogger.o:THC-Vlogger kernel module
			 cleaner.o:Cleaner kernel module
			 mod_klgr.o:klgr, keyboard logger (kernel module)
			 hydra:THC-Hydra (password capture)
			 hydra.restore:THC-Hydra (password capture)"

	# Integrity tests
	STRINGS_INTEGRITY="${BOBKIT_FILES} ${BOBKIT_DIRS} ${CINIK_FILES}
			   ${CINIK_DIRS} ${DICA_FILES} ${FREEBSD_RK_FILES}
			   ${TBD_FILES} ${TORN_FILES} ${TORN_DIRS}"


	SNIFFER_FILES="${ROOTDIR}/usr/lib/libice.log"


	HTTPDCONFS="${ROOTDIR}/usr/local/apache/conf/httpd.conf
		    ${ROOTDIR}/usr/local/etc/apache/httpd.conf
		    ${ROOTDIR}/etc/apache/httpd.conf
		    ${ROOTDIR}/etc/httpd/conf/httpd.conf"


	# Known bad Linux kernel modules
	LKM_BADNAMES="adore.o
		      cleaner.o
		      flkm.o
		      phide_mod.o
		      vlogger.o"

	return
}


strings_check() {

	#
	# This function carries out the 'strings' command check.
	# It passes specific strings through the strings command to
	# see if they are missing. If so, then it can indicate that
	# the command has been modified to hide information.
	#

	if ! `check_test strings`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST strings
		return
	fi


	display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 STRINGS_CHECK_START


	#
	# First check to see if we have a 'strings' command.
	#

	if [ -z "${STRINGS_CMD}" ]; then
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --screen-indent 4 STRINGS_CHECK
		display --to LOG --type INFO NOT_FOUND_CMD "strings"
		return
	fi


	#
	# The pathnames to check will have the ROOTDIR at
	# the front. We need to strip this off before passing
	# it through the 'strings' command. If we didn't then
	# we would be looking for the wrong pathname.
	#

	STRINGSFAILED=0

	RDIR=`echo "${ROOTDIR}" | sed -e 's/\//\\\\\//g'`

	for STRING in ${STRINGS_INTEGRITY}; do
		STRING=`echo "${STRING}" | sed -e "s/^${RDIR}//"`

		STRINGNAME=`echo "${STRING}" | sed -e 's/\./\\\./g'`
		STRING_SEEN=`echo "${STRING}" | ${STRINGS_CMD} | grep "${STRINGNAME}" | tr -d ' '`

		if [ -z "${STRING_SEEN}" ]; then
			STRINGSFAILED=1
			display --to LOG --type WARNING --result WARNING STRINGS_SCANNING_BAD "${STRING}"
		elif [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --result OK STRINGS_SCANNING_OK "${STRING}"
		fi
	done


	if [ $STRINGSFAILED -eq 0 ]; then
		RKHTMPVAR="SCREEN"
		test $VERBOSE_LOGGING -eq 0 && RKHTMPVAR="SCREEN+LOG"

		display --to "${RKHTMPVAR}" --type PLAIN --result OK --color GREEN --screen-indent 4 STRINGS_CHECK
	else
		display --to SCREEN --type PLAIN --result WARNING --color RED --screen-indent 4 STRINGS_CHECK
	fi

	return
}


shared_libs_check() {

	#
	# This function checks shared library loading problems.
	# It is part of do_system_commands_checks and should precede or run
	# just after strings_check if enabled.
	#

	#
	# Remarks:
	# Oracle-10.1.0.3 on RHEL3 needs /etc/libcwait.so,
	# F-PROT Antivirus for GNU/Linux needs f-prot.so,
	# AVAYA Labs "stack overflow protection" uses libsafe.
	#

	if ! `check_test shared_libs`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST shared_libs
		return
	fi

	display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 SHARED_LIBS_START


	#
	# First check for preloading exported variables.
	#

	VARFOUND=""

	for RKHTMPVAR in LD_PRELOAD LD_AOUT_PRELOAD LD_ELF_PRELOAD; do
		RKHTMPVAR_RES=`eval echo "\\$${RKHTMPVAR}"`

		if [ -n "${RKHTMPVAR_RES}" ]; then
			VARFOUND="${VARFOUND} ${RKHTMPVAR}"
		fi
	done

	if [ -z "${VARFOUND}" ]; then
		display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 SHARED_LIBS_PRELOAD_VAR
	else
		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 SHARED_LIBS_PRELOAD_VAR
		display --to LOG --type WARNING SHARED_LIBS_PRELOAD_VAR_FOUND "${VARFOUND}"
	fi


	#
	# Next check for a preload file.
	#

	RKHTMPVAR=${ROOTDIR}/etc/ld.so.preload

	if [ -f ${RKHTMPVAR} ]; then
		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 SHARED_LIBS_PRELOAD_FILE
		display --to LOG --type WARNING SHARED_LIBS_PRELOAD_FILE_FOUND "${RKHTMPVAR}"
	else
		display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 SHARED_LIBS_PRELOAD_FILE
	fi


	#
	# Finally we check the LD_LIBRARY_PATH. This check may be
	# disabled by the user if the 'ldd' command is not available.
	#

	if `check_test shared_libs_path`; then
		if [ -n "${LDD_CMD}" ]; then
			if [ -n "${LD_LIBRARY_PATH}" ]; then
				LD_LIBR_FAILED=0
				LD_LIBRARY_PATH_SAVED="${LD_LIBRARY_PATH}"

				RKHTMPVAR_BIN="${FIND_CMD} ${PS_CMD}
					${STRINGS_CMD} ${MD5_CMD} ${LS_CMD}
					${STAT_CMD}"

				for RKHTMPVAR in ${RKHTMPVAR_BIN}; do
					LD_LIBRARY_PATH="${LD_LIBRARY_PATH_SAVED}"
					export LD_LIBRARY_PATH
					RKHTMPVAR_WITH=`${LDD_CMD} ${RKHTMPVAR} 2>&1`

					unset LD_LIBRARY_PATH
					RKHTMPVAR_WITHOUT=`${LDD_CMD} ${RKHTMPVAR} 2>&1`

					if [ "${RKHTMPVAR_WITH}" != "${RKHTMPVAR_WITHOUT}" ]; then
						#
						# Testing one command should be "evidence" enough.
						#

						LD_LIBR_FAILED=1
						break
					fi
				done


				#
				# Reset things to the way they were before.
				#

				LD_LIBRARY_PATH="${LD_LIBRARY_PATH_SAVED}"
				export LD_LIBRARY_PATH


				if [ $LD_LIBR_FAILED -eq 0 ]; then
					display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --screen-indent 4 SHARED_LIBS_PATH
				else
					display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 SHARED_LIBS_PATH
					display --to LOG --type WARNING SHARED_LIBS_PATH_BAD "${LD_LIBRARY_PATH}"
				fi
			else
				display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 SHARED_LIBS_PATH
			fi
		else
			display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --screen-indent 4 SHARED_LIBS_PATH
			display --to LOG --type INFO NOT_FOUND_CMD "ldd"
		fi
	else
		display --to LOG --type INFO USER_DISABLED_TEST shared_libs_path
	fi

	return
}


file_properties_check() {

	#
	# This function carries out a check of system command property
	# values checked against their previous value, which is stored
	# in the rkhunter.dat file. Other checks work on the current
	# file, and do not use any previously stored value (for example,
	# the immutable bit check).
	#

	#
	# Each test will set the variable TEST_RESULT, and use it to
	# display the actual result. Typically a null string indicates
	# 'OK', and anything else is 'BAD'.
	#

	TEST_RESULT=""
	WHITELIST_RESULT=""
	SKIP_ATTR=0; SKIP_HASH=0; SKIP_IMMUT=0; SKIP_SCRIPT=0
	USE_DAT_FILE=1
	SKIP_IMMUT_OS=0
	PROP_FILE_LIST_COUNT=0

	#
	# In order to disable the whole test we have to check if
	# each specific test has been disabled.
	#

	for RKHTMPVAR in attributes hashes immutable scripts; do
		if ! `check_test ${RKHTMPVAR}`; then
			test "${RKHTMPVAR}" = "attributes" && SKIP_ATTR=1
			test "${RKHTMPVAR}" = "hashes" && SKIP_HASH=1
			test "${RKHTMPVAR}" = "immutable" && SKIP_IMMUT=1
			test "${RKHTMPVAR}" = "scripts" && SKIP_SCRIPT=1
		fi
	done

	#
	# The immutable-bit test is only applicable to Linux systems.
	# We need to disable the test, but not have it logged as if
	# the user had disabled it (that would be confusing).
	#

	if [ "${OPERATING_SYSTEM}" != "Linux" ]; then
		test $SKIP_IMMUT -eq 0 && SKIP_IMMUT_OS=1
		SKIP_IMMUT=1
	fi

	if ! `check_test properties`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST properties
		return
	elif [ $SKIP_ATTR -eq 1 -a $SKIP_HASH -eq 1 -a $SKIP_IMMUT -eq 1 -a $SKIP_SCRIPT -eq 1 ]; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST properties
		return
	fi


	display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 FILE_PROP_START


	#
	# If the user wants to skip a test then log it.
	#

	for RKHTMPVAR in attributes hashes immutable scripts; do
		test "${RKHTMPVAR}" = "attributes" && TEST_NAME=$SKIP_ATTR
		test "${RKHTMPVAR}" = "hashes" && TEST_NAME=$SKIP_HASH
		test "${RKHTMPVAR}" = "scripts" && TEST_NAME=$SKIP_SCRIPT

		if [ "${RKHTMPVAR}" = "immutable" ]; then
			TEST_NAME=0
			test $SKIP_IMMUT_OS -eq 0 && TEST_NAME=$SKIP_IMMUT
		fi

		if [ $TEST_NAME -eq 1 ]; then
			display --to LOG --type INFO USER_DISABLED_TEST ${RKHTMPVAR}
		fi
	done


	#
	# The first test we do is on the commands needed to
	# perform all the file checks. If the user has not
	# disabled any test, and a command is missing, then
	# we must let them know that without marking each file
	# test as 'BAD' (because that could hide a real problem).
	# We include checks on the rkhunter.dat file as well.
	#

	RKHTMPVAR=""

	if [ $SKIP_ATTR -eq 0 -a -z "${STAT_CMD}" ]; then
		SKIP_ATTR=1
		RKHTMPVAR="${RKHTMPVAR} attr"
	fi

	if [ $SKIP_HASH -eq 0 ]; then
		if [ -z "${HASH_FUNC}" ]; then
			SKIP_HASH=1
			RKHTMPVAR="${RKHTMPVAR} hash"
		fi

		if [ -z "${PRELINK_CMD}" ]; then
			SKIP_HASH=1
			RKHTMPVAR="${RKHTMPVAR} prelink"
		fi

		if [ $PRELINKED -eq 1 ]; then
			if [ $SKIP_HASH_MSG -eq 2 ]; then
				SKIP_HASH=1
				RKHTMPVAR="${RKHTMPVAR} sha1"
			fi

			if [ $SKIP_HASH_MSG -eq 3 ]; then
				SKIP_HASH=1
				RKHTMPVAR="${RKHTMPVAR} libsafe"
			fi
		fi
	fi

	if [ $SKIP_IMMUT -eq 0 -a -z "${LSATTR_CMD}" ]; then
		SKIP_IMMUT=1
		RKHTMPVAR="${RKHTMPVAR} immutable"
	fi

	if [ $SKIP_SCRIPT -eq 0 -a -z "${FILE_CMD}" ]; then
		SKIP_SCRIPT=1
		RKHTMPVAR="${RKHTMPVAR} script"
	fi

	if [ $SKIP_ATTR -eq 0 -o $SKIP_HASH -eq 0 ]; then
		if [ ! -f "${DB_PATH}/rkhunter.dat" ]; then
			SKIP_HASH=1
			SKIP_ATTR=1
			USE_DAT_FILE=0
			RKHTMPVAR="${RKHTMPVAR} missing"
		fi

		if [ $USE_DAT_FILE -eq 1 -a ! -s "${DB_PATH}/rkhunter.dat" ]; then
			SKIP_HASH=1
			SKIP_ATTR=1
			USE_DAT_FILE=0
			RKHTMPVAR="${RKHTMPVAR} empty"
		fi
	else
		#
		# If we are not checking the file attributes or
		# the hash value, then we don't need to look at
		# the rkhunter.dat file. The other tests can be
		# done without the file.
		#

		USE_DAT_FILE=0
	fi

	#
	# If all the previous checks have disabled all the tests,
	# then we tell the user and then return.
	#

	if [ $SKIP_ATTR -eq 1 -a $SKIP_HASH -eq 1 -a $SKIP_IMMUT -eq 1 -a $SKIP_SCRIPT -eq 1 ]; then
		RKHTMPVAR="${RKHTMPVAR} notests"
	fi


	#
	# Display the results.
	#

	if [ $SKIP_IMMUT_OS -eq 1 ]; then
		display --to LOG --type INFO FILE_PROP_IMMUT_OS
	fi

	if [ -z "${RKHTMPVAR}" ]; then
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 --result OK --color GREEN FILE_PROP_CMDS
	else
		SUMMARY_PROP_REQCMDS=1

		display --to SCREEN+LOG --type WARNING --screen-indent 4 --result WARNING --color RED FILE_PROP_CMDS


		RKHTMPVAR2=0
		for TEST_RESULT in ${RKHTMPVAR}; do
			case "${TEST_RESULT}" in
			attr)
				display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SKIP_ATTR
				;;
			hash|prelink|sha1|libsafe)
				if [ $RKHTMPVAR2 -eq 0 ]; then
					RKHTMPVAR2=1
					display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SKIP_HASH
				fi

				case "${TEST_RESULT}" in
				hash)
					display --to LOG --type PLAIN --log-indent 13 FILE_PROP_SKIP_HASH_FUNC
					;;
				prelink)
					display --to LOG --type PLAIN --log-indent 13 FILE_PROP_SKIP_HASH_PRELINK
					;;
				sha1)
					display --to LOG --type PLAIN --log-indent 13 FILE_PROP_SKIP_HASH_SHA1
					;;
				libsafe)
					display --to LOG --type PLAIN --log-indent 13 FILE_PROP_SKIP_HASH_LIBSAFE
					;;
				esac
				;;
			immutable)
				display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SKIP_IMMUT
				;;
			script)
				display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SKIP_SCRIPT
				;;
			missing)
				display --to LOG --type PLAIN --log-indent 9 FILE_PROP_DAT_MISSING
				;;
			empty)
				display --to LOG --type PLAIN --log-indent 9 FILE_PROP_DAT_EMPTY
				;;
			esac
		done


		if [ -n "`echo \"${RKHTMPVAR}\" | egrep 'libsafe|missing|empty'`" ]; then
			display --to LOG --type WARNING --nl PROPUPD_WARN
		fi

		if [ -n "`echo \"${RKHTMPVAR}\" | grep 'notests'`" ]; then
			display --to LOG --type WARNING --nl FILE_PROP_SKIP_ALL
			return
		fi
	fi


	#
	# Set up some local variables depending on what
	# commands we have available.
	#

	if [ $SKIP_ATTR -eq 1 ]; then
		SCMD=""
		FDATA=""
	else
		if [ -n "`echo ${STAT_CMD} | grep '\.pl$'`" ]; then
			SCMD="${STAT_CMD} --modeoct --raw --mode --ino -uid -gid -Mtime"
		else
			if [ "${OPERATING_SYSTEM}" = "NetBSD" ]; then
				SCMD="${STAT_CMD} -f '%i %Mp%Lp %u %g %m:'"
			else
				SCMD="${STAT_CMD} --format='%i 0%a %u %g %Y:'"
			fi
		fi
	fi

	if [ $SKIP_HASH -eq 1 ]; then
		HCMD=""
		SYSHASH=""
	else
		if [ $PRELINKED -eq 0 ]; then
			HCMD=$HASH_FUNC
		else
			if [ -n "`echo ${HASH_FUNC} | grep 'md5'`" ]; then
				HCMD="${PRELINK_CMD} --verify --md5"
			else
				HCMD="${PRELINK_CMD} --verify --sha"
			fi
		fi

		if [ "${OPERATING_SYSTEM}" = "OpenBSD" -a "${HCMD}" = "/bin/md5" ]; then
			HSH_FLD_IDX=4
		else
			HSH_FLD_IDX=1
		fi
	fi

	#
	# Set up some whitelist variables. There is no point
	# recalculating the (static) whitelist as we look at
	# each file. We may as well just do it the once here.
	#

	if [ $SKIP_HASH -eq 0 ]; then
		HASHWHITELIST=`grep '^HASHWHITELIST=' ${CONFIGFILE} | sed -e 's/HASHWHITELIST=//g'`
	fi

	if [ $SKIP_ATTR -eq 0 ]; then
		ATTRWHITELIST=`grep '^ATTRWHITELIST=' ${CONFIGFILE} | sed -e 's/ATTRWHITELIST=//g'`
		WRITEWHITELIST=`grep '^WRITEWHITELIST=' ${CONFIGFILE} | sed -e 's/WRITEWHITELIST=//g'`
	fi

	if [ $SKIP_IMMUT -eq 0 ]; then
		IMMUTWHITELIST=`grep '^IMMUTWHITELIST=' ${CONFIGFILE} | sed -e 's/IMMUTWHITELIST=//g'`
	fi

	if [ $SKIP_SCRIPT -eq 0 ]; then
		SCRIPTWHITELIST=`grep '^SCRIPTWHITELIST=' ${CONFIGFILE} | sed -e 's/SCRIPTWHITELIST=//g'`
	fi


	#
	# Now loop through each of the files and
	# perform the tests on each one.
	#

	for DIR in ${PROP_DIR_LIST}; do
		for FNAME in ${PROP_FILE_LIST}; do
			TEST_RESULT=""
			WHITELIST_RESULT=""


			#
			# We first need to test if the file exists or not,
			# and if the file is listed in the rkhunter.dat
			# file or not. This can indicate files that have
			# appeared or disappeared on the system.
			#

			if [ -f "${DIR}/${FNAME}" -a ! -h "${DIR}/${FNAME}" ]; then
				FILE_EXISTS=1
				PROP_FILE_LIST_COUNT=`expr ${PROP_FILE_LIST_COUNT} + 1`
			else
				FILE_EXISTS=0
			fi

			if [ $USE_DAT_FILE -eq 1 ]; then
				RKHLINE=`grep "^File:${DIR}/${FNAME}:" ${DB_PATH}/rkhunter.dat`

				if [ $FILE_EXISTS -eq 1 -a -z "${RKHLINE}" ]; then
					TEST_RESULT="${TEST_RESULT} norkhline"
				elif [ $FILE_EXISTS -eq 0 ]; then
					if [ -n "${RKHLINE}" ]; then
						PROP_FAILED_COUNT=`expr ${PROP_FAILED_COUNT} + 1`

						display --to SCREEN+LOG --type PLAIN --screen-indent 4 --result BAD --color RED FILE_PROP_FILENAME "${DIR}/${FNAME}"
						display --to LOG --type WARNING FILE_PROP_FILE_NOT_EXIST "${DIR}/${FNAME}"
					fi

					continue
				fi
			else
				if [ $FILE_EXISTS -eq 1 ]; then
					RKHLINE=""
				else
					continue
				fi
			fi


			if [ $USE_DAT_FILE -eq 1 -a -n "${RKHLINE}" ]; then
				#
				# Do the file hash value check.
				#

				if [ $SKIP_HASH -eq 0 ]; then
					RKHTMPVAR=""
					RKHHASH=`echo ${RKHLINE} | cut -d: -f3`

					if [ -n "${RKHHASH}" ]; then
						SYSHASH=`${HCMD} ${DIR}/${FNAME} 2>/dev/null | cut -d' ' -f $HSH_FLD_IDX`

						if [ "${RKHHASH}" != "${SYSHASH}" ]; then
							RKHTMPVAR="hashchanged"
						fi
					else
						RKHTMPVAR="norkhhash"
					fi


					#
					# Test if the file is whitelisted.
					#

					if [ -n "${RKHTMPVAR}" ]; then
						for WHITELISTFILE in ${HASHWHITELIST}; do
							WL_FILE=`echo ${WHITELISTFILE} | cut -d: -f1`
							WL_HASH=`echo ${WHITELISTFILE} | cut -d: -f2`

							if [ "${WL_FILE}" = "${DIR}/${FNAME}" ]; then
								if [ "${WL_HASH}" = "${RKHHASH}" ]; then
									RKHTMPVAR=""
									WHITELIST_RESULT="${WHITELIST_RESULT} hash"
								else
									RKHTMPVAR="${RKHTMPVAR} hwlinvalid"
								fi

								break
							fi
						done

						test -n "${RKHTMPVAR}" && TEST_RESULT="${TEST_RESULT} ${RKHTMPVAR}"
					fi
				fi


				#
				# Do the file attributes checks.
				# This checks the files permissions, and the
				# uid/gid. If prelinking is not in use then
				# the inode and modification date-time are
				# checked as well. We also check the file
				# permissions to see if 'w' has been
				# allowed for all users.
				#

				if [ $SKIP_ATTR -eq 0 ]; then
					RKHTMPVAR=""
					WL_FILE=""

					#
					# We check to see if the file is whitelisted here,
					# just the once. It is better than checking after
					# each individual attribute test.
					#

					for WHITELISTFILE in ${ATTRWHITELIST}; do
						if [ "${WHITELISTFILE}" = "${DIR}/${FNAME}" ]; then
							WL_FILE="whitelisted"
							WHITELIST_RESULT="${WHITELIST_RESULT} attr"
							break
						fi
					done

					FDATA=`eval ${SCMD} ${DIR}/${FNAME} 2>/dev/null | tr ' ' ':'`

					if [ -z "${WL_FILE}" -a -n "${FDATA}" ]; then
						#
						# Check the file permissions.
						#

						RKHTMPVAR=""

						RKHPERM=`echo ${RKHLINE} | cut -d: -f5`
						SYSPERM=`echo ${FDATA} | cut -d: -f2`

						if [ -n "${RKHPERM}" ]; then
							if [ "${RKHPERM}" != "${SYSPERM}" ]; then
								RKHTMPVAR="permchanged"
							fi
						else
							RKHTMPVAR="norkhperm"
						fi

						test -n "${RKHTMPVAR}" && TEST_RESULT="${TEST_RESULT} ${RKHTMPVAR}"


						#
						# Check the file user-id.
						#

						RKHTMPVAR=""
						RKHUID=`echo ${RKHLINE} | cut -d: -f6`
						SYSUID=`echo ${FDATA} | cut -d: -f3`

						if [ -n "${RKHUID}" ]; then
							if [ "${RKHUID}" != "${SYSUID}" ]; then
								RKHTMPVAR="uidchanged"
							fi
						else
							RKHTMPVAR="norkhuid"
						fi

						test -n "${RKHTMPVAR}" && TEST_RESULT="${TEST_RESULT} ${RKHTMPVAR}"


						#
						# Check the file group-id.
						#

						RKHTMPVAR=""
						RKHGID=`echo ${RKHLINE} | cut -d: -f7`
						SYSGID=`echo ${FDATA} | cut -d: -f4`

						if [ -n "${RKHGID}" ]; then
							if [ "${RKHGID}" != "${SYSGID}" ]; then
								RKHTMPVAR="gidchanged"
							fi
						else
							RKHTMPVAR="norkhgid"
						fi

						test -n "${RKHTMPVAR}" && TEST_RESULT="${TEST_RESULT} ${RKHTMPVAR}"


						if [ $PRELINKED -eq 0 ]; then
							#
							# Check the file inode number.
							#

							RKHTMPVAR=""
							RKHINODE=`echo ${RKHLINE} | cut -d: -f4`
							SYSINODE=`echo ${FDATA} | cut -d: -f1`

							if [ -n "${RKHINODE}" ]; then
								if [ "${RKHINODE}" != "${SYSINODE}" ]; then
									RKHTMPVAR="inodechanged"
								fi
							else
								RKHTMPVAR="norkhinode"
							fi

							test -n "${RKHTMPVAR}" && TEST_RESULT="${TEST_RESULT} ${RKHTMPVAR}"


							#
							# Check the file modification date-time.
							#

							RKHTMPVAR=""
							RKHDTM=`echo ${RKHLINE} | cut -d: -f8`
							SYSDTM=`echo ${FDATA} | cut -d: -f5`

							if [ -n "${RKHDTM}" ]; then
								if [ "${RKHDTM}" != "${SYSDTM}" ]; then
									RKHTMPVAR="dtmchanged"
								fi
							else
								RKHTMPVAR="norkhdtm"
							fi

							test -n "${RKHTMPVAR}" && TEST_RESULT="${TEST_RESULT} ${RKHTMPVAR}"
						fi
					elif [ -z "${WL_FILE}" ]; then
						TEST_RESULT="${TEST_RESULT} sysattrunavail"
					fi


					#
					# We check the file permissions here
					# to see if the 'other' permission
					# contains a 'w'. The check is
					# against the octal value.
					#

					SYSPERM=`echo ${FDATA} | cut -d: -f2`
					RKHTMPVAR=`echo ${SYSPERM} | grep '[2367]$'`

					if [ -n "${RKHTMPVAR}" ]; then
						for WHITELISTFILE in ${WRITEWHITELIST}; do
							if [ "${WHITELISTFILE}" = "${DIR}/${FNAME}" ]; then
								RKHTMPVAR=""
								WHITELIST_RESULT="${WHITELIST_RESULT} write"
								break
							fi
						done

						test -n "${RKHTMPVAR}" && TEST_RESULT="${TEST_RESULT} write"
					elif [ -z "${SYSPERM}" ]; then
						TEST_RESULT="${TEST_RESULT} syspermunavail"
					fi
				fi
			fi


			#
			# We can now carry out the tests which do not
			# require the rkhunter.dat file.
			#

			#
			# Do the file immutable-bit check.
			#

			if [ $SKIP_IMMUT -eq 0 ]; then
				RKHTMPVAR=`${LSATTR_CMD} ${DIR}/${FNAME} 2>/dev/null | cut -d' ' -f1 | grep 'i'`


				#
				# Test if the file is whitelisted.
				#

				if [ -n "${RKHTMPVAR}" ]; then
					for WHITELISTFILE in ${IMMUTWHITELIST}; do
						if [ "${WHITELISTFILE}" = "${DIR}/${FNAME}" ]; then
							RKHTMPVAR=""
							WHITELIST_RESULT="${WHITELIST_RESULT} immutable"
							break
						fi
					done

					test -n "${RKHTMPVAR}" && TEST_RESULT="${TEST_RESULT} immutable"
				fi
			fi


			#
			# Do the file script replacement check.
			#

			if [ $SKIP_SCRIPT -eq 0 ]; then
				SYSSCRIPT=`${FILE_CMD} ${DIR}/${FNAME} 2>&1 | egrep -i ' script( |$)'`


				#
				# Test if the file is whitelisted.
				#

				if [ -n "${SYSSCRIPT}" ]; then
					for WHITELISTFILE in ${SCRIPTWHITELIST}; do
						if [ "${WHITELISTFILE}" = "${DIR}/${FNAME}" ]; then
							SYSSCRIPT=""
							WHITELIST_RESULT="${WHITELIST_RESULT} file"
							break
						fi
					done

					test -n "${SYSSCRIPT}" && TEST_RESULT="${TEST_RESULT} file"
				fi
			fi


			#
			# Now output the results.
			#

			if [ -z "${TEST_RESULT}" ]; then
				display --to SCREEN+LOG --type PLAIN --screen-indent 4 --result OK --color GREEN FILE_PROP_FILENAME "${DIR}/${FNAME}"
			else
				display --to SCREEN+LOG --type PLAIN --screen-indent 4 --result WARNING --color RED FILE_PROP_FILENAME "${DIR}/${FNAME}"

				PROP_FAILED_COUNT=`expr ${PROP_FAILED_COUNT} + 1`

				RKHTMPVAR2=0
				for RKHTMPVAR in ${TEST_RESULT}; do
					case "${RKHTMPVAR}" in
					hashchanged|permchanged|uidchanged|gidchanged|inodechanged|dtmchanged)
						if [ $RKHTMPVAR2 -eq 0 ]; then
							RKHTMPVAR2=1
							display --to LOG --type WARNING FILE_PROP_CHANGED
							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_CHANGED2 "${DIR}/${FNAME}"
						fi

						case "${RKHTMPVAR}" in
						hashchanged)
							if [ -z "${SYSHASH}" ]; then
								display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SYSHASH_UNAVAIL
							else
								display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SYSHASH "${SYSHASH}"
							fi

							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_RKHHASH "${RKHHASH}"
							;;
						permchanged)
							if [ -z "${SYSPERM}" ]; then
								display --to LOG --type PLAIN --log-indent 9 FILE_PROP_PERM_UNAVAIL "${RKHPERM}"
							else
								display --to LOG --type PLAIN --log-indent 9 FILE_PROP_PERM "${SYSPERM}" "${RKHPERM}"
							fi
							;;
						uidchanged)
							if [ -z "${SYSUID}" ]; then
								display --to LOG --type PLAIN --log-indent 9 FILE_PROP_UID_UNAVAIL "${RKHUID}"
							else
								display --to LOG --type PLAIN --log-indent 9 FILE_PROP_UID "${SYSUID}" "${RKHUID}"
							fi
							;;
						gidchanged)
							if [ -z "${SYSGID}" ]; then
								display --to LOG --type PLAIN --log-indent 9 FILE_PROP_GID_UNAVAIL "${RKHGID}"
							else
								display --to LOG --type PLAIN --log-indent 9 FILE_PROP_GID "${SYSGID}" "${RKHGID}"
							fi
							;;
						inodechanged)
							if [ -z "${SYSINODE}" ]; then
								display --to LOG --type PLAIN --log-indent 9 FILE_PROP_INODE_UNAVAIL "${RKHINODE}"
							else
								display --to LOG --type PLAIN --log-indent 9 FILE_PROP_INODE "${SYSINODE}" "${RKHINODE}"
							fi
							;;
						dtmchanged)
							if [ -z "${SYSDTM}" ]; then
								display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SYSDTM_UNAVAIL
							else
								display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SYSDTM "${SYSDTM}"
							fi

							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_RKHDTM "${RKHDTM}"
							;;
						esac
						;;
					norkhline)
						display --to LOG --type WARNING FILE_PROP_NO_RKH_REC "${DIR}/${FNAME}"
						;;
					norkhhash)
						display --to LOG --type WARNING FILE_PROP_NO_RKHHASH "${DIR}/${FNAME}"
						;;
					norkhperm)
						display --to LOG --type WARNING FILE_PROP_NO_RKHPERM "${DIR}/${FNAME}"
						;;
					norkhuid)
						display --to LOG --type WARNING FILE_PROP_NO_RKHUID "${DIR}/${FNAME}"
						;;
					norkhgid)
						display --to LOG --type WARNING FILE_PROP_NO_RKHGID "${DIR}/${FNAME}"
						;;
					norkhinode)
						display --to LOG --type WARNING FILE_PROP_NO_RKHINODE "${DIR}/${FNAME}"
						;;
					norkhdtm)
						display --to LOG --type WARNING FILE_PROP_NO_RKHDTM "${DIR}/${FNAME}"
						;;
					sysattrunavail)
						display --to LOG --type WARNING FILE_PROP_NO_SYSATTR "${DIR}/${FNAME}"
						;;
					write)
						display --to LOG --type WARNING FILE_PROP_WRITE "${DIR}/${FNAME}"
						;;
					syspermunavail)
						display --to LOG --type WARNING FILE_PROP_SYSPERM_UNAVAIL "${DIR}/${FNAME}"
						;;
					immutable)
						display --to LOG --type WARNING FILE_PROP_IMMUT "${DIR}/${FNAME}"
						;;
					file)
						display --to LOG --type WARNING FILE_PROP_SCRIPT "${DIR}/${FNAME}" "${SYSSCRIPT}"
						;;
					esac
				done
			fi

			if [ -n "${WHITELIST_RESULT}" ]; then
				for WL_FILE in ${WHITELIST_RESULT}; do
					case "${WL_FILE}" in
					hash)
						RKHTMPVAR="file hash"
						;;
					attr)
						RKHTMPVAR="file attributes"
						;;
					write)
						RKHTMPVAR="file write permission"
						;;
					immutable)
						RKHTMPVAR="file immutable-bit"
						;;
					file)
						RKHTMPVAR="script replacement"
						;;
					esac

					display --to LOG --type INFO FILE_PROP_WL "${DIR}/${FNAME}" "${RKHTMPVAR}"
				done
			fi

			if [ -n "`echo \"${TEST_RESULT}\" | grep 'hwlinvalid'`" ]; then
				display --to LOG -type INFO FILE_PROP_HASH_WL_INVALID "${DIR}/${FNAME}" "${WL_HASH}"
			fi
		done
	done

	return
}


do_system_commands_checks() {

	#
	# This function carries out a sequence of tests on
	# system commands. These consist of the 'strings' command
	# check, library checks and the file properties checks.
	#

	if ! `check_test system_commands`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST system_commands
		return
	fi


	display --to SCREEN+LOG --type PLAIN --color YELLOW --nl CHECK_SYS_COMMANDS


	strings_check

	shared_libs_check

	file_properties_check

	keypresspause

	return
}


rootkit_file_dir_checks() {

	#
	# This function performs the check for known rootkit
	# files and directories.
	#

	if ! `check_test known_rkts`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST known_rkts
		return
	fi


	display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 ROOTKIT_FILES_DIRS_START


	# 55808 Trojan - Variant A

	SCAN_ROOTKIT="55808 Trojan - Variant A"
	SCAN_FILES=${W55808A_FILES}
	SCAN_DIRS=${W55808A_DIRS}
	SCAN_KSYMS=${W55808A_KSYMS}
	scanrootkit

	# ADM Worm

	SCAN_ROOTKIT="ADM Worm"

	ROOTKIT_COUNT=`expr ${ROOTKIT_COUNT} + 1`

	if [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --nl ROOTKIT_FILES_DIRS_NAME_LOG "${SCAN_ROOTKIT}"
	fi

	if [ -f "${ROOTDIR}/etc/passwd" ]; then
		RKHTMPVAR=`grep 'w0rm' ${ROOTDIR}/etc/passwd`

		if [ -z "${RKHTMPVAR}" ]; then
			if [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result NOT_FOUND --log-indent 2 ROOTKIT_FILES_DIRS_STR "w0rm"
			fi

			display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 ROOTKIT_FILES_DIRS_NAME "${SCAN_ROOTKIT}"
		else
			ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
			ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}${SCAN_ROOTKIT}, "

			if [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result FOUND --log-indent 2 ROOTKIT_FILES_DIRS_STR "w0rm"
			fi

			display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 ROOTKIT_FILES_DIRS_NAME "${SCAN_ROOTKIT}"
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_STR_FOUND "w0rm" "${ROOTDIR}/etc/passwd"
		fi
	else
		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 ROOTKIT_FILES_DIRS_NAME "${SCAN_ROOTKIT}"
		display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_NOFILE "${ROOTDIR}/etc/passwd"
	fi

	# AjaKit Rootkit

	SCAN_ROOTKIT="AjaKit Rootkit"
	SCAN_FILES=${AJAKIT_FILES}
	SCAN_DIRS=${AJAKIT_DIRS}
	SCAN_KSYMS=${AJAKIT_KSYMS}
	scanrootkit

	# aPa Kit

	SCAN_ROOTKIT="aPa Kit"
	SCAN_FILES=${APAKIT_FILES}
	SCAN_DIRS=${APAKIT_DIRS}
	SCAN_KSYMS=${APAKIT_KSYMS}
	scanrootkit

	# Apache worm

	SCAN_ROOTKIT="Apache Worm"
	SCAN_FILES=${APACHEWORM_FILES}
	SCAN_DIRS=${APACHEWORM_DIRS}
	SCAN_KSYMS=${APACHEWORM_KSYMS}
	scanrootkit

	# Ambient (ark) Rootkit

	SCAN_ROOTKIT="Ambient (ark) Rootkit"
	SCAN_FILES=${ARK_FILES}
	SCAN_DIRS=${ARK_DIRS}
	SCAN_KSYMS=${ARK_KSYMS}
	scanrootkit

	# Balaur Rootkit

	SCAN_ROOTKIT="Balaur Rootkit"
	SCAN_FILES=${BALAUR_FILES}
	SCAN_DIRS=${BALAUR_DIRS}
	SCAN_KSYMS=${BALAUR_KSYMS}
	scanrootkit

	# BeastKit Rootkit

	SCAN_ROOTKIT="BeastKit Rootkit"
	SCAN_FILES=${BEASTKIT_FILES}
	SCAN_DIRS=${BEASTKIT_DIRS}
	SCAN_KSYMS=${BEASTKIT_KSYMS}
	scanrootkit

	# beX2 Rootkit

	SCAN_ROOTKIT="beX2 Rootkit"
	SCAN_FILES=${BEX_FILES}
	SCAN_DIRS=${BEX_DIRS}
	SCAN_KSYMS=${BEX_KSYMS}
	scanrootkit

	# BOBKit Rootkit

	SCAN_ROOTKIT="BOBKit Rootkit"
	SCAN_FILES=${BOBKIT_FILES}
	SCAN_DIRS=${BOBKIT_DIRS}
	SCAN_KSYMS=${BOBKIT_KSYMS}
	scanrootkit

	# CiNIK Worm (Slapper.B variant)

	SCAN_ROOTKIT="CiNIK Worm (Slapper.B variant)"
	SCAN_FILES=${CINIK_FILES}
	SCAN_DIRS=${CINIK_DIRS}
	SCAN_KSYMS=${CINIK_KSYMS}
	scanrootkit

	# Danny-Boy's Abuse Kit

	SCAN_ROOTKIT="Danny-Boy's Abuse Kit"
	SCAN_FILES=${DANNYBOYS_FILES}
	SCAN_DIRS=${DANNYBOYS_DIRS}
	SCAN_KSYMS=${DANNYBOYS_KSYMS}
	scanrootkit

	# Devil RootKit

	SCAN_ROOTKIT="Devil RootKit"
	SCAN_FILES=${DEVIL_FILES}
	SCAN_DIRS=${DEVIL_DIRS}
	SCAN_KSYMS=${DEVIL_KSYMS}
	scanrootkit

	# Dica-Kit Rootkit

	SCAN_ROOTKIT="Dica-Kit Rootkit"
	SCAN_FILES=${DICA_FILES}
	SCAN_DIRS=${DICA_DIRS}
	SCAN_KSYMS=${DICA_KSYMS}
	scanrootkit

	# Dreams RootKit

	SCAN_ROOTKIT="Dreams Rootkit"
	SCAN_FILES=${DREAMS_FILES}
	SCAN_DIRS=${DREAMS_DIRS}
	SCAN_KSYMS=${DREAMS_KSYMS}
	scanrootkit

	# Duarawkz Rootkit

	SCAN_ROOTKIT="Duarawkz Rootkit"
	SCAN_FILES=${DUARAWKZ_FILES}
	SCAN_DIRS=${DUARAWKZ_DIRS}
	SCAN_KSYMS=${DUARAWKZ_KSYMS}
	scanrootkit

	# Enye LKM

	SCAN_ROOTKIT="Enye LKM"
	SCAN_FILES=${ENYELKM_FILES}
	SCAN_DIRS=${ENYELKM_DIRS}
	SCAN_KSYMS=${ENYELKM_KSYMS}
	scanrootkit

	# Flea Linux Rootkit

	SCAN_ROOTKIT="Flea Linux Rootkit"
	SCAN_FILES=${FLEA_FILES}
	SCAN_DIRS=${FLEA_DIRS}
	SCAN_KSYMS=${FLEA_KSYMS}
	scanrootkit

	# FreeBSD Rootkit

	SCAN_ROOTKIT="FreeBSD Rootkit"
	SCAN_FILES=${FREEBSD_RK_FILES}
	SCAN_DIRS=${FREEBSD_RK_DIRS}
	SCAN_KSYMS=${FREEBSD_RK_KSYMS}
	scanrootkit

	# Fuck`it Rootkit

	SCAN_ROOTKIT="Fuck\`it Rootkit"
	SCAN_FILES=${FUCKIT_FILES}
	SCAN_DIRS=${FUCKIT_DIRS}
	SCAN_KSYMS=${FUCKIT_KSYMS}
	scanrootkit

	# GasKit Rootkit

	SCAN_ROOTKIT="GasKit Rootkit"
	SCAN_FILES=${GASKIT_FILES}
	SCAN_DIRS=${GASKIT_DIRS}
	SCAN_KSYMS=${GASKIT_KSYMS}
	scanrootkit

	# Heroin LKM

	SCAN_ROOTKIT="Heroin LKM"
	SCAN_FILES=${HEROIN_FILES}
	SCAN_DIRS=${HEROIN_DIRS}
	SCAN_KSYMS=${HEROIN_KSYMS}
	scanrootkit

	# HjC Kit

	SCAN_ROOTKIT="HjC Kit"
	SCAN_FILES=${HJCKIT_FILES}
	SCAN_DIRS=${HJCKIT_DIRS}
	SCAN_KSYMS=${HJCKIT_KSYMS}
	scanrootkit

	# ignoKit Rootkit

	SCAN_ROOTKIT="ignoKit Rootkit"
	SCAN_FILES=${IGNOKIT_FILES}
	SCAN_DIRS=${IGNOKIT_DIRS}
	SCAN_KSYMS=${IGNOKIT_KSYMS}
	scanrootkit

	# ImperalsS-FBRK Rootkit

	SCAN_ROOTKIT="ImperalsS-FBRK Rootkit"
	SCAN_FILES=${IMPFRB_FILES}
	SCAN_DIRS=${IMPFRB_DIRS}
	SCAN_KSYMS=${IMPFRB_KSYMS}
	scanrootkit

	# Irix Rootkit

	SCAN_ROOTKIT="Irix Rootkit"
	SCAN_FILES=${IRIXRK_FILES}
	SCAN_DIRS=${IRIXRK_DIRS}
	SCAN_KSYMS=${IRIXRK_KSYMS}
	scanrootkit

	# Kitko Rootkit

	SCAN_ROOTKIT="Kitko Rootkit"
	SCAN_FILES=${KITKO_FILES}
	SCAN_DIRS=${KITKO_DIRS}
	SCAN_KSYMS=${KITKO_KSYMS}
	scanrootkit

	# Knark Rootkit

	SCAN_ROOTKIT="Knark Rootkit"
	SCAN_FILES=${KNARK_FILES}
	SCAN_DIRS=${KNARK_DIRS}
	SCAN_KSYMS=${KNARK_KSYMS}
	scanrootkit

	# Li0n Worm

	SCAN_ROOTKIT="Li0n Worm"
	SCAN_FILES=${LION_FILES}
	SCAN_DIRS=${LION_DIRS}
	SCAN_KSYMS=${LION_KSYMS}
	scanrootkit

	# Lockit / LJK2 Rootkit

	SCAN_ROOTKIT="Lockit / LJK2 Rootkit"
	SCAN_FILES=${LOCKIT_FILES}
	SCAN_DIRS=${LOCKIT_DIRS}
	SCAN_KSYMS=${LOCKIT_KSYMS}
	scanrootkit

	# Mood-NT Rootkit

	SCAN_ROOTKIT="Mood-NT Rootkit"
	SCAN_FILES=${MOODNT_FILES}
	SCAN_DIRS=${MOODNT_DIRS}
	SCAN_KSYMS=${MOODNT_KSYMS}
	scanrootkit

	# MRK (MiCrobul?) RootKit

	SCAN_ROOTKIT="MRK Rootkit"
	SCAN_FILES=${MRK_FILES}
	SCAN_DIRS=${MRK_DIRS}
	SCAN_KSYMS=${MRK_KSYMS}
	scanrootkit

	# Ni0 Rootkit

	SCAN_ROOTKIT="Ni0 Rootkit"
	SCAN_FILES=${NIO_FILES}
	SCAN_DIRS=${NIO_DIRS}
	SCAN_KSYMS=${NIO_KSYMS}
	scanrootkit

	# Ohhara Rootkit

	SCAN_ROOTKIT="Ohhara Rootkit"
	SCAN_FILES=${OHHARA_FILES}
	SCAN_DIRS=${OHHARA_DIRS}
	SCAN_KSYMS=${OHHARA_KSYMS}
	scanrootkit

	# Optic Kit Worm

	SCAN_ROOTKIT="Optic Kit (Tux) Worm"
	SCAN_FILES=${OPTICKIT_FILES}
	SCAN_DIRS=${OPTICKIT_DIRS}
	SCAN_KSYMS=${OPTICKIT_KSYMS}
	scanrootkit

	# Oz Rootkit

	SCAN_ROOTKIT="Oz Rootkit"
	SCAN_FILES=${OZ_FILES}
	SCAN_DIRS=${OZ_DIRS}
	SCAN_KSYMS=${OZ_KSYMS}
	scanrootkit

	# Phalanx Rootkit

	SCAN_ROOTKIT="Phalanx Rootkit"
	SCAN_FILES=${PHALANX_FILES}
	SCAN_DIRS="${PHALANX_DIRS}"
	SCAN_KSYMS="${PHALANX_KSYMS}"
	scanrootkit

	# Phalanx Rootkit (strings)

	if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
		SCAN_ROOTKIT="Phalanx Rootkit (strings)"

		ROOTKIT_COUNT=`expr ${ROOTKIT_COUNT} + 1`

		if [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --nl ROOTKIT_FILES_DIRS_NAME_LOG "${SCAN_ROOTKIT}"
		fi

		if [ -f "${ROOTDIR}/bin/hostname" ]; then
			if `grep -q 'phalanx' ${ROOTDIR}/bin/hostname >/dev/null 2>&1`; then
				ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
				ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}${SCAN_ROOTKIT}, "

				if [ $VERBOSE_LOGGING -eq 1 ]; then
					display --to LOG --type PLAIN --result FOUND --log-indent 2 ROOTKIT_FILES_DIRS_STR "phalanx"
				fi

				display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 ROOTKIT_FILES_DIRS_NAME "${SCAN_ROOTKIT}"
				display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_STR_FOUND "phalanx" "${ROOTDIR}/bin/hostname"
			else
				if [ $VERBOSE_LOGGING -eq 1 ]; then
					display --to LOG --type PLAIN --result NOT_FOUND --log-indent 2 ROOTKIT_FILES_DIRS_STR "phalanx"
				fi

				display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 ROOTKIT_FILES_DIRS_NAME "${SCAN_ROOTKIT}"
			fi
		else
			display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 ROOTKIT_FILES_DIRS_NAME "${SCAN_ROOTKIT}"
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_NOFILE "${ROOTDIR}/bin/hostname"
		fi
	fi

	# Portacelo Rootkit

	SCAN_ROOTKIT="Portacelo Rootkit"
	SCAN_FILES=${PORTACELO_FILES}
	SCAN_DIRS=${PORTACELO_DIRS}
	SCAN_KSYMS=${PORTACELO_KSYMS}
	scanrootkit

	# R3dstorm Toolkit

	SCAN_ROOTKIT="R3dstorm Toolkit"
	SCAN_FILES=${REDSTORM_FILES}
	SCAN_DIRS=${REDSTORM_DIRS}
	SCAN_KSYMS=${REDSTORM_KSYMS}
	scanrootkit

	# RH-Sharpe's Rootkit

	SCAN_ROOTKIT="RH-Sharpe's Rootkit"
	SCAN_FILES=${RHSHARPES_FILES}
	SCAN_DIRS=${RHSHARPES_DIRS}
	SCAN_KSYMS=${RHSHARPES_KSYMS}
	scanrootkit

	# RSHA's Rootkit

	SCAN_ROOTKIT="RSHA's Rootkit"
	SCAN_FILES=${RSHA_FILES}
	SCAN_DIRS=${RSHA_DIRS}
	SCAN_KSYMS=${RSHA_KSYMS}
	scanrootkit

	# Scalper Worm

	SCAN_ROOTKIT="Scalper Worm"
	SCAN_FILES=${SCALPER_FILES}
	SCAN_DIRS=${SCALPER_DIRS}
	SCAN_KSYMS=${SCALPER_KSYMS}
	scanrootkit

	# Sebek LKM (Honeypot)

	SCAN_ROOTKIT="Sebek LKM"

	ROOTKIT_COUNT=`expr ${ROOTKIT_COUNT} + 1`

	if [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --nl ROOTKIT_FILES_DIRS_NAME_LOG "${SCAN_ROOTKIT}"
	fi

	FOUND=0

	if [ -n "${KSYMS_FILE}" ]; then
		if `egrep -i 'adore|sebek' ${KSYMS_FILE} >/dev/null 2>&1`; then
			FOUND=1
		fi
	fi

	if [ $FOUND -eq 0 ]; then
		if [ $VERBOSE_LOGGING -eq 1 ]; then
			if [ -n "${KSYMS_FILE}" ]; then
				display --to LOG --type PLAIN --result NOT_FOUND --log-indent 2 ROOTKIT_FILES_DIRS_KSYM "adore or sebek"
			else
				display --to LOG --type PLAIN --result SKIPPED --log-indent 2 ROOTKIT_FILES_DIRS_KSYM "adore or sebek"
			fi
		fi

		display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 ROOTKIT_FILES_DIRS_NAME "${SCAN_ROOTKIT}"
	else
		ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
		ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}${SCAN_ROOTKIT}, "

		if [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --result FOUND --log-indent 2 ROOTKIT_FILES_DIRS_KSYM "adore or sebek"
		fi

		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 ROOTKIT_FILES_DIRS_NAME "${SCAN_ROOTKIT}"
		display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_KSYM_FOUND "adore or sebek"
	fi

	# Shutdown Rootkit

	SCAN_ROOTKIT="Shutdown Rootkit"
	SCAN_FILES=${SHUTDOWN_FILES}
	SCAN_DIRS=${SHUTDOWN_DIRS}
	SCAN_KSYMS=${SHUTDOWN_KSYMS}
	scanrootkit

	# SHV4 Rootkit

	SCAN_ROOTKIT="SHV4 Rootkit"
	SCAN_FILES=${SHV4_FILES}
	SCAN_DIRS=${SHV4_DIRS}
	SCAN_KSYMS=${SHV4_KSYMS}
	scanrootkit

	# SHV5 Rootkit

	SCAN_ROOTKIT="SHV5 Rootkit"
	SCAN_FILES=${SHV5_FILES}
	SCAN_DIRS=${SHV5_DIRS}
	SCAN_KSYMS=${SHV5_KSYMS}
	scanrootkit

	# Sin Rootkit

	SCAN_ROOTKIT="Sin Rootkit"
	SCAN_FILES=${SINROOTKIT_FILES}
	SCAN_DIRS=${SINROOTKIT_DIRS}
	SCAN_KSYMS=${SINROOTKIT_KSYMS}
	scanrootkit

	# SInAR Rootkit

	if [ "${OPERATING_SYSTEM}" = "SunOS" ]; then
		FOUND=0
		SINARFILES=""

		SCAN_ROOTKIT="SInAR Rootkit"

		ROOTKIT_COUNT=`expr ${ROOTKIT_COUNT} + 1`

		if [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --nl ROOTKIT_FILES_DIRS_NAME_LOG "${SCAN_ROOTKIT}"
		fi

		if [ -n "${FIND_CMD}" ]; then
			for DIR in ${BINPATHS}; do
				FOUNDINDIR="NOT_FOUND"

				for FNAME in `${FIND_CMD} "${DIR}" -type f -name "*[sS][iI][nN][aA][rR]*" 2>/dev/null`; do
					if `grep -i 'sinar' ${FNAME} >/dev/null 2>&1`; then
						FOUND=1
						FOUNDINDIR="FOUND"
						SINARFILES="${SINARFILES} ${FNAME}"
					fi
				done

				if [ $VERBOSE_LOGGING -eq 1 ]; then
					display --to LOG --type PLAIN --result "${FOUNDINDIR}" --log-indent 2 ROOTKIT_FILES_DIRS_SINAR_DIR "${DIR}"
				fi
			done


			#
			# Now display the result.
			#

			if [ $FOUND -eq 0 ]; then
				display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 ROOTKIT_FILES_DIRS_NAME "${SCAN_ROOTKIT}"
			else
				ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
				ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}${SCAN_ROOTKIT}, "

				display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 ROOTKIT_FILES_DIRS_NAME "${SCAN_ROOTKIT}"
				display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_SINAR "${SINARFILES}"
			fi
		else
			display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --screen-indent 4 ROOTKIT_FILES_DIRS_NAME "${SCAN_ROOTKIT}"
			display --to LOG --type INFO NOT_FOUND_CMD "find"
		fi
	fi

	# Slapper Worm

	SCAN_ROOTKIT="Slapper Worm"
	SCAN_FILES=${SLAPPER_FILES}
	SCAN_DIRS=${SLAPPER_DIRS}
	SCAN_KSYMS=${SLAPPER_KSYMS}
	scanrootkit

	# Sneakin Rootkit

	SCAN_ROOTKIT="Sneakin Rootkit"
	SCAN_FILES=${SNEAKIN_FILES}
	SCAN_DIRS=${SNEAKIN_DIRS}
	SCAN_KSYMS=${SNEAKIN_KSYMS}
	scanrootkit

	# Suckit Rootkit

	SCAN_ROOTKIT="Suckit Rootkit"
	SCAN_FILES=${SUCKIT_FILES}
	SCAN_DIRS=${SUCKIT_DIRS}
	SCAN_KSYMS=${SUCKIT_KSYMS}
	scanrootkit

	# SunOS Rootkit

	SCAN_ROOTKIT="SunOS Rootkit"
	SCAN_FILES=${SUNOSROOTKIT_FILES}
	SCAN_DIRS=${SUNOSROOTKIT_DIRS}
	SCAN_KSYMS=${SUNOSROOTKIT_KSYMS}
	scanrootkit

	# SunOS / NSDAP Rootkit

	SCAN_ROOTKIT="SunOS / NSDAP Rootkit"
	SCAN_FILES=${NSDAP_FILES}
	SCAN_DIRS=${NSDAP_DIRS}
	SCAN_KSYMS=${NSDAP_KSYMS}
	scanrootkit

	# Superkit Rootkit

	SCAN_ROOTKIT="Superkit Rootkit"
	SCAN_FILES=${SUPERKIT_FILES}
	SCAN_DIRS=${SUPERKIT_DIRS}
	SCAN_KSYMS=${SUPERKIT_KSYMS}
	scanrootkit

	# TBD (Telnet BackDoor)

	SCAN_ROOTKIT="TBD (Telnet BackDoor)"
	SCAN_FILES=${TBD_FILES}
	SCAN_DIRS=${TBD_DIRS}
	SCAN_KSYMS=${TBD_KSYMS}
	scanrootkit

	# TeLeKiT Rootkit

	SCAN_ROOTKIT="TeLeKiT Rootkit"
	SCAN_FILES=${TELEKIT_FILES}
	SCAN_DIRS=${TELEKIT_DIRS}
	SCAN_KSYMS=${TELEKIT_KSYMS}
	scanrootkit


	# T0rn Rootkit

	SCAN_ROOTKIT="T0rn Rootkit"
	SCAN_FILES=${TORN_FILES}
	SCAN_DIRS=${TORN_DIRS}
	SCAN_KSYMS=${TORN_KSYMS}
	scanrootkit

	# Trojanit Kit

	SCAN_ROOTKIT="Trojanit Kit"
	SCAN_FILES=${TROJANIT_FILES}
	SCAN_DIRS=${TROJANIT_DIRS}
	SCAN_KSYMS=${TROJANIT_KSYMS}
	scanrootkit

	# Tuxtendo Rootkit

	SCAN_ROOTKIT="Tuxtendo Rootkit"
	SCAN_FILES=${TUXTENDO_FILES}
	SCAN_DIRS=${TUXTENDO_DIRS}
	SCAN_KSYMS=${TUXTENDO_KSYMS}
	scanrootkit

	# URK - Universal RootKit

	SCAN_ROOTKIT="URK Rootkit"
	SCAN_FILES=${URK_FILES}
	SCAN_DIRS=${URK_DIRS}
	SCAN_KSYMS=${URK_KSYMS}
	scanrootkit

	# VcKit Rootkit

	SCAN_ROOTKIT="VcKit Rootkit"
	SCAN_FILES=${VCKIT_FILES}
	SCAN_DIRS=${VCKIT_DIRS}
	SCAN_KSYMS=${VCKIT_KSYMS}
	scanrootkit

	# Volc Rootkit

	SCAN_ROOTKIT="Volc Rootkit"
	SCAN_FILES=${VOLC_FILES}
	SCAN_DIRS=${VOLC_DIRS}
	SCAN_KSYMS=${VOLC_KSYMS}
	scanrootkit

	# X-Org SunOS Rootkit

	SCAN_ROOTKIT="X-Org SunOS Rootkit"
	SCAN_FILES=${XORGSUNOS_FILES}
	SCAN_DIRS=${XORGSUNOS_DIRS}
	SCAN_KSYMS=${XORGSUNOS_KSYMS}
	scanrootkit

	# zaRwT.KiT Rootkit

	SCAN_ROOTKIT="zaRwT.KiT Rootkit"
	SCAN_FILES=${ZARWT_FILES}
	SCAN_DIRS=${ZARWT_DIRS}
	SCAN_KSYMS=${ZARWT_KSYMS}
	scanrootkit

	return
}


possible_rootkit_file_dir_checks() {

	#
	# This function performs the check for possible rootkit
	# files and directories.
	#

	if ! `check_test possible_rkt_files`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST possible_rkt_files
		return
	fi


	if [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --nl --log-indent 2 ROOTKIT_POSS_FILES_DIRS_LOG
	fi

	FOUND=0
	FOUNDFILES=""
	FOUNDDIRS=""

	IFS="
"

	for RKHTMPVAR in ${FILESCAN}; do
		ROOTKIT_COUNT=`expr ${ROOTKIT_COUNT} + 1`

		RKHTMPVAR=`echo "${RKHTMPVAR}" | sed -e 's/^[ 	]*//'`
		TYPE=`echo "${RKHTMPVAR}" | cut -d: -f1`
		FILE=`echo "${RKHTMPVAR}" | cut -d: -f2`
		INFO=`echo "${RKHTMPVAR}" | cut -d: -f3`

		case "${TYPE}" in
		dir)
			if [ -d "${FILE}" ]; then
				FOUND=1
				FOUNDDIRS="${FOUNDDIRS}%${FILE}:${INFO}"

				if [ $VERBOSE_LOGGING -eq 1 ]; then
					display --to LOG --type PLAIN --result WARNING --log-indent 4 ROOTKIT_FILES_DIRS_DIR "${FILE}"
				fi
			elif [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result NOT_FOUND --log-indent 4 ROOTKIT_FILES_DIRS_DIR "${FILE}"
			fi
			;;
		file)
			if [ -f "${FILE}" ]; then
				FOUND=1
				FOUNDFILES="${FOUNDFILES}%${FILE}:${INFO}"

				if [ $VERBOSE_LOGGING -eq 1 ]; then
					display --to LOG --type PLAIN --result WARNING --log-indent 4 ROOTKIT_FILES_DIRS_FILE "${FILE}"
				fi
			elif [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result NOT_FOUND --log-indent 4 ROOTKIT_FILES_DIRS_FILE "${FILE}"
			fi
			;;
		*)
			echo "Error: Unknown file type in possible rootkit check: FILESCAN contains: ${TYPE}"
			;;
		esac
	done

	IFS=$ORIGIFS


	#
	# Now display the results.
	#

	if [ $FOUND -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 --log-indent 2 ROOTKIT_POSS_FILES_DIRS
	else
		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 --log-indent 2 ROOTKIT_POSS_FILES_DIRS

		IFS="%"

		for RKHTMPVAR in ${FOUNDFILES}; do
			FILE=`echo "${RKHTMPVAR}" | cut -d: -f1`
			INFO=`echo "${RKHTMPVAR}" | cut -d: -f2`

			test -z "${FILE}" && continue

			ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
			ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}${INFO}, "

			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_POSS_FILES_FILE_FOUND "${FILE}" "${INFO}"
		done

		for RKHTMPVAR in ${FOUNDDIRS}; do
			FILE=`echo "${RKHTMPVAR}" | cut -d: -f1`
			INFO=`echo "${RKHTMPVAR}" | cut -d: -f2`

			test -z "${FILE}" && continue

			ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
			ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}${INFO}, "

			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_POSS_FILES_DIR_FOUND "${FILE}" "${INFO}"
		done

		IFS=$ORIGIFS
	fi

	return
}


possible_rootkit_string_checks() {

	#
	# This function performs the check for possible rootkit
	# strings in files.
	#

	if ! `check_test possible_rkt_strings`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST possible_rkt_strings
		return
	fi


	if [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --nl --log-indent 2 ROOTKIT_POSS_STRINGS_LOG
	fi

	#
	# First check to see if we have a 'strings' command.
	#

	if [ -z "${STRINGS_CMD}" ]; then
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --screen-indent 4 ROOTKIT_POSS_STRINGS
		display --to LOG --type INFO NOT_FOUND_CMD "strings"
		return
	fi


	#
	# Set and check that the RCFILE is okay.
	#

	if [ "${OPERATING_SYSTEM}" = "AIX" ]; then
		RCFILE="${ROOTDIR}/etc/inittab"
	else
		RCFILE="${ROOTDIR}/etc/rc.d/rc.sysinit"
	fi

	if [ -f "${RCFILE}" ]; then
		display --to LOG --type INFO ROOTKIT_POSS_STRINGS_RCFILE "${RCFILE}"
	else
		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 ROOTKIT_POSS_STRINGS
		display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_NOFILE "${RCFILE}"
		return
	fi


	FOUND=0
	FOUNDFILES=""
	IFS="
"

	for RKHTMPVAR in ${STRINGSCAN}; do
		FOUNDFILE=0
		FOUNDSTRING=""

		RKHTMPVAR=`echo "${RKHTMPVAR}" | sed -e 's/^[ 	]*//'`
		FILE=`echo "${RKHTMPVAR}" | cut -d: -f1`
		FILESTRING=`echo "${RKHTMPVAR}" | cut -d: -f2`
		STRING=`echo "${FILESTRING}" | sed -e 's/\./\\\./g'`
		INFO=`echo "${RKHTMPVAR}" | cut -d: -f3`

		if [ "${FILE}" = "rcfile" ]; then
			FOUNDFILE=1

			FOUNDSTRING=`${STRINGS_CMD} ${RCFILE} | grep "${STRING}"`

			if [ -n "${FOUNDSTRING}" ]; then
				FOUND=1
				FOUNDSTRINGS="${FOUNDSTRINGS}%${RCFILE}:${FILESTRING}:${INFO}"
			fi
		else
			#
			# We cannot use the 'find_cmd' function here because we
			# are looking at the command binaries themselves, not
			# executing them as commands from the local system.
			#
			# We need to jiggle with IFS here because we are in
			# two loops which are using different field separators.
			#

			IFS=$ORIGIFS

			for DIR in ${BINPATHS}; do
				FILENAME="${ROOTDIR}${DIR}/${FILE}"

				if [ -f "${FILENAME}" ]; then
					FOUNDFILE=1
					FOUNDSTRING=`${STRINGS_CMD} ${FILENAME} | grep "${STRING}"`

					if [ -n "${FOUNDSTRING}" ]; then
						FOUND=1
						FOUNDSTRINGS="${FOUNDSTRINGS}%${FILENAME}:${FILESTRING}:${INFO}"
					fi

					break
				fi
			done
		fi

		if [ $FOUNDFILE -eq 1 ]; then
			ROOTKIT_COUNT=`expr ${ROOTKIT_COUNT} + 1`

			if [ $VERBOSE_LOGGING -eq 1 ]; then
				if [ -z "${FOUNDSTRING}" ]; then
					display --to LOG --type PLAIN --result NOT_FOUND --log-indent 4 ROOTKIT_FILES_DIRS_STR "${FILESTRING}"
				else
					display --to LOG --type PLAIN --result WARNING --log-indent 4 ROOTKIT_FILES_DIRS_STR "${FILESTRING}"
				fi
			fi
		fi

		IFS="
"
	done

	IFS=$ORIGIFS


	#
	# Now display the results.
	#

	if [ $FOUND -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 --log-indent 2 ROOTKIT_POSS_STRINGS
	else
		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 --log-indent 2 ROOTKIT_POSS_STRINGS

		IFS="%"

		for RKHTMPVAR in ${FOUNDSTRINGS}; do
			FILE=`echo "${RKHTMPVAR}" | cut -d: -f1`
			FILESTRING=`echo "${RKHTMPVAR}" | cut -d: -f2`
			INFO=`echo "${RKHTMPVAR}" | cut -d: -f3`

			test -z "${FILE}" && continue

			ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
			ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}${INFO}, "

			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_POSS_STRINGS_FOUND "${FILESTRING}" "${FILE}" "${INFO}"
		done

		IFS=$ORIGIFS
	fi

	return
}


additional_rootkit_checks() {

	#
	# This function performs additional rootkit checks.
	# These include checks for possible rootkits.
	#

	if ! `check_test additional_rkts`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST additional_rkts
		return
	fi


	display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 ROOTKIT_ADD_START

	if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
		suckit_extra_checks
	fi

	possible_rootkit_file_dir_checks

	possible_rootkit_string_checks

	return
}


malware_checks() {

	#
	# This function performs malware checks.
	#

	if ! `check_test malware`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST malware
		return
	fi


	display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 ROOTKIT_MALWARE_START

	#
	# First we check for processes using deleted files.
	#

	if `check_test deleted_files`; then
		if [ -n "${LSOF_CMD}" ]; then
			STATUS=0
			WHITEPROC=""; BLACKPROC=""

			DELE_FILES=`${LSOF_CMD} -n -l -w | grep '(dele' | head -n 1`

			if [ -n "${DELE_FILES}" ]; then
				PIDLIST=" "

				ALLOWPROCDELFILES=`grep '^ALLOWPROCDELFILE=' ${CONFIGFILE} | sed -e 's/ALLOWPROCDELFILE=//g'`


				#
				# If we are running Solaris 10, then see if
				# we have the command pathname available.
				#
				# Solaris 10 and above should have the 'a.out'
				# file present. We use the PID of 1 here since
				# it should exist on all systems.
				#

				SOL_PROC=0

				if [ "${OPERATING_SYSTEM}" = "SunOS" ]; then
					test -n "${READLINK_CMD}" -a -h "/proc/1/path/a.out" && SOL_PROC=1
				fi


				IFS="
"

				for LINE in `${LSOF_CMD} -n -l -w | grep '(dele'`; do
					PROC=`echo "$LINE" | awk '{ print $1 }'`
					PID=`echo "$LINE" | awk '{ print $2 }'`
					NODE=`echo "$LINE" | awk '{ print $8 }'`
					FNAME=`echo "$LINE" | awk '{ print $9 }'`

					#
					# Skip any PID's we have already seen.
					#

					test -n "`echo \"${PIDLIST}\" | grep \" $PID \"`" && continue

					#
					# Try and get the running process name.
					#

					if [ -n "${READLINK_CMD}" ]; then
						RKHTMPVAR=""

						if [ $SOL_PROC -eq 1 ]; then
							RKHTMPVAR=`${READLINK_CMD} /proc/${PID}/path/a.out | awk '{ print $1 }'`
						elif [ "${OPERATING_SYSTEM}" != "SunOS" -o -h /proc/${PID}/exe ]; then
							RKHTMPVAR=`${READLINK_CMD} /proc/${PID}/exe | awk '{ print $1 }'`
						fi

						test -n "${RKHTMPVAR}" && PROC="${RKHTMPVAR}"
					fi

					#
					# If FNAME is not a pathname then look at the NODE.
					#

					if [ -z "`echo \"${FNAME}\" | grep '^/'`" ]; then
						if [ -n "`echo \"${NODE}\" | grep '^/'`" ]; then
							FNAME="${NODE}"
						fi
					fi

					#
					# Strip anything after the pathname.
					#

					if [ -n "`echo \"${FNAME}\" | grep '^/'`" ]; then
						FNAME=`echo "${FNAME}" | cut -d' ' -f1`
					fi

					#
					# Now see if the process is whitelisted.
					#

					PROCWHITELISTED=0

					for RKHTMPVAR in $ALLOWPROCDELFILES; do
						if [ "${PROC}" = "${RKHTMPVAR}" ]; then
							PROCWHITELISTED=1
							break
						fi
					done

					test -z "${READLINK_CMD}" && PROC="\"${PROC}\""

					if [ $PROCWHITELISTED -eq 1 ]; then
						if [ -z "`echo \"${WHITEPROC}\" | egrep \"${PROC}( |$)\"`" ]; then
							WHITEPROC="${WHITEPROC} ${PROC}"
						fi
					else
						STATUS=1
						BLACKPROC="${BLACKPROC}
${PROC} ${PID} ${FNAME}"
					fi


					#
					# Finally add the PID to the seen PID list.
					#

					PIDLIST="$PIDLIST $PID "
				done
			fi


			#
			# Now display the results.
			#

			if [ $STATUS -eq 0 ]; then
				display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_DELETED_FILES
			else
				display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_DELETED_FILES

				display --to LOG --type WARNING ROOTKIT_MALWARE_DELETED_FILES_FOUND

				for LINE in ${BLACKPROC}; do
					PROC=`echo "$LINE" | cut -d' ' -f1`
					PID=`echo "$LINE" | cut -d' ' -f2`
					FNAME=`echo "$LINE" | cut -d' ' -f3`

					test -z "${PROC}" && continue

					display --to LOG --type PLAIN --log-indent 9 ROOTKIT_MALWARE_DELETED_FILES_FOUND_DATA "${PROC}" "${PID}" "${FNAME}"
				done
			fi

			IFS=$ORIGIFS

			for RKHTMPVAR in $WHITEPROC; do
				display --to LOG --type INFO NETWORK_PACKET_CAP_WHITE "${RKHTMPVAR}"
			done
		else
			display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_DELETED_FILES
			display --to LOG --type INFO NOT_FOUND_CMD "lsof"
		fi
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST deleted_files
	fi


	#
	# Next we check to see if there any running processes
	# using suspicious files.
	#

	if `check_test running_procs`; then
		if [ -n "${LSOF_CMD}" ]; then
			SUSP_FILES=""
			IFS="
"

			for RKHTMPVAR in ${SUSP_FILES_INFO}; do
				RKHTMPVAR=`echo "${RKHTMPVAR}" | sed -e 's/^[ 	]*//'`
				FILENAME=`echo "${RKHTMPVAR}" | cut -d: -f1 | sed -e 's/\./\\\./g'`
				SUSP_FILES="${SUSP_FILES}|${FILENAME}"
			done

			IFS=$ORIGIFS

			SUSP_FILES=`echo "${SUSP_FILES}" | sed -e 's/^|//'`

			#
			# If we have the 'sort' and 'uniq' commands available,
			# then the output will be less and avoids listing any
			# duplicate processes.
			#

			if [ -n "${SORT_CMD}" -a -n "${UNIQ_CMD}" ]; then
				FILENAME=`${LSOF_CMD} -F n -w -n | ${SORT_CMD} | ${UNIQ_CMD} | grep '^n/' | sed -e 's/^n//' | egrep "/(${SUSP_FILES})$"`
			else
				FILENAME=`${LSOF_CMD} -F n -w -n | grep '^n/' | sed -e 's/^n//' | "/(${SUSP_FILES})$"`
			fi

			if [ -z "${FILENAME}" ]; then
				display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_SUSP_FILES
			else
				display --to SCREEN+LOG --type WARNING --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_SUSP_FILES

				SUSP_FILES=`echo "${SUSP_FILES}" | sed -e 's/|/, /g'`
				SUSP_FILES=`echo "${SUSP_FILES}" | sed -e 's/\\\././g'`
				display --to LOG --type WARNING --log-indent 2 ROOTKIT_MALWARE_SUSP_FILES_FOUND "${SUSP_FILES}"
			fi
		else
			display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_SUSP_FILES
			display --to LOG --type INFO NOT_FOUND_CMD "lsof"
		fi
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST running_procs
	fi


	#
	# Next we check for any hidden processes.
	#

	if `check_test hidden_procs`; then
		UNHIDE_CMD=`find_cmd unhide`

		if [ -n "${UNHIDE_CMD}" ]; then
			HIDDEN_PROCS=`${UNHIDE_CMD} sys | grep '^F' | awk -F':' '{ print $2 }'`

			if [ -z "${HIDDEN_PROCS}" ]; then
				display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_HIDDEN_PROCS
			else
				display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_HIDDEN_PROCS
				display --to LOG --type WARNING --log-indent 2 ROOTKIT_MALWARE_HIDDEN_PROCS_FOUND "${HIDDEN_PROCS}"
			fi
		else
			display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_HIDDEN_PROCS
			display --to LOG --type INFO NOT_FOUND_CMD "unhide"
		fi
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST hidden_procs
	fi


	#
	# We have completed the checks which can be enabled/disabled,
	# but we need to be able to exclude or include the rest of the
	# malware checks. As such we do a simple test for 'other_malware'
	# as a test name, and only proceed if it is enabled.
	#

	if ! `check_test other_malware`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST other_malware
		return
	fi


	#
	# Next we check for login backdoors.
	#

	FOUND=0
	FOUNDFILES=""

	if [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --nl --log-indent 2 ROOTKIT_MALWARE_LOGIN_BDOOR_LOG
	fi

	IFS="
"

	for FILE in ${LOGIN_BACKDOOR_FILES}; do
		FILE=`echo "${FILE}" | sed -e 's/^[ 	]*//'`

		if [ -e "${FILE}" ]; then
			FOUND=1
			FOUNDFILES="${FOUNDFILES} ${FILE}"

			if [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result FOUND --log-indent 4 ROOTKIT_MALWARE_LOGIN_BDOOR_CHK "${FILE}"
			fi
		elif [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --result NOT_FOUND --log-indent 4 ROOTKIT_MALWARE_LOGIN_BDOOR_CHK "${FILE}"
		fi
	done

	IFS=$ORIGIFS


	#
	# Now display the results.
	#

	if [ $FOUND -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 --log-indent 2 ROOTKIT_MALWARE_LOGIN_BDOOR
	else
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --screen-indent 4 --log-indent 2 ROOTKIT_MALWARE_LOGIN_BDOOR

		for FILE in ${FOUNDFILES}; do
			display --to LOG --type WARNING ROOTKIT_MALWARE_LOGIN_BDOOR_FOUND "${FILE}"
		done
	fi


	#
	# Next check for any suspicious directories.
	#

	FOUND=0
	FOUNDDIRS=""

	if [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --nl --log-indent 2 ROOTKIT_MALWARE_SUSP_DIR_LOG
	fi

	IFS="
"

	for DIR in ${SUSPICIOUS_DIRS}; do
		DIR=`echo "${DIR}" | sed -e 's/^[ 	]*//'`

		if [ -d "${DIR}" ]; then
			FOUND=1
			FOUNDDIRS="${FOUNDDIRS} ${DIR}"

			if [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result FOUND --log-indent 4 ROOTKIT_FILES_DIRS_DIR "${DIR}"
			fi
		elif [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --result NOT_FOUND --log-indent 4 ROOTKIT_FILES_DIRS_DIR "${DIR}"
		fi
	done

	IFS=$ORIGIFS


	#
	# Now display the results.
	#

	if [ $FOUND -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 --log-indent 2 ROOTKIT_MALWARE_SUSP_DIR
	else
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --screen-indent 4 --log-indent 2 ROOTKIT_MALWARE_SUSP_DIR

		for DIR in ${FOUNDDIRS}; do
			display --to LOG --type WARNING ROOTKIT_MALWARE_SUSP_DIR_FOUND "${DIR}"
		done
	fi


	#
	# Next we check for any software intrusions.
	#

	TRIPWIREFILE="${ROOTDIR}/var/lib/tripwire/`uname -n 2>/dev/null`.twd"

	if [ -f "${TRIPWIREFILE}" ]; then
		if [ -z "`grep 'Tripwire segment-faulted !' ${TRIPWIREFILE}`" ]; then
			display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 --log-indent 2 --log-nl ROOTKIT_MALWARE_SFW_INTRUSION
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --screen-indent 4 --log-indent 2 --log-nl ROOTKIT_MALWARE_SFW_INTRUSION
			display --to LOG --type WARNING --log-indent 2 ROOTKIT_MALWARE_SFW_INTRUSION_FOUND "${TRIPWIREFILE}" "Tripwire segment-faulted"
		fi
	else
		display --to LOG --type PLAIN --result SKIPPED --log-indent 2 --log-nl ROOTKIT_MALWARE_SFW_INTRUSION
		display --to LOG --type INFO ROOTKIT_MALWARE_SFW_INTRUSION_SKIP
	fi


	#
	# Next, check for sniffer log files.
	#

	FOUND=0
	FOUNDFILES=""

	if [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --nl --log-indent 2 ROOTKIT_MALWARE_SNIFFER_LOG
	fi

	IFS="
"

	for FNAME in ${SNIFFER_FILES}; do
		FNAME=`echo "${FNAME}" | sed -e 's/^[ 	]*//'`

		if [ -f "${FNAME}" ]; then
			FOUND=1
			FOUNDFILES="${FOUNDFILES} ${FNAME}"

			if [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result FOUND --log-indent 4 ROOTKIT_FILES_DIRS_FILE "${FNAME}"
			fi
		elif [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --result NOT_FOUND --log-indent 4 ROOTKIT_FILES_DIRS_FILE "${FNAME}"
		fi
	done

	IFS=$ORIGIFS


	#
	# Now display the results.
	#

	if [ $FOUND -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 --log-indent 2 ROOTKIT_MALWARE_SNIFFER
	else
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --screen-indent 4 --log-indent 2 ROOTKIT_MALWARE_SNIFFER

		for FNAME in ${FOUNDFILES}; do
			display --to LOG --type WARNING ROOTKIT_MALWARE_SNIFFER_FOUND "${FNAME}"
		done
	fi

	return
}


xinetd_include() {

	#
	# This function handles the xinetd 'include' directive.
	# It is also used to initially process the xinetd.conf
	# file, and to process any files within an 'includedir'
	# directory.
	#
	# Any filename containing a dot or ending in a tilde (~)
	# is ignored. Also absolute pathnames must be used.
	#

	test -z "$1" -o ! -f "${ROOTDIR}$1" && return
	test -z "`echo \"$1\" | grep '^/'`" && return

	test -n "`echo \"$1\" | grep '/[^/]*\.[^/]*$'`" -a "$1" != "${XINETD_CONF_PATH}" && return
	test -n "`echo \"$1\" | grep '~$'`" && return


	#
	# First see if any services have been enabled.
	#

	if [ -n "`grep '^[ 	]*disable[ 	]*=[ 	]*no' ${ROOTDIR}$1`" ]; then
		#
		# See if the file is whitelisted.
		#

		RKHTMPVAR=0

		for FNAME in ${XINETDALLOWEDSVCS}; do
			if [ "${FNAME}" = "$1" ]; then
				RKHTMPVAR=1
				break
			fi
		done

		if [ $RKHTMPVAR -eq 0 ]; then
			FOUND=1
			FOUNDFILES="${FOUNDFILES} ${ROOTDIR}$1"

			if [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result WARNING --log-indent 4 ROOTKIT_TROJAN_XINETD_ENABLED "${ROOTDIR}$1"
			fi
		elif [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --result OK --log-indent 4 ROOTKIT_TROJAN_XINETD_ENABLED "${ROOTDIR}$1"
			display --to LOG --type INFO ROOTKIT_TROJAN_XINETD_WHITELIST "$1" "xinetd"
		fi
	elif [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --result OK --log-indent 4 ROOTKIT_TROJAN_XINETD_ENABLED "${ROOTDIR}$1"
	fi


	#
	# Next we look for any 'include' directives.
	#

	for FNAME in `grep '^[ 	]*include[ 	]' ${ROOTDIR}$1 | awk '{ print $2 }'`; do
		if [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --log-indent 6 ROOTKIT_TROJAN_XINETD_INCLUDE "${FNAME}"
		fi

		xinetd_include "${FNAME}"
	done


	#
	# Finally we look for any 'includedir' directives.
	#

	for DIR in `grep '^[ 	]*includedir[ 	]' ${ROOTDIR}$1 | awk '{ print $2 }'`; do
		if [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --log-indent 6 ROOTKIT_TROJAN_XINETD_INCLUDEDIR "${DIR}"
		fi

		xinetd_includedir "${DIR}"
	done

	return
}


xinetd_includedir() {

	#
	# This function handles the xinetd 'includedir' directive.
	#
	# Absolute pathnames must be used.
	#

	test -z "$1" -o ! -d "${ROOTDIR}$1" && return
	test -z "`echo \"$1\" | grep '^/'`" && return


	for FNAME in `ls ${ROOTDIR}$1`; do
		xinetd_include "$1/${FNAME}"
	done

	return
}


sol10_inetd() {

	#
	# This function handles the Solaris 10, and later, inetd
	# configuration. Because the original inetd.conf file may
	# well exist, we look in there as well for any enabled services.
	#
	# This function sets the FOUNDSTRING variable, which will
	# be used later.
	#

	FOUNDSTRING=`${INETADM_CMD} | grep '^enabled' | cut -d: -f2`

	if [ -f "${ROOTDIR}${INETD_CONF_PATH}" ]; then
		STR=`grep -v '^#' ${ROOTDIR}${INETD_CONF_PATH} | awk '{ print $1 }'`
		if [ -n "${FOUNDSTRING}" -o -n "${STR}" ]; then
			FOUNDSTRING="${FOUNDSTRING} ${STR}"
		fi
	fi

	return
}


trojan_checks() {

	#
	# This function performs some trojan specific checks.
	#

	if ! `check_test trojan`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST trojan
		return
	fi


	#
	# We first need to see if we are running Solaris 10 or later.
	# Earlier versions of Solaris used the standard inetd configuration
	# file, but later versions use a different mechanism. The 'inetadm'
	# command can be used on these later Solaris versions.
	#

	if [ "${OPERATING_SYSTEM}" = "SunOS" ]; then
		INETADM_CMD=`find_cmd inetadm`

		test -n "${INETADM_CMD}" && sol10_inetd
	else
		INETADM_CMD=""
	fi


	if [ -f "${ROOTDIR}${INETD_CONF_PATH}" -o -f "${ROOTDIR}${XINETD_CONF_PATH}" -o -n "${INETADM_CMD}" ]; then
		RKHTMPVAR="SCREEN+LOG"
	else
		RKHTMPVAR="LOG"
	fi

	display --to "${RKHTMPVAR}" --type PLAIN --nl --screen-indent 2 ROOTKIT_TROJAN_START


	#
	# We first check the inetd.conf file. This includes the
	# Solaris 10 inetd services as well.
	#

	if [ -f "${ROOTDIR}${INETD_CONF_PATH}" -o -n "${INETADM_CMD}" ]; then
		if [ -z "${INETADM_CMD}" ]; then
			display --to LOG --type INFO CONFIG_XINETD_PATH "inetd" "${INETD_CONF_PATH}"

			FOUNDSTRING=`grep -v '^#' ${ROOTDIR}${INETD_CONF_PATH} | awk '{ print $1 }'`
		else
			display --to LOG --type INFO CONFIG_SOL10_INETD
		fi

		#
		# We now need to see if any of the services are whitelisted.
		#

		RKHTMPVAR=""

		for STR in ${FOUNDSTRING}; do
			FOUND=0

			for SVC in ${INETDALLOWEDSVCS}; do
				if [ "${STR}" = "${SVC}" ]; then
					FOUND=1
					display --to LOG --type INFO ROOTKIT_TROJAN_XINETD_WHITELIST "${SVC}" "inetd"
					break
				fi
			done

			if [ $FOUND -eq 0 ]; then
				#
				# We want to change any RPC services into
				# an actual executable name, if we can. The
				# executable is the sixth field. If the
				# sixth field is empty or this is an internal
				# service, then we just use the service name.
				#

				if [ -n "`echo \"${STR}\" | grep '^[0-9/]*$'`" ]; then
					EXECNAME=`grep "^${STR}" ${ROOTDIR}${INETD_CONF_PATH} | awk '{ print $6 }'`

					if [ -z "${EXECNAME}" -o "${EXECNAME}" = "internal" ]; then
						EXECNAME="${STR}"
					fi

					STR="${EXECNAME}"
				fi

				RKHTMPVAR="${RKHTMPVAR} ${STR}"
			fi
		done

		FOUNDSTRING="${RKHTMPVAR}"


		#
		# Now display the results.
		#

		if [ -z "${FOUNDSTRING}" ]; then
			display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --screen-indent 4 --log-indent 2 ROOTKIT_TROJAN_INETD
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --screen-indent 4 --log-indent 2 ROOTKIT_TROJAN_INETD

			for STR in ${FOUNDSTRING}; do
				display --to LOG --type WARNING ROOTKIT_TROJAN_INETD_FOUND "${STR}"
			done
		fi
	else
		display --to LOG --type PLAIN --result SKIPPED --log-indent 2 ROOTKIT_TROJAN_INETD
		display --to LOG --type INFO ROOTKIT_TROJAN_INETD_SKIP "${ROOTDIR}${INETD_CONF_PATH}"
	fi


	#
	# Next we check the xinetd.conf file.
	#

	FOUND=0
	FOUNDFILES=""

	if [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --nl --log-indent 2 ROOTKIT_TROJAN_XINETD_LOG
	fi

	if [ -f "${ROOTDIR}${XINETD_CONF_PATH}" ]; then
		display --to LOG --type INFO CONFIG_XINETD_PATH "xinetd" "${XINETD_CONF_PATH}"

		xinetd_include "${XINETD_CONF_PATH}"


		#
		# Now display the results.
		#

		if [ $FOUND -eq 0 ]; then
			display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_TROJAN_XINETD
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_TROJAN_XINETD

			for FNAME in ${FOUNDFILES}; do
				display --to LOG --type WARNING ROOTKIT_TROJAN_XINETD_ENABLED_FOUND "${FNAME}"
			done
		fi
	else
		display --to LOG --type PLAIN --result SKIPPED --log-indent 2 ROOTKIT_TROJAN_XINETD
		display --to LOG --type INFO ROOTKIT_TROJAN_INETD_SKIP "${ROOTDIR}${XINETD_CONF_PATH}"
	fi

	return
}


bsd_specific_checks() {

	#
	# This function performs tests specific to the BSD O/S.
	#


	SOCKSTAT_CMD=`find_cmd sockstat`

	if [ -n "${SOCKSTAT_CMD}" -a -n "${NETSTAT_CMD}" -a -n "${SORT_CMD}" -a -n "${UNIQ_CMD}" ]; then
		SOCKSTAT_OUTPUT=`${SOCKSTAT_CMD} -n | grep '\*[:.]\*' | cut -c1-55 | grep '\*[:.]' | cut -c39-47 | grep -v '\*' | tr -d ' ' | ${SORT_CMD} | ${UNIQ_CMD}`
		NETSTAT_OUTPUT=`${NETSTAT_CMD} -an | egrep -v 'TIME_WAIT|ESTABLISHED|SYN_SENT|CLOSE_WAIT|LAST_ACK|SYN_RECV|CLOSING' | cut -c1-44 | grep '\*\.' | cut -c24-32 | grep -v '\*' | tr -d ' ' | tr -d '\t' | ${SORT_CMD} | ${UNIQ_CMD}`

		if [ "${SOCKSTAT_OUTPUT}" = "${NETSTAT_OUTPUT}" ]; then
			display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_OS_BSD_SOCKNET
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_OS_BSD_SOCKNET

			display --to LOG --type WARNING ROOTKIT_OS_BSD_SOCKNET_FOUND
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_OS_BSD_SOCKNET_OUTPUT "Sockstat" "${SOCKSTAT_OUTPUT}"
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_OS_BSD_SOCKNET_OUTPUT "Netstat" "${NETSTAT_OUTPUT}"
		fi
	else
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ROOTKIT_OS_BSD_SOCKNET

		test -z "${SOCKSTAT_CMD}" && display --to LOG --type INFO NOT_FOUND_CMD "sockstat"
		test -z "${NETSTAT_CMD}" && display --to LOG --type INFO NOT_FOUND_CMD "netstat"
		test -z "${SORT_CMD}" && display --to LOG --type INFO NOT_FOUND_CMD "sort"
		test -z "${UNIQ_CMD}" && display --to LOG --type INFO NOT_FOUND_CMD "uniq"
	fi

	return
}


freebsd_specific_checks() {

	#
	# This function performs tests specific to the FreeBSD O/S.
	#


	#
	# First we check for KLD backdoors.
	#

	KLDSTAT_CMD=`find_cmd kldstat`

	if [ -n "${KLDSTAT_CMD}" ]; then
		FOUND=0
		FOUNDKEYS=""

		for RKHTMPVAR in ${KLDSTATKEYWORDS}; do
			RKHTMPVAR=`echo "${RKHTMPVAR}" | sed -e 's/^[ 	]*//'`
			KLDKEYWD=`echo "${RKHTMPVAR}" | sed -e 's/\./\\\./g'`

			if [ -n "`${KLDSTAT_CMD} -v | grep \"${KLDKEYWD}\"`" ]; then
				FOUND=1
				FOUNDKEYS="${FOUNDKEYS} ${RKHTMPVAR} "
			fi
		done


		if [ $FOUND -eq 0 ]; then
			display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_OS_FREEBSD_KLD
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_OS_FREEBSD_KLD

			for RKHTMPVAR in ${FOUNDKEYS}; do
				display --to LOG --type WARNING ROOTKIT_OS_FREEBSD_KLD_FOUND "${RKHTMPVAR}"
			done
		fi
	else
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ROOTKIT_OS_FREEBSD_KLD

		display --to LOG --type INFO NOT_FOUND_CMD "kldstat"
	fi


	#
	# Next we check that the package database is okay.
	#

	PKGDB_CMD=`find_cmd pkgdb`

	if [ -n "${PKGDB_CMD}" ]; then
		RKHTMPVAR=`${PKGDB_CMD} -Fa -v | grep 'Skipped\.'`

		if [ -z "${RKHTMPVAR}" ]; then
			display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_OS_FREEBSD_PKGDB
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_OS_FREEBSD_PKGDB

			display --to LOG --type WARNING ROOTKIT_OS_FREEBSD_PKGDB_NOTOK
		fi
	else
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ROOTKIT_OS_FREEBSD_PKGDB

		display --to LOG --type INFO NOT_FOUND_CMD "pkgdb"
	fi

	return
}


linux_specific_checks() {

	#
	# This function performs tests specific to the Linux O/S.
	#


	#
	# First we check the currently loaded kernel modules.
	#

	if [ -f "${ROOTDIR}/proc/modules" -a -n "${LSMOD_CMD}" -a -n "${SORT_CMD}" ]; then
		PROC_OUTPUT=`cat ${ROOTDIR}/proc/modules | cut -d' ' -f1 | ${SORT_CMD}`
		LSMOD_OUTPUT=`${LSMOD_CMD} | grep -v 'Size *Used *by' | cut -d' ' -f1 | ${SORT_CMD}`


		if [ -n "${PROC_OUTPUT}" -a -n "${LSMOD_OUTPUT}" ]; then
			if [ "${PROC_OUTPUT}" = "${LSMOD_OUTPUT}" ]; then
				display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKM
			else
				display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKM

				display --to LOG --type WARNING ROOTKIT_OS_LINUX_LKM_FOUND
				display --to LOG --type PLAIN --log-indent 9 ROOTKIT_OS_LINUX_LKM_OUTPUT "/proc/modules" "${PROC_OUTPUT}"
				display --to LOG --type PLAIN --log-indent 9 ROOTKIT_OS_LINUX_LKM_OUTPUT "lsmod" "${LSMOD_OUTPUT}"
			fi
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKM

			display --to LOG --type WARNING ROOTKIT_OS_LINUX_LKM_EMPTY
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_OS_LINUX_LKM_OUTPUT "/proc/modules" "${PROC_OUTPUT}"
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_OS_LINUX_LKM_OUTPUT "lsmod" "${LSMOD_OUTPUT}"
		fi
	elif [ ! -f "${ROOTDIR}/proc/modules" ]; then
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKM

		display --to LOG --type WARNING ROOTKIT_OS_LINUX_LKM_MOD_MISSING "${ROOTDIR}/proc/modules"
	else
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKM

		test -z "${LSMOD_CMD}" && display --to LOG --type INFO NOT_FOUND_CMD "lsmod"
		test -z "${SORT_CMD}" && display --to LOG --type INFO NOT_FOUND_CMD "sort"
	fi


	#
	# Next we check for any known bad modules.
	#

	FOUND=0
	FOUNDFILES=""
	LKM_NAMES=""


	#
	# First obtain and log where the modules are kept. Generally
	# rkhunter will determine the location based on the kernel
	# version. However, in the case of remote diagnostics the
	# diagnosing and diagnosed kernel versions may be different.
	# In this case we simply look in '/lib/modules'.
	#

	if [ -z "${ROOTDIR}" ]; then
		LKMPATH="${ROOTDIR}/lib/modules/`uname -r 2>/dev/null`"
	else
		LKMPATH="${ROOTDIR}/lib/modules"
	fi

	display --to LOG --type INFO ROOTKIT_OS_LINUX_LKMNAMES_PATH "${LKMPATH}"


	#
	# Next, we reformat the LKM names at this point since
	# we only need to do it once.
	#

	for RKHTMPVAR in ${LKM_BADNAMES}; do
		RKHTMPVAR=`echo "${RKHTMPVAR}" | sed -e 's/^[ 	]*//' | sed -e 's/\./\\\./g'`
		LKM_NAMES="${LKM_NAMES} ${RKHTMPVAR}"
	done


	#
	# Now do the test.
	#

	if [ -d "${LKMPATH}" -a -n "${FIND_CMD}" ]; then
		for FNAME in `${FIND_CMD} ${LKMPATH} -type f -name "*.o"`; do
			for RKHTMPVAR in ${LKM_NAMES}; do
				if [ -n "`echo ${FNAME} | grep \"/${RKHTMPVAR}\$\"`" ]; then
					FOUND=1
					FOUNDFILES="${FOUNDFILES} ${RKHTMPVAR}"
				fi
			done
		done


		if [ $FOUND -eq 0 ]; then
			display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKMNAMES
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKMNAMES

			for RKHTMPVAR in ${FOUNDFILES}; do
				RKHTMPVAR=`echo "${RKHTMPVAR}" | sed -e 's/\\\././g'`

				display --to LOG --type WARNING ROOTKIT_OS_LINUX_LKMNAMES_FOUND "${LKMPATH}" "${RKHTMPVAR}"
			done
		fi
	elif [ ! -d "${LKMPATH}" ]; then
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKMNAMES

		display --to LOG --type WARNING ROOTKIT_OS_LINUX_LKMNAMES_PATH_MISSING "${LKMPATH}"
	else
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKMNAMES

		display --to LOG --type INFO NOT_FOUND_CMD "find"
	fi

	return
}


os_specific_checks() {

	#
	# This function performs any O/S specific tests.
	#

	if ! `check_test os_specific`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST os_specific
		return
	fi


	#
	# Run the relevant O/S specific tests.
	#

	case "${OPERATING_SYSTEM}" in
	*BSD)
		display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 ROOTKIT_OS_START "${OPERATING_SYSTEM}"

		bsd_specific_checks

		test "${OPERATING_SYSTEM}" = "FreeBSD" && freebsd_specific_checks
		;;
	Linux)
		display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 ROOTKIT_OS_START "${OPERATING_SYSTEM}"

		linux_specific_checks
		;;
	*)
		display --to LOG --type PLAIN --nl ROOTKIT_OS_START "${OPERATING_SYSTEM}"

		display --to LOG --type INFO ROOTKIT_OS_SKIPPED
		;;
	esac

	return
}


do_rootkit_checks() {

	#
	# This function carries out a sequence of tests for rootkits.
	# This consists of the default files and directories check,
	# possible rootkit checks, and checks for malware.
	#

	if ! `check_test rootkits`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST rootkits
		return
	fi


	display --to SCREEN+LOG --type PLAIN --color YELLOW --nl CHECK_ROOTKITS


	rootkit_file_dir_checks

	test `check_test known_rkts || check_test all` && keypresspause

	additional_rootkit_checks

	malware_checks

	trojan_checks

	os_specific_checks

	keypresspause

	return
}


do_network_port_checks() {

	#
	# This function will check the network ports to see
	# if any known backdoor ports are being used.
	#

	#
	# We must check to see who can perform this test.
	#

	case "${OPERATING_SYSTEM}" in
	*BSD|Linux|AIX|SunOS|Darwin)
		;;
	*)
		return
		;;
	esac

	#
	# Systems with a modified kernel must also skip this test.
	#

	test $GRSECINSTALLED -eq 1 && return


	#
	# Next we do some further testing and the initial logging.
	#

	display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 NETWORK_PORTS_START

	if [ ! -f "${DB_PATH}/backdoorports.dat" -o ! -s "${DB_PATH}/backdoorports.dat" ]; then
		display --to SCREEN+LOG --type WARNING --screen-indent 4 NETWORK_PORTS_FILE_MISSING
		return
	elif [ -z "${NETSTAT_CMD}" ]; then
		display --to SCREEN+LOG --type WARNING --screen-indent 4 NETWORK_PORTS_FILE_NO_NETSTAT
		return
	fi


	#
	# Now do the test.
	#

	IFS="
"

	for LINE in `cat ${DB_PATH}/backdoorports.dat`; do
		if [ -n "`echo \"${LINE}\" | egrep -i '^#|version'`" ]; then
			continue
		elif [ -z "${LINE}" ]; then
			continue
		fi

		PORT=`echo "${LINE}" | cut -d: -f1`
		DESCRIPTION=`echo ${LINE} | cut -d: -f2`
		PROTO=`echo ${LINE} | cut -d: -f3 | tr '[a-z]' '[A-Z]'`

		if [ -n "`echo \"${PORT}\" | grep -v '^[0-9]'`" ]; then
			echo "Error: Invalid port in backdoorports.dat: $LINE"
			continue
		elif [ "${PROTO}" != "UDP" -a "${PROTO}" != "TCP" ]; then
			echo "Error: Invalid protocol in backdoorports.dat: $LINE"
			continue
		fi

		case "${OPERATING_SYSTEM}" in
		Linux)
			FOUND=`${NETSTAT_CMD} -an | grep -i "^${PROTO}.*:${PORT} "`
			;;
		*BSD|Darwin)
			FOUND=`${NETSTAT_CMD} -an | grep -i "^${PROTO}.*\.${PORT} "`
			;;
		AIX|SunOS)
			if [ "${PROTO}" = "UDP" ]; then
				FOUND=`${NETSTAT_CMD} -an | grep "\.${PORT} "`
			elif [ "${PROTO}" = "TCP" ]; then
				FOUND=`${NETSTAT_CMD} -an | egrep 'BOUND|ESTABLISH|LISTEN' | grep "\.${PORT} "`
			fi
			;;
		esac


		#
		# Now display the result.
		#

		if [ -z "${FOUND}" ]; then
			display --to SCREEN+LOG --type PLAIN --log-indent 2 --screen-indent 4 --result OK --color GREEN NETWORK_PORTS "${PROTO}" "${PORT}"
		else
			display --to SCREEN+LOG --type PLAIN --screen-indent 4 --log-indent 2 --result WARNING --color RED NETWORK_PORTS "${PROTO}" "${PORT}"
			display --to LOG --type WARNING NETWORK_PORTS_FOUND "${PROTO}" "${PORT}" "${DESCRIPTION}"
		fi
	done

	IFS=$ORIGIFS

	return
}


do_network_interface_checks() {

	#
	# This function will check the network interfaces to see
	# if any are in promiscuous mode. It will also check to see
	# if there are any applications running which are capturing
	# network interface packets.
	#

	display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 NETWORK_INTERFACE_START


	if [ -n "${IFCONFIG_CMD}" ]; then
		PROMISCSCAN1=""; PROMISCSCAN2=""

		if [ "${OPERATING_SYSTEM}" = "OpenBSD" -o "${OPERATING_SYSTEM}" = "AIX" ]; then
			PROMISCSCAN1=`${IFCONFIG_CMD} -a | grep -v 'pflog' | grep 'PROMISC'`
		elif [ "${OPERATING_SYSTEM}" = "SunOS" -o "${OPERATING_SYSTEM}" = "NetBSD" ]; then
			PROMISCSCAN1=`${IFCONFIG_CMD} -a | grep 'PROMISC'`
		else
			PROMISCSCAN1=`${IFCONFIG_CMD} | grep 'PROMISC'`
		fi

		if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
			if [ -n "${IP_CMD}" ]; then
				PROMISCSCAN2=`${IP_CMD} -s link | grep 'PROMISC'`
			else
				display --to LOG --type INFO NETWORK_PROMISC_NO_IP
			fi
		fi


		#
		# Now show the results of the interface check.
		#

		if [ -z "${PROMISCSCAN1}" -a -z "${PROMISCSCAN2}" ]; then
			display --to SCREEN+LOG --type PLAIN --color GREEN --result NOT_FOUND --log-indent 2 --screen-indent 4 NETWORK_PROMISC_CHECK
		else
			display --to SCREEN+LOG --type PLAIN --color RED --result WARNING --log-indent 2 --screen-indent 4 NETWORK_PROMISC_CHECK

			display --to LOG --type WARNING NETWORK_PROMISC_IF

			display --to LOG --type PLAIN --log-indent 9 NETWORK_PROMISC_IF_1 "${PROMISCSCAN1}"

			if [ "${OPERATING_SYSTEM}" = "Linux" -a -n "${PROMISCSCAN2}" ]; then
				PROMISCSCAN2=`echo "${PROMISCSCAN2}" | cut -d: -f2`

				for IFACE in ${PROMISCSCAN2}; do
					display --to LOG --type PLAIN --log-indent 9 NETWORK_PROMISC_IF_2 "${IFACE}"
				done
			fi
		fi
	else
		display --to SCREEN+LOG --type PLAIN --color RED --result WARNING --screen-indent 4 NETWORK_PROMISC_CHECK
		display --to LOG --type WARNING NETWORK_PROMISC_NO_IFCONFIG
	fi


	#
	# For the packet capturing check, we must first see if we
	# are able to run the test. We let the user know if the test
	# was disabled, or if the lsof command is not present.
	#

	test "${OPERATING_SYSTEM}" != "Linux" && return

	if ! `check_test packet_cap_apps`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST packet_cap_apps
		return
	elif [ ! -f "${ROOTDIR}/proc/net/packet" ]; then
		display --to SCREEN+LOG --type PLAIN --color RED --result WARNING --log-indent 2 --screen-indent 4 NETWORK_PACKET_CAP_CHECK
		display --to LOG --type WARNING NETWORK_PACKET_CAP_CHECK_NO_FILE "${ROOTDIR}/proc/net/packet"
		return
	elif [ -z "${LSOF_CMD}" ]; then
		display --to SCREEN+LOG --type PLAIN --color YELLOW --result SKIPPED --log-indent 2 --screen-indent 4 NETWORK_PACKET_CAP_CHECK
		display --to LOG --type INFO NOT_FOUND_CMD "lsof"
		return
	fi


	#
	# Now run the test.
	#

	FOUND=0
	WHITEPROC=""; BLACKPROC=""

	LIBPCAPRES=`egrep -v '^sk|888e' ${ROOTDIR}/proc/net/packet | cut -c1`

	if [ -n "${LIBPCAPRES}" ]; then
		#
		# We only need to get the whitelisted processes once.
		#

		ALLOWPROCLISTENERS=`grep '^ALLOWPROCLISTEN=' ${CONFIGFILE} | sed -e 's/ALLOWPROCLISTEN=//g'`


		for INODE in `egrep -v '^sk|888e' ${ROOTDIR}/proc/net/packet | awk '{print $9}'`; do
			for PID in `${LSOF_CMD} -lMnP | grep "$INODE" | awk '{print $2}'`; do
				if [ -n "${READLINK_CMD}" ]; then
					NAME=`${READLINK_CMD} -f ${ROOTDIR}/proc/$PID/exe`
				else
					NAME=`grep '^Name:.' ${ROOTDIR}/proc/$PID/status | sed -e 's/^Name:.//'`
				fi


				AMATCH=1

				for RKHTMPVAR in ${ALLOWPROCLISTENERS}; do
					if [ "${NAME}" = "${RKHTMPVAR}" ]; then
						AMATCH=0; break
					fi
				done

				if [ $AMATCH -eq 0 ]; then
					FNAME=`echo "${NAME}" | sed -e 's/\./\\\./g'`
					if [ -z "`echo ${WHITEPROC} | egrep \"${FNAME}( |$)\"`" ]; then
						WHITEPROC="${WHITEPROC} ${NAME}"
					fi
				else
					FOUND=1
					BLACKPROC="${BLACKPROC}
${NAME} ${PID}"
				fi
			done
		done
	fi


	#
	# Now display the results.
	#

	if [ $FOUND -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --color GREEN --result NOT_FOUND --log-indent 2 --screen-indent 4 NETWORK_PACKET_CAP_CHECK
	else
		display --to SCREEN+LOG --type PLAIN --color RED --result WARNING --log-indent 2 --screen-indent 4 NETWORK_PACKET_CAP_CHECK


		IFS="
"

		for RKHTMPVAR in ${BLACKPROC}; do
			test -z "${RKHTMPVAR}" && continue

			NAME=`echo "${RKHTMPVAR}" | cut -d' ' -f1`
			PID=`echo "${RKHTMPVAR}" | cut -d' ' -f2`

			display --to LOG --type WARNING NETWORK_PACKET_CAP_FOUND "${NAME}" "${PID}"
		done

		IFS=$IFSORIG
	fi

	for NAME in $WHITEPROC; do
		display --to LOG --type INFO NETWORK_PACKET_CAP_WHITE "${NAME}"
	done

	return
}


do_network_checks() {

	#
	# This function carries out some network checks. This consists
	# of port checks, and some interface checks.
	#

	if ! `check_test network`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST network
		return
	fi


	display --to SCREEN+LOG --type PLAIN --color YELLOW --nl CHECK_NETWORK


	do_network_port_checks

	do_network_interface_checks

	keypresspause

	return
}


do_local_host_checks() {

	#
	# This function carries out a sequence of tests on the local
	# host.
	#

	if ! `check_test local_host`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST local_host
		return
	fi


	display --to SCREEN+LOG --type PLAIN --color YELLOW --nl CHECK_LOCALHOST


	displaytext "* Allround tests${NORMAL}"

	displaytext -n "   Checking hostname... "
	if [ "${HOST_NAME}" = "" ]; then
		displaytext "${RED}Warning. ${NORMAL}Found empty hostname. Some programs don't like this."
	else
		displaytext "${GREEN}Found. ${NORMAL}Hostname is ${HOST_NAME}"
	fi


	FOUND=0
	SIZE=49
	jump=`expr ${defaultcolumn} - ${SIZE}`
	displaytext -n "   Checking for passwordless user accounts... "
	logtext "Checking for passwordless user accounts... "
	if [ -f "${ROOTDIR}/etc/shadow" ]; then
		for I in `cat ${ROOTDIR}/etc/shadow`; do
			USER=`echo "${I}" | cut -d: -f1`
			PASSWORD=`echo "${I}" | cut -d: -f2`
			# Exclude NIS-user (+::::::)
			if [ ! "${USER}" = "+" -a "x${PASSWORD}x" = "xx" ]; then
				FOUND=1
				logtext "Warning! Found passwordless account (${USER})"
				logtext "Check this account and give it a password."
			fi
		done
		if [ ${FOUND} -eq 0 ]; then
			displaytext "${GREEN}OK${NORMAL}"
		else
			displaytext "${RED}Warning!${NORMAL}"
			displaytext "Found passwordless user account. Check the logfile for more information"
			logtext --nodate "OK"
		fi
	else
		insertlayout
		displaytext "${WHITE}Skipped${NORMAL}"
		logtext --nodate "Skipped"
		logtext "Skipped test because /etc/shadow doesn't exist"
	fi



	if `check_test passwd`; then
		displaytext -n "   Checking for differences in user accounts... "
		if [ -f "${ROOTDIR}/etc/passwd" ]; then
			if [ -f "${TMPDIR}/passwd" ]; then
				differences=`diff ${ROOTDIR}/etc/passwd ${TMPDIR}/passwd 2>/dev/null | grep ':'`
				if [ "${differences}" = "" ]; then
					displaytext "${GREEN}OK. ${NORMAL}No differences."
				else
					diffadded=`echo "${differences}" | grep '<'`
					diffremoved=`echo "${differences}" | grep '>'`
					displaytext "${RED}Found differences${NORMAL}"
					displaytext "   Info: "
					displaytext "----------------------"
					displaytext "${differences}"
					displaytext "----------------------"
					if [ ! "${diffadded}" = "" ]; then
						displaytext "   Info: Some items have been added (items marked with '<')"
					fi
					if [ ! "${diffremoved}" = "" ]; then
						displaytext "   Info: Some items have been removed (items marked with '>')"
					fi
				fi
				rm -f ${TMPDIR}/passwd >/dev/null 2>&1
			else
				jump=44
				displaytext $E "${LAYOUT}[ ${YELLOW}NA${NORMAL} ]"
			fi
			cp ${ROOTDIR}/etc/passwd ${TMPDIR}/passwd
		else
			displaytext "${RED}Error. ${NORMAL}Cannot find /etc/passwd"
			logtext "Can't find /etc/passwd file?!?"
		fi

		displaytext -n "   Checking for differences in user groups... "
		if [ -f "${ROOTDIR}/etc/group" ]; then
			if [ -f "${TMPDIR}/group" ]; then
				differences=`diff ${ROOTDIR}/etc/group ${TMPDIR}/group | grep ':'`
				if [ "${differences}" = "" ]; then
					displaytext "${GREEN}OK. ${NORMAL}No differences."
				else
					diffadded=`echo "${differences}" | grep '<'`
					diffremoved=`echo "${differences}" | grep '>'`
					displaytext "${RED}Found differences${NORMAL}"
					displaytext "   Info: "
					displaytext "----------------------"
					displaytext "${differences}"
					displaytext "----------------------"
					if [ ! "${diffadded}" = "" ]; then
						displaytext "   Info: Some items have been added (items marked with '<')"
					fi
					if [ ! "${diffremoved}" = "" ]; then
						displaytext "   Info: Some items have been removed (items marked with '>')"
					fi
				fi
				rm -f ${TMPDIR}/group >/dev/null 2>&1
			else
				displaytext "${YELLOW}Creating file ${NORMAL}It seems this is your first time."
			fi
			cp ${ROOTDIR}/etc/group ${TMPDIR}/group
		else
			displaytext "${RED}Error. ${NORMAL}Cannot find /etc/group"
			logtext "Can't find /etc/group file?!?"
		fi
	else
		display --to LOG --type INFO USER_DISABLED_TEST passwd
	fi


	SIZE=42
	jump=`expr ${defaultcolumn} - ${SIZE}`
	displaytext "   Checking boot.local/rc.local file... "

	# Gentoo: /etc/conf.d/local.start
	RCLOCATIONS="${ROOTDIR}/etc/rc.local ${ROOTDIR}/etc/rc.d/rc.local ${ROOTDIR}/usr/local/etc/rc.local ${ROOTDIR}/usr/local/etc/rc.d/rc.local ${ROOTDIR}/etc/conf.d/local.start ${ROOTDIR}/etc/init.d/boot.local"
	FOUNDRCSIGN=0

	for FILE in ${RCLOCATIONS}; do
		FILELENGTH=`echo ${FILE} | wc -c | tr -d ' '`
		SIZE=4
		jump=`expr ${defaultcolumn} - ${SIZE} - ${FILELENGTH}`

		displaytext -n "     - ${FILE}"
		if [ -f "${FILE}" ]; then
			for J in ${RCLOCAL_STRINGS}; do
				STRING=`echo ${J} | cut -d: -f1 | sed -e 's/\./\\\./g'`
				FOUND=`grep "${STRING}" ${FILE}`
				if [ ! "${FOUND}" = "" ]; then
					FOUNDRCSIGN=1
					logtext "Warning! Found unusual string in ${FILE}"
				fi
			done

			if [ "${FOUNDRCSIGN}" -eq 1 ]; then
				insertlayout
				displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (found unusual signs) ]"
				logtext "Warning! Found unusual string in rc.local/boot.local file"
			else
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			fi
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}Not found${NORMAL} ]"
		fi
	done

	FOUNDRCSIGN=0
	COUNTER=0

	SIZE=24
	jump=`expr ${defaultcolumn} - ${SIZE}`
	displaytext -n "   Checking rc.d files... "

	if [ -d "${ROOTDIR}/etc/rc.d" ]; then
		# Insert end-of-line
		displaytext ""
		displaytext -n "     Processing"
		for I in `find ${ROOTDIR}/etc/rc.d/*`; do
			# Only check files, not directories
			if [ -f "${I}" ]; then
				COUNTER=`expr ${COUNTER} + 1`
				if [ ${COUNTER} -eq 40 ]; then
					displaytext "."
					displaytext -n "               "
					COUNTER=0
				else
					displaytext -n "."
				fi
				for J in ${RCLOCAL_STRINGS}; do
					STRING=`echo ${J} | cut -d: -f1 | sed -e 's/\./\\\./g'`
					FOUND=`grep "${STRING}" ${I}`
					if [ ! "${FOUND}" = "" ]; then
						FOUNDRCSIGN=1
					fi
				done
			fi
		done

		# Insert end-of-line
		displaytext ""
		displaytext -n "   Result rc.d files check"
		if [ "${FOUNDRCSIGN}" -eq 1 ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (found unusual things) ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		fi
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}Not found${NORMAL} ]"
	fi

	if [ -f "${ROOTDIR}/etc/conf.d/local.start" ]; then
		SIZE=37
		jump=`expr ${defaultcolumn} - ${SIZE}`
		displaytext -n "   Checking Gentoo local.start file... "
		logtext "Found ${ROOTDIR}/etc/conf.d/local.start file (Gentoo)"

		INSPECTLINES=`grep -v '^#' ${ROOTDIR}/etc/conf.d/local.start | grep -v '^$'`

		for J in ${RCLOCAL_STRINGS}; do
			STRING=`echo ${J} | cut -d: -f1 | sed -e 's/\./\\\./g'`
			FOUND=`echo ${INSPECTLINES} | grep "${STRING}"`
			if [ ! "${FOUND}" = "" ]; then
				FOUNDRCSIGN=1
				logtext "Found ${FOUND} while checking ${ROOTDIR}/etc/conf.d/local.start"
			fi
		done

		if [ "${FOUNDRCSIGN}" -eq 1 ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		fi
	fi


	logtext "---------------------------- History files ----------------------------"

	SIZE=15
	displaytext "   Checking history files"
	jump=`expr ${defaultcolumn} - ${SIZE}`

	displaytext -n "     Bourne Shell"

	if [ -f "${ROOTDIR}/root/.bash_history" ]; then
		ATTRIBUTE=`ls -l ${ROOTDIR}/root/.bash_history | cut -c1`
		if [ "${ATTRIBUTE}" = "l" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (redirection found) ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		fi
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}Not Found${NORMAL} ]"
	fi



	logtext "------------------------- Security advisories -------------------------"

	SIZE=30
	jump=`expr ${defaultcolumn} - ${SIZE}`


	displaytext "* Check: Groups and Accounts${NORMAL}"
	displaytext -n "   Searching for ${ROOTDIR}/etc/passwd... "
	if [ -f "${ROOTDIR}/etc/passwd" ]; then
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}Found${NORMAL} ]"
		displaytext -n "   Checking users with UID '0' (root)... "

		SIZE=39
		jump=`expr ${defaultcolumn} - ${SIZE}`

		users_with_uid0=`grep -v '^:0:0:::' ${ROOTDIR}/etc/passwd | grep ':0:' | cut -d: -f1,3 | grep '0' | grep -v 'root:0'`
		if [ "${users_with_uid0}" = "" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${YELLOW}Warning!${NORMAL} (some users in root group) ]"
			displaytext "    info: ${users_with_uid0}"
		fi

	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${RED}Not Found${NORMAL} ]"
	fi

	displaytext "";
	displaytext "* Check: SSH${NORMAL}"

	SIZE=39
	jump=`expr ${defaultcolumn} - ${SIZE}`

	displaytext "   Searching for sshd_config... "
	SSHDCONFIG_PLACES="${ROOTDIR}/etc ${ROOTDIR}/etc/ssh ${ROOTDIR}/usr/local/etc ${ROOTDIR}/usr/local/etc/ssh"
	for I in ${SSHDCONFIG_PLACES}; do
		if [ -f "${I}/sshd_config" ]; then
			FOUND=0
			displaytext "   Found ${I}/sshd_config"
			displaytext -n "   Checking for allowed root login... "
			permitrootlogin=`grep 'PermitRootLogin' ${I}/sshd_config | grep -v '#'`
			if [ "${permitrootlogin}" = "PermitRootLogin yes" ]; then
				FOUND=1
				logtext "Info: Found 'PermitRootLogin yes'. Unsafe for production servers..."
				logtext "Tip: Change the option in your configuration file (${I}/sshd_config)."
				logtext "     Use normal user accounts and 'su' to obtain root permissions."
			else
				permitrootlogin2=`egrep 'PermitRootLogin (no|without-password)' ${I}/sshd_config | grep -v '#'`
				if [ "${permitrootlogin2}" = "PermitRootLogin no" -o "${permitrootlogin2}" = "PermitRootLogin without-password" ]; then
					FOUND=0
					logtext "Info: Found 'PermitRootLogin no' or 'PermitRootLogin without-password' in SSH configuration file ${I}/sshd_config"
				else
					permitrootlogin2=`grep 'PermitRootLogin forced-commands-only' ${I}/sshd_config | grep -v '#'`
					if [ "${permitrootlogin2}" = "PermitRootLogin forced-commands-only" ]; then
						FOUND=1
						logtext "Info: Found 'PermitRootLogin forced-commands-only'"
					else
						permitrootlogin3=`grep '#PermitRootLogin yes' ${I}/sshd_config`
						if [ -n "${permitrootlogin3}" ]; then
							FOUND=1
							logtext "Info: Found no PermitRootLogin value in file ${I}/sshd_config. Default value is 'yes'."
						else
							FOUND=0
							logtext "Unknown PermitRootLogin value found in file ${I}/sshd_config"
						fi
					fi
				fi
			fi

			if [ ${FOUND} -eq 1 ]; then
				if [ $ALLOW_SSH_ROOT_USER -eq 0 ]; then
					displaytext "${RED}Warning${NORMAL} Root login possible. Possible risk!"
					if [ -z "${permitrootlogin}" ]; then
						displaytext "    info: No 'PermitRootLogin' entry found in file ${I}/sshd_config"
					else
						displaytext "    info: \"${permitrootlogin}\" found in file ${I}/sshd_config"
					fi
					displaytext "    Hint: Check the logfile for more information about this issue"
					logtext "Warning: root login possible. Change for your safety the 'PermitRootLogin'"
					logtext "entry in the SSH configuration file ${I}/sshd_config to 'no', and use 'su -' to become root. "
				else
					logtext "Remote root login permitted, but allowed by using explicit option"
					SIZE=36
					jump=`expr ${defaultcolumn} - ${SIZE}`
					insertlayout
					displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (Remote root login permitted by explicit option) ]"
				fi
			else
				SIZE=36
				jump=`expr ${defaultcolumn} - ${SIZE}`
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (Remote root login disabled) ]"
			fi

			displaytext -n "   Checking for allowed protocols... "

			protocols=`grep 'Protocol 2' ${I}/sshd_config | grep -v '#'`
			if [ "${protocols}" = "Protocol 2" ]; then
				SIZE=35
				jump=`expr ${defaultcolumn} - ${SIZE}`
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (Only SSH2 allowed) ]"
			else
				if [ "${protocols}" = "Protocol 2,1" -o "${protocols}" = "Protocol 1,2" -o "${protocols}" = "Protocol 1" ]; then
					SIZE=35
					jump=`expr ${defaultcolumn} - ${SIZE}`
					insertlayout
					if [ "${ALLOW_SSH_PROT_V1}" = "0" ]; then
						displaytext $E "${LAYOUT}[ ${YELLOW}Warning${NORMAL} ]"
						displaytext "    info: Users can use SSH1-protocol (Check the logfile for more information)."
						logtext "Hint: Change the 'Protocol xxx' line into 'Protocol 2'"
					else
						displaytext $E "${LAYOUT}[ ${OK}OK${NORMAL} (SSH1-protocol permitted by explicit option) ]"
						logtext "Info: found SSH1-protocol permitted by explicit option."
					fi	
				else
					SIZE=35
					jump=`expr ${defaultcolumn} - ${SIZE}`
					insertlayout
					protocols=`grep '#Protocol' ${I}/sshd_config`
					if [ "${protocols}" = "#Protocol 2,1" -o "${protocols}" = "#Protocol 1,2" ]; then
						FOUND=1
						logtext "Found default option Protocol 2,1"
					fi
					if [ "${protocols}" = "#Protocol 1" ]; then
						FOUND=1
						logtext "Found default option Protocol 1"
					fi

					if [ ${FOUND} -eq 0 ];then
						displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (Only SSH2 allowed) ]"
						displaytext "    info: found no option, most times default value is used."
					else
						if [ "${ALLOW_SSH_PROT_V1}" = "0" ]; then
							displaytext $E "${LAYOUT}[ ${YELLOW}Warning${NORMAL} (SSH1-protocol allowed) ]"
							logtext "Warning: SSH version 1 possible allowed!"
							logtext "Hint: Change the 'Protocol xxx' line into 'Protocol 2'"
						else
							displaytext $E "${LAYOUT}[ ${OK}OK${NORMAL} (SSH1-protocol permitted by explicit option) ]"
							logtext "Info: found SSH1-protocol permitted by explicit option."
						fi
					fi
				fi
			fi
		fi
	done


	displaytext ""
	displaytext "* Check: Events and Logging${NORMAL}"
	displaytext -n "   Search for syslog configuration... "

	SIZE=36
	jump=`expr ${defaultcolumn} - ${SIZE}`


	if [ -f "${ROOTDIR}/etc/syslog.conf" -o -f "${ROOTDIR}/etc/syslog-ng/syslog-ng.conf" ]; then
		insertlayout
		displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		SIZE=38
		jump=`expr ${defaultcolumn} - ${SIZE}`

		displaytext -n "   Checking for running syslog slave... "

		case "${OPERATING_SYSTEM}" in
		SunOS)
			syslogisrunning=`ps -ef | grep 'syslogd' | grep -v 'grep'`
			syslogngisrunning=`ps -ef | grep 'syslog-ng' | grep -v 'grep'`
			;;
		*)
			syslogisrunning=`ps ax | egrep 'syslogd|syslog-ng|metalog' | grep -v 'grep'`
			#syslogngisrunning=`ps ax | grep syslog-ng | grep -v "grep"`
			;;
		esac

		if [ ! "${syslogisrunning}" = "" -o ! "${syslogngisrunning}" = "" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} ]"
			displaytext "    Info: Cannot find syslog/syslog-ng daemon"
		fi

		SIZE=42
		jump=`expr ${defaultcolumn} - ${SIZE}`

		displaytext -n "   Checking for logging to remote system... "

		# First do syslog
		if [ -f "${ROOTDIR}/etc/syslog.conf" ]; then
			logtoremote=`grep '@' ${ROOTDIR}/etc/syslog.conf | grep -v '#'`
		else
			# Second try syslog-ng
			if [ -f "${ROOTDIR}/etc/syslog-ng/syslog-ng.conf" ]; then
				# Yes, we found the configuration file
				# Gready regex necessary due to allowed formatting (indentation, destination names, destinations)
				# As result logtxt below may contain partial lines.
				logtoremote=`egrep -iA1 '^destination.*{' ${ROOTDIR}/etc/syslog-ng/syslog-ng.conf | egrep '(udp|tcp).*\(' | grep -v '/'`
			else
				displaytext $E "${LAYOUT}[ ${YELLOW}NA${NORMAL} ]"
				displaytext "Warning: Cannot find syslog-ng configuration file"
				logtext "Info: Cannot find syslog-ng configuration file"
			fi
		fi

		if [ "${logtoremote}" = "" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (no remote logging) ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} (remote logging) ]"
			displaytext "    info: ${logtoremote}"
			logtext "Info: line found with logging to remote host ($logtoremote)"
		fi
	fi


	displaytext ""
	displaytext "* Filesystem checks${NORMAL}"

	if [ -d "${ROOTDIR}/dev" ]; then
		# FreeBSD (5): character special, symbolic link to,directory
		# Linux (Debian): block special, socket, fifo (named pipe)

# jh - add in whitelisting for /dev files.
		display --to LOG --type INFO CONFIG_SCAN_MODE_DEV "${SCAN_MODE_DEV}"

		if [ "${SCAN_MODE_DEV}" = "LAZY" ]; then
			displaytext -n "   Checking /dev for suspicious files... (in explicit LAZY mode)"
			SPECIALFILES=`file "${ROOTDIR}/dev/"* | cat -v | egrep -v 'character special|block special|socket|fifo \(named pipe\)|symbolic link to|empty|directory|MAKEDEV'`
		else
			displaytext -n "   Checking /dev for suspicious files... "
			SPECIALFILES=`find "${ROOTDIR}/dev/" | while read f; do file "${f}" | cat -v | egrep -v 'character special|block special|socket|fifo \(named pipe\)|symbolic link to|empty|directory|MAKEDEV'; done`
		fi

		SIZE=39
		jump=`expr ${defaultcolumn} - ${SIZE}`

		if [ "${SPECIALFILES}" = "" ]; then
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${RED}Warning!${NORMAL} (unusual files found) ]"
			displaytext "---------------------------------------------"
			displaytext "Unusual files:"
			displaytext "${SPECIALFILES}"
			displaytext "---------------------------------------------"
		fi
	else
		insertlayout
		displaytext $E "${LAYOUT}[ ${YELLOW}NA${NORMAL} ]"
	fi

	SIZE=29

	displaytext -n "   Scanning for hidden files..."

	SEARCHINDIRS="${ROOTDIR}/dev ${ROOTDIR}/bin ${ROOTDIR}/usr ${ROOTDIR}/usr/man ${ROOTDIR}/usr/share/man ${ROOTDIR}/usr/man/man1 ${ROOTDIR}/usr/share/man/man1 ${ROOTDIR}/usr/man/man8 ${ROOTDIR}/usr/share/man/man8 ${ROOTDIR}/usr/bin ${ROOTDIR}/usr/sbin ${ROOTDIR}/sbin ${ROOTDIR}/etc"
	# Only reset status once
	STATUS=0

	if [ -z "${LS_CMD}" ]; then
		jump=`expr ${defaultcolumn} - ${SIZE}`
		insertlayout
		displaytext $E "${LAYOUT}[ ${YELLOW}Skipped${NORMAL} ]"
		logtext "Scanning for hidden files... Skipped"
		logtext "Test skipped because no \"ls\" command is present."
	else
		for I in ${SEARCHINDIRS}; do
			# Initialize directory
			HIDDENDIRS=""

			logtext "Start scanning for hidden files in ${I}..."

			if [ -d "${I}" ]; then
				HIDDENDIRS=`${LS_CMD} -A1d ${I}/.* | egrep -v '\/\.\.?$'`
				logtext "Value of hiddendirs: ${HIDDENDIRS}"
			fi

			if [ -n "${HIDDENDIRS}" ]; then
				ALLHIDDENDIRS="${HIDDENDIRS} ${ALLHIDDENDIRS}"
				STATUS=1
			fi

			logtext "End of scanning ${I}"
		done

		if [ ${STATUS} -eq 0 ]; then
			jump=`expr ${defaultcolumn} - ${SIZE}`
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		else
			# Reset state
			STATUS=0
			for I in ${ALLHIDDENDIRS}; do
				if [ ${OPERATING_SYSTEM} = "AIX" -o ${OPERATING_SYSTEM} = "SunOS" ] ; then
					FILETYPE=`file ${I}|awk '{print $2}'`
				else
					FILETYPE=`file -b ${I}`
				fi

				# Ignore some filetypes, because they are harmless
				case "${FILETYPE}" in
				"character special (8/0)" | "character special (254/0)" | "empty")
					logtext "Hidden file/dir ${I} [${FILETYPE}] seems to be OK"
					;;
				"TDB database"*)
					logtext "Hidden file/dir ${I} [${FILETYPE}] seems to be OK"
					;;
				*)
					# Ignore Gentoo's zero-sized files (extra check for future use)
					if [ ! ${GENTOO} -eq 1 -a ! "${I}" = ".keep" -a ! -z ${I} ]; then
						SEARCHDIR=0
						if [ "${FILETYPE}" = "directory" ]; then
							for ALLOWHIDDENDIRS in `grep '^ALLOWHIDDENDIR=' ${CONFIGFILE} | sed -e 's/ALLOWHIDDENDIR=//g'`; do
								if [ "${ROOTDIR}${ALLOWHIDDENDIRS}" = "${I}" ]; then
									SEARCHDIR=1
									logtext "Found hidden directory ${I} on whitelist"
								fi
							done
						else
							for ALLOWHIDDENFILES in `grep '^ALLOWHIDDENFILE=' ${CONFIGFILE} | sed -e 's/ALLOWHIDDENFILE=//g'`; do
								if [ "${ROOTDIR}${ALLOWHIDDENFILES}" = "${I}" ]; then
									SEARCHDIR=1
									logtext "Found hidden file ${I} on whitelist"
								fi
							done
						fi

						# Is it a directory and is it on the whitelist?
						# searchdir: 0 = NOT on list, 1 = on list
						if [ ${SEARCHDIR} -eq 0 ]; then
							STATUS=1
							HIDDENFILES="${HIDDENFILES} ${I} (${FILETYPE}) "
							logtext "Added ${I} (${FILETYPE}) to list of unknown hidden files/dirs"
						fi
					fi
					;;
				esac
			done

			if [ ${STATUS} -eq 1 ]; then
				jump=`expr ${defaultcolumn} - ${SIZE}`
				insertlayout
				displaytext $E "${LAYOUT}[ ${YELLOW}Warning!${NORMAL} ]"
				logtext "WARNING, found: ${HIDDENFILES}"

				displaytext "---------------"
				displaytext "${ALLHIDDENDIRS}"
				displaytext "---------------"

				displaytext "Please inspect: ${HIDDENFILES}"
			else
				jump=`expr ${defaultcolumn} - ${SIZE}`
				insertlayout
				displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			fi
		fi
	fi

	keypresspause

	return
}


do_app_checks() {

	#
	# This function carries out a sequence of application checks.
	#

# jh - remove need for programs_good.dat; only warn user if a programs_bad entry is seen.
	if ! `check_test apps`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST apps
		return
	fi


	display --to SCREEN+LOG --type PLAIN --color YELLOW --nl CHECK_APPS




	displaytext "* Application scan"

	FOUNDSTRING=0
	SIZE=32
	displaytext -n "   Checking Apache2 modules... "
	jump=`expr ${defaultcolumn} - ${SIZE}`

	if [ -d "${ROOTDIR}/etc/apache2/mods-enabled" ]; then
		SEARCHSTRING=`ls ${ROOTDIR}/etc/apache2/mods-enabled/* | egrep 'mod_rootme2?\.so'`
		logtext -n "Checking Apache2 modules in ${ROOTDIR}/etc/apache2/mods-enabled... "
		if [ -n "${SEARCHSTRING}" ]; then
			logtext --nodate "Warning! Possible bad module found."
			FOUNDSTRING=1
		else
			logtext --nodate "OK"
		fi

		if [ ${FOUNDSTRING} -eq 1 ]; then
			insertlayout
			displaytext $E "   ${LAYOUT}[ ${RED}BAD${NORMAL} ]"
		else
			insertlayout
			displaytext $E "   ${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
		fi
	else
		insertlayout
		displaytext $E "   ${LAYOUT}[ ${GREEN}Not found${NORMAL} ]"
	fi

	FOUNDSTRING=0

	SIZE=37
	displaytext "   Checking Apache configuration... "

	for I in ${HTTPDCONFS}; do
		FILELENGTH=`echo ${I} | wc -c | tr -d ' '`
		SIZE=4
		jump=`expr ${defaultcolumn} - ${SIZE} - ${FILELENGTH}`

		displaytext -n "     - ${I}"
		if [ -f "${I}" ]; then
			SEARCHSTRING=`egrep 'mod_rootme2?\.so' ${I}`
			test -n "${SEARCHSTRING}" && FOUNDSTRING=1

			if [ ${FOUNDSTRING} -eq 1 ]; then
				insertlayout
				displaytext $E "   ${LAYOUT}[ ${RED}BAD${NORMAL} ]"
			else
				insertlayout
				displaytext $E "   ${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
			fi
		else
			insertlayout
			displaytext $E "${LAYOUT}[ ${GREEN}Not found${NORMAL} ]"
		fi
	done

	logtext "---------------------- Application version check ----------------------"

	if [ $APPS_CHECK_ENABLED -eq 1 ]; then
		displaytext ""
		displaytext "* Application version scan"

		APPS_COUNT=0

		#BINPATHS="/bin /sbin /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin /usr/local/libexec /usr/libexec"

		if [ "${OPERATING_SYSTEM}" = "AIX" ]; then
			SCANFILES="
exim:Exim%%MTA:
httpd:Apache:
openssl:OpenSSL:
php:PHP:
procmail:Procmail%%MTA:
proftpd:ProFTPd:
sshd:OpenSSH:
"
		else
			SCANFILES="
exim:Exim%%MTA:
gpg:GnuPG:
httpd:Apache:
named:Bind%%DNS:
openssl:OpenSSL:
php:PHP:
procmail:Procmail%%MTA:
proftpd:ProFTPd:
sshd:OpenSSH:
"
		fi

		LINUX_KERNELS="
vulnerable:%2.4.22%2.4.23%
nonvulnerable:%2.4.24%
"

		FOUND=0
		FOUNDUNKNOWN=0

		APPS_TOTAL_COUNT=`echo "${SCANFILES}" | wc -l | tr -d ' '`
		APPS_TOTAL_COUNT=`expr ${APPS_TOTAL_COUNT} - 2`

		for J in ${SCANFILES}; do
			APPLICATION=`echo ${J} | cut -d: -f1`
			APPLICATIONNAME=`echo ${J} | cut -d: -f2`
			VULNERABLE=`cat ${DB_PATH}/programs_bad.dat | cut -d: -f2`
			NONVULNERABLE=`cat ${DB_PATH}/programs_good.dat | cut -d: -f2`
			logtext "----------------------------------------------------------"
			logtext "Scanning ${APPLICATIONNAME}..."

			FILEFOUND=0
			for I in ${BINPATHS}; do
				if [ -f "${I}/${APPLICATION}" ]; then
					FILEFOUND=1
					VERSION=""

					APPS_COUNT=`expr ${APPS_COUNT} + 1`

					case "${APPLICATION}" in
					exim)
						VERSION=`${I}/exim -bV | grep 'Exim version' | awk '{ print $3 }'`
						;;
					gpg)
						VERSION=`${I}/gpg --version --homedir / | grep 'GnuPG' | awk '{ print $3 }'`
						;;
					httpd)
						VERSION=`${I}/httpd -v | grep 'Apache' | cut -d' ' -f3 | cut -d'/' -f2`
						;;
					named)
						VERSION=`${I}/named -v | grep 'named' | grep -v '/' | awk '{ print $2 }'`
						if [ ! "`echo ${VERSION} | grep '-'`" = "" ]; then
							VERSION=`echo ${VERSION} | cut -d'-' -f1`
						fi
						TEST=`${I}/named -v | grep 'named'`
						logtext "Debug: ${TEST}"
						if [ "${VERSION}" = "" ]; then
							VERSION=`${I}/named -v | awk '{ print $2 }'`
						fi
						;;
					openssl)
						VERSION=`${I}/openssl version | head -n 1 | cut -d' ' -f2`
						;;
					php)
						# Strip off any additions (like Debian using version 4.3.10-8)
						VERSION=`${I}/php -v | head -n 1 | awk '{ print $2 }' | cut -d'-' -f1`
						;;
					procmail)
						VERSION=`${I}/procmail -v 2>&1  | grep 'procmail v' | awk '{ print $2 }' | tr -d 'v'`
						;;
					proftpd)
						VERSION=`${I}/proftpd -v 2>&1 | awk '{ print $4 }'`
						;;
					sshd)
						VERSION=`${I}/sshd -t -d 2>&1 | head -n 1 | awk '{ print $4 }' | cut -d'_' -f2`
						if [ ! "`echo "${VERSION}" | grep '+'`" = "" ]; then
							VERSION=`echo "${VERSION}" | cut -d'+' -f1`
						fi
						;;
					*)
						displaytext "Unknown"
						VERSION="NA"
						;;
					esac

					logtext "${I}/${APPLICATION} found"

					VERSION=`echo ${VERSION} | tr -d '\r'`

					if [ "${VERSION}" = "" ]; then
						logtext "No version found of application ${APPLICATION}"
						APPLICATIONNAME=`echo ${APPLICATIONNAME} | tr -s '%' ' '`
						displaytext -n "   - ${APPLICATIONNAME} [unknown] "

						JUMPCOL=`expr ${defaultcolumn} - 12`
						SIZE=`echo \'${APPLICATIONNAME} [unknown]\' | wc -c | tr -d ' '`
						jump=`expr ${JUMPCOL} - ${SIZE} + 11`
						insertlayout
						displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
					else
						APPLICATIONNAME=`echo ${APPLICATIONNAME} | tr -s '%' ' '`
						displaytext -n "   - ${APPLICATIONNAME} ${VERSION} "

						JUMPCOL=`expr ${defaultcolumn} - 12`
						SIZE=`echo \'${APPLICATIONNAME} ${VERSION}\' | wc -c | tr -d ' '`
						jump=`expr ${JUMPCOL} - ${SIZE} + 11`
						insertlayout

						RE_VERSION=`echo "${VERSION}" | sed -e 's/\./\\\./g'`
						ISVULNERABLE=`echo ${VULNERABLE} | grep "%${RE_VERSION}%"`
						if [ "${ISVULNERABLE}" = "" ]; then
							ISNONVULNERABLE=`echo ${NONVULNERABLE} | grep "%${RE_VERSION}%"`
							if [ "${ISNONVULNERABLE}" = "" ]; then
								logtext "No information available. Unknown version number"
								displaytext $E "${LAYOUT}[ ${YELLOW}Unknown${NORMAL} ]"
								FOUNDUNKNOWN=1
							else
								logtext "Version ${VERSION} is available in non-vulnerable group and seems to be OK!"
								displaytext $E "${LAYOUT}[ ${GREEN}OK${NORMAL} ]"
							fi
						else
							logtext "Version ${VERSION} seems to be vulnerable (if unpatched)!"
							if [ ${USE_PATCHED_SOFTWARE} -eq 1 ]; then
								displaytext $E "${LAYOUT}[ ${YELLOW}Old or patched version${NORMAL} ]"
							else
								displaytext $E "${LAYOUT}[ ${RED}Vulnerable${NORMAL} ]"
							fi
							FOUND=1
							APPS_FAILED_COUNT=`expr ${APPS_FAILED_COUNT} + 1`
						fi
					fi
				fi
			done

			if [ ${FILEFOUND} -eq 0 ]; then
				logtext "Application not found"
			fi
		done


		displaytext ""
		if [ $FOUNDUNKNOWN -eq 1 ]; then
			displaytext "Your system contains some unknown version numbers. Please run Rootkit Hunter"
			displaytext "with the --update parameter or contact us through the Rootkit Hunter mailing list"
			displaytext "at rkhunter-users@lists.sourceforge.net"
		fi

	fi

	display --to LOG --type INFO APPS_TOTAL_COUNT $APPS_COUNT $APPS_TOTAL_COUNT

	return
}


display_check_summary() {

	#
	# This function displays a short summary of some of the
	# groups of checks performed.
	#

	if [ $QUIET -eq 0 -o \( $SHOWWARNINGSONLY -eq 1 -a $WARNING_COUNT -gt 0 \) ]; then
		RKHTMPVAR=2
	else
		RKHTMPVAR=1
	fi

	display --to SCREEN+LOG --type PLAIN --nl ${RKHTMPVAR} SUMMARY_TITLE1
	display --to SCREEN+LOG --type PLAIN SUMMARY_TITLE2


	#
	# Do file properties summary.
	#

	display --to SCREEN+LOG --type PLAIN --nl SUMMARY_PROP_SCAN

	if `check_test properties`; then
		if [ $SUMMARY_PROP_REQCMDS -eq 1 ]; then
			display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_PROP_REQCMDS
		fi

		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_PROP_COUNT $PROP_FILE_LIST_COUNT
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_PROP_FAILED $PROP_FAILED_COUNT
	else
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_CHKS_SKIPPED
	fi


	#
	# Do rootkit check summary.
	#

	display --to SCREEN+LOG --type PLAIN --nl SUMMARY_RKT_SCAN

	if `check_test rootkits`; then
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_RKT_COUNT $ROOTKIT_COUNT
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_RKT_FAILED $ROOTKIT_FAILED_COUNT

		if [ -n "${ROOTKIT_FAILED_NAMES}" ]; then
			ROOTKIT_FAILED_NAMES=`echo "${ROOTKIT_FAILED_NAMES}" | sed -e 's/, $//'`
			display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_RKT_NAMES "${ROOTKIT_FAILED_NAMES}"
		fi
	else
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_CHKS_SKIPPED
	fi


	#
	# Do application check summary.
	#

	display --to SCREEN+LOG --type PLAIN --nl SUMMARY_APPS_SCAN

	if [ $APPS_CHECK_ENABLED -eq 1 ]; then
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_APPS_COUNT $APPS_COUNT
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_APPS_FAILED $APPS_FAILED_COUNT
	else
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_CHKS_SKIPPED
	fi


	#
	# Display the amount of time the system checking took.
	#

	if [ $BEGINTIME -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --nl SUMMARY_NO_SCAN_TIME
	else
		display --to SCREEN+LOG --type PLAIN --nl SUMMARY_SCAN_TIME "${TOTAL_SCANTIME}"
	fi


	#
	# Display where the log file is located, if there is one.
	#

	if [ $NOLOG -eq 0 ]; then
		display --to SCREEN --type PLAIN --nl --nl-after SUMMARY_LOGFILE "${LOGFILE}"
	else
		display --to SCREEN --type PLAIN --nl --nl-after SUMMARY_NO_LOGFILE
	fi

	return
}


display_warnings() {

	echo "-----------------------------------------------------------------"
	echo ""
	echo "Found warnings:"
	egrep 'Warning|WARNING|BAD|Bad|Vulnerable' $LOGFILE
	echo ""
	echo "-----------------------------------------------------------------"
	echo ""
	echo "If you are unsure about the results above, please contact the"
	echo "Rootkit Hunter team through the Rootkit Hunter mailing list"
	echo "at rkhunter-users@lists.sourceforge.net"

	return
}


do_system_check() {

	#
	# This function performs the various rootkit and security checks
	# for the program. We start by initialising variables used for
	# the rootkit checks.
	#

	display --to LOG --type PLAIN --nl CHECK_START

	do_system_check_initialisation


	#
	# Record the start time if we can. The total time taken for
	# scanning will only be calculated and displayed if the
	# start time can be set.
	#

	BEGINTIME=0
	ENDTIME=0

	if [ -n "$SECONDS" ]; then
		BEGINTIME=$SECONDS
	elif [ -n "${PERL_CMD}" ]; then
		BEGINTIME=`${PERL_CMD} -e 'printf "%d\n", time;'`
	fi


	#
	# Send a start message to syslog if the user requested that.
	#

	if [ -n "${USE_SYSLOG}" ]; then
		${LOGGER_CMD} -t "${PROGRAM_NAME}" -p ${USE_SYSLOG} "Rootkit hunter check started (version ${PROGRAM_version})"
	fi


	#
	# We start with checks of some of the commands (binaries) and 
	# libraries on the system, to make sure that they have not
	# been tampered with.
	#

	do_system_commands_checks


	#
	# Next are the rootkit checks.
	#

	do_rootkit_checks


	#
	# Next are some network port, and interface checks.
	#

	do_network_checks


	#
	# Next are checks of the files for the local host.
	#

	do_local_host_checks


	#
	# Next are checks on specific applications.
	#

	do_app_checks


	#
	# Now record the end time.
	#

	if [ $BEGINTIME -ne 0 ]; then
		if [ -n "$SECONDS" ]; then
			ENDTIME=$SECONDS
		else
			ENDTIME=`${PERL_CMD} -e 'printf "%d\n", time;'`
		fi

		TOTAL_SCANTIME=`expr ${ENDTIME} - ${BEGINTIME}`
		TOTALMINS=`expr ${TOTAL_SCANTIME} / 60`
		TOTALSECS=`expr ${TOTAL_SCANTIME} % 60`

		if [ $TOTALMINS -gt 0 ]; then
			if [ $TOTALMINS -eq 1 ]; then
				TOTAL_SCANTIME="${TOTALMINS} minute and "
			else
				TOTAL_SCANTIME="${TOTALMINS} minutes and "
			fi
		else
			TOTAL_SCANTIME=""
		fi

		if [ $TOTALSECS -eq 1 ]; then
			TOTAL_SCANTIME="${TOTAL_SCANTIME}${TOTALSECS} second"
		else
			TOTAL_SCANTIME="${TOTAL_SCANTIME}${TOTALSECS} seconds"
		fi
	fi


	#
	# Display the summary of the results.
	#

	if [ $SHOW_SUMMARY -eq 1 ]; then
		#
		# Unfortunately we need to do a kludge here!
		# The user may have used the '--quiet' option,
		# so we need to force the summary to be displayed.
		# By resetting the NOTTY variable we can get
		# the output shown.
		#

		OLD_NOTTY=$NOTTY
		test $SHOW_SUMMARY_OPT -eq 1 && NOTTY=0

		display_check_summary

		if [ $WARNING_COUNT -eq 0 ]; then
			display --to SCREEN --type PLAIN --nl-after CHECK_WARNINGS_NOT_FOUND
		else
			display --to SCREEN --type PLAIN CHECK_WARNINGS_FOUND

			if [ $NOLOG -eq 1 ]; then
				display --to SCREEN --type PLAIN --nl-after CHECK_WARNINGS_FOUND_RERUN
			else
				display --to SCREEN --type PLAIN --nl-after CHECK_WARNINGS_FOUND_CHK_LOG "${LOGFILE}"
			fi
		fi

		NOTTY=$OLD_NOTTY
	fi


	#
	# Send a finish message to syslog if the user requested that.
	#

	if [ -n "${USE_SYSLOG}" ]; then
		${LOGGER_CMD} -t "${PROGRAM_NAME}" -p ${USE_SYSLOG} "Scanning took ${TOTAL_SCANTIME}"
	fi


	#
	# If some warning or error has been seen, then make sure the
	# user is told about it. We also set the return code, to allow
	# the user to detect it being non-zero.
	#

	if [ $WARNING_COUNT -gt 0 ]; then
		if [ $SHOWWARNINGSONLY -eq 1 ]; then
			#
			# Unfortunately we need to do a kludge again!
			# By requesting that only warnings are shown,
			# the following output would not normally be
			# displayed (because they are not warnings).
			#

			OLD_NOTTY=$NOTTY
			NOTTY=0

			display --to SCREEN --type PLAIN --nl CHECK_WARNINGS_FOUND

			if [ $NOLOG -eq 1 ]; then
				display --to SCREEN --type PLAIN CHECK_WARNINGS_FOUND_RERUN
			else
				display --to SCREEN --type PLAIN CHECK_WARNINGS_FOUND_CHK_LOG "${LOGFILE}"
			fi

			display_warnings

			NOTTY=$OLD_NOTTY
		fi


		if [ -n "${USE_SYSLOG}" ]; then
			${LOGGER_CMD} -t "${PROGRAM_NAME}" -p ${USE_SYSLOG} "Please inspect this machine, because it may be infected"
		fi


		if [ -n "${MAILONWARNING}" ]; then
			eval "echo 'Please inspect this machine, because it may be infected' | ${MAIL_CMD} ${MAILONWARNING}"
		fi

		RET_CODE=1
	fi

	return
}


check_os_info() {

	#
	# This function checks the current O/S information against
	# that stored in the rkhunter.dat file. Any change could
	# mean that the file properties checks could give several
	# false-positive answers. As such we warn users that
	# a change has occurred.
	#

	#
	# First check if the host name has changed.
	#

	FOUND=0

	display --to LOG --type PLAIN --nl OSINFO_START


	OLD_HOST=`grep '^Host:' ${DB_PATH}/rkhunter.dat | cut -d: -f2-`

	if [ "${HOST_NAME}" != "${OLD_HOST}" ]; then
		FOUND=1
		display --to LOG --type WARNING OSINFO_HOST_CHANGE1
		display --to LOG --type PLAIN --log-indent 9 OSINFO_HOST_CHANGE2 "${OLD_HOST}" "${HOST_NAME}"
	fi


	#
	# Next check if the O/S name has changed.
	#

	OLD_OSNAME=`grep '^OS:' ${DB_PATH}/rkhunter.dat | cut -d: -f2-`

	if [ "${OSNAME}" != "${OLD_OSNAME}" ]; then
		FOUND=1
		display --to LOG --type WARNING OSINFO_OSVER_CHANGE1
		display --to LOG --type PLAIN --log-indent 9 OSINFO_OSVER_CHANGE2 "${OLD_OSNAME}" "${OSNAME}"
	fi


	#
	# Check if the prelinking status has changed.
	#

	if [ -z "`grep '^Prelinked:Yes' ${DB_PATH}/rkhunter.dat`" ]; then
		OLD_PRELINK=0
	else
		OLD_PRELINK=1
	fi

	if [ $PRELINKED -ne $OLD_PRELINK ]; then
		FOUND=1
		if [ $PRELINKED -eq 1 ]; then
			display --to LOG --type WARNING OSINFO_PRELINK_CHANGE ''
		else
			display --to LOG --type WARNING OSINFO_PRELINK_CHANGE 'not '
		fi
	fi


	#
	# Check if the system architecture has changed. We treat
	# the i386-type architectures as the same. We also treat
	# the sun-type archictures the same as 'sparc'.
	#

	OLD_ARCH=`grep '^Arch:' ${DB_PATH}/rkhunter.dat | cut -d: -f2-`

	if [ -n "`echo ${OLD_ARCH} | grep 'i[0-9]86'`" ]; then
		OLD_ARCH_TYPE="i386"
	elif [ -n "`echo ${OLD_ARCH} | grep 'sun[0-9][a-z]'`" -o -n "`echo ${OLD_ARCH} | grep 'sparc'`" ]; then
		OLD_ARCH_TYPE="sparc"
	else
		OLD_ARCH_TYPE=$OLD_ARCH
	fi

	if [ -n "`echo ${ARCH} | grep 'i[0-9]86'`" ]; then
		ARCH_TYPE="i386"
	elif [ -n "`echo ${ARCH} | grep 'sun[0-9][a-z]'`" -o -n "`echo ${ARCH} | grep 'sparc'`" ]; then
		ARCH_TYPE="sparc"
	else
		ARCH_TYPE=$ARCH
	fi

	if [ "${OLD_ARCH_TYPE}" != "${ARCH_TYPE}" ]; then
		FOUND=1
		display --to LOG --type WARNING OSINFO_ARCH_CHANGE1
		display --to LOG --type PLAIN --log-indent 9 OSINFO_ARCH_CHANGE2 "${OLD_ARCH}" "${ARCH}"
	fi


	if [ $FOUND -eq 1 ]; then
		display --to LOG --type PLAIN --log-indent 9 OSINFO_MSG1
		display --to LOG --type PLAIN --log-indent 9 OSINFO_MSG2
		display --to LOG --type WARNING --nl PROPUPD_WARN
	else
		display --to LOG --type INFO OSINFO_END
	fi

	return
}


set_file_prop_dirs_files() {

	#
	# This function sets up the list of directories we look in,
	# and the list of files we look for, in order to perform
	# the file properties checks.
	#

	PROP_DIR_LIST=""

	for DIR in ${BINPATHS}; do
		PROP_DIR_LIST="${PROP_DIR_LIST} ${ROOTDIR}${DIR}"
	done

	PROP_FILE_LIST="adduser amd basename cat chattr checkproc chkconfig
	    chmod chown chroot cron csh date depmod df dirname dmesg du echo
	    ed egrep env fgrep file find grep groupadd groupdel groupmod
	    groups grpck head id ifconfig ifdown ifstatus ifup inetd init
	    insmod ip kallsyms kill killall ksyms kudzu last lastlog less
	    locate logger login ls lsattr lsmod lynx md5 md5sum mlocate modinfo
	    modload modprobe modstat modunload more mount netstat newgrp
	    newsyslog nologin passwd ps pstree pwck rkhunter rmmod runlevel sh
	    sha1 sha1sum size slocate sockstat sort stat strace strings su sudo
	    sulogin sysctl syslogd systat tail tcpd test top touch uname
	    useradd userdel usermod users vipw vmstat w watch wc wget whatis
	    whereis which who whoami xinetd"


	#
	# Under SunOS /bin is a link to /usr/bin, so there is no need
	# to look in it. Also add in some extra commands to check.
	#

	if [ "${OPERATING_SYSTEM}" = "SunOS" ]; then
		if [ -h ${ROOTDIR}/bin ]; then
			B=""

			for DIR in ${PROP_DIR_LIST}; do
				test "${DIR}" != "${ROOTDIR}/bin" && B="${B} ${DIR}"
			done

			PROP_DIR_LIST=`echo ${B} | sed -e 's/^ *//'`
		fi

		PROP_FILE_LIST="${PROP_FILE_LIST} gbasename gcat gchmod gchown
		    gdate gdirname gecho gfind gfile ggroups ghead gid glocate
		    gmd5sum gsize gtail gtest gtouch guname gusers truss"
	elif [ "${OPERATING_SYSTEM}" = "FreeBSD" ]; then
		PROP_FILE_LIST="${PROP_FILE_LIST} kldload kldstat kldunload"
	fi


	add_extra_dirs
	PROP_DIR_LIST="${PROP_DIR_LIST}${EXTRA_DIRS}"

	PROP_FILE_LIST_TOTAL=`echo ${PROP_FILE_LIST} | wc -w | tr -d ' '`

	return
}


check_test() {

	#
	# This function will test if a given test name is enabled
	# or not. It returns 0 if the test is to be executed, and
	# 1 if it is not.
	#

	if [ "${ENABLE_TESTS}" = "all" -o -n "`echo \"${ENABLE_TESTS}\" | egrep \"(^| )${1}( |$)\"`" ]; then
		if [ "${DISABLE_TESTS}" = "none" -o -z "`echo \"${DISABLE_TESTS}\" | egrep \"(^| )${1}( |$)\"`" ]; then
			return 0
		fi
	fi

	return 1
}


display_tests() {

	#
	# This function is used to simply output all the available
	# tests and test group names. If a group name itself contains
	# a group name, then that second group name is omitted. It
	# could be confusing if it was included.
	#

	KNOWN_TESTS="all none ${KNOWN_TESTS}"

	#
	# We have to look for the sort command because
	# it won't have been set yet.
	#

	SORT_CMD=`find_cmd sort`

	if [ -n "${SORT_CMD}" ]; then
		KNOWN_TESTS=`echo "${KNOWN_TESTS}" | tr ' ' '\n' | ${SORT_CMD} | tr '\n' ' '`
		GROUPED_TESTS=`echo "${GROUPED_TESTS}" | tr ' ' '\n' | ${SORT_CMD} | tr '\n' ' '`
	fi


	echo "Available test names:"

	while test -n "${KNOWN_TESTS}"; do
		STR=`echo ${KNOWN_TESTS} | cut -d' ' -f1-6`
		KNOWN_TESTS=`echo ${KNOWN_TESTS} | cut -d' ' -f7-`

		echo "    ${STR}"

		test "${STR}" = "${KNOWN_TESTS}" && KNOWN_TESTS=""
	done


	echo ""
	echo "Grouped test names:"

	#
	# Sort out the maximum group name length, so we can do some
	# simple formatting of the output.
	#

	MAX=0

	for STR in ${GROUPED_TESTS}; do
		LEN=`echo "${STR}" | cut -d: -f1 | wc -c | tr -d ' '`
		test $LEN -gt $MAX && MAX=$LEN
	done


	#
	# Now loop through the group names.
	#

	for STR in ${GROUPED_TESTS}; do
		TEST_NAMES=""
		GROUP_NAME=`echo "${STR}" | cut -d: -f1`

		#
		# Add on spaces to expand the group name to the maximum.
		#

		LEN=`echo "${GROUP_NAME}" | wc -c | tr -d ' '`
		LEN=`expr $MAX - $LEN`

		if [ $LEN -gt 0 ]; then
			GROUP_NAME="${GROUP_NAME} `echo \"${BLANK_LINE}\" | cut -d' ' -f1-$LEN`"
		fi


		#
		# Check through the list of tests for this group name.
		# If the test name is a group name itself, then go to
		# the next test name, otherwise add it to our list of
		# test names.
		#

		for TEST in `echo "${STR}" | cut -d: -f2- | tr ':' ' '`; do
			RKHTMPVAR=`echo "${GROUPED_TESTS}" | egrep "(^| )${TEST}:"`

			if [ -n "${RKHTMPVAR}" ]; then
				continue
			else
				TEST_NAMES="${TEST_NAMES}:${TEST}"
			fi
		done


		#
		# Finally, sort our list of test names and display them.
		#

		TEST_NAMES=`echo "${TEST_NAMES}" | sed -e 's/^://'`

		if [ -n "${SORT_CMD}" ]; then
			TEST_NAMES=`echo "${TEST_NAMES}" | tr ':' '\n' | ${SORT_CMD} | tr '\n' ' '`
		else
			TEST_NAMES=`echo "${TEST_NAMES}" | tr ':' ' '`
		fi

		echo "    ${GROUP_NAME} => ${TEST_NAMES}"
	done

	echo ""
	echo "Please see the README file for a brief description of the test names."

	return
}


display_languages() {

	#
	# This function is used to simply output all the available
	# languages in a basic format of 10 per line.
	#

	TITLE=1

	#
	# We have to look for the sort command because
	# it won't have been set yet.
	#

	SORT_CMD=`find_cmd sort`

	if [ -n "${SORT_CMD}" ]; then
		KNOWN_LANGS=`echo "${KNOWN_LANGS}" | tr ' ' '\n' | ${SORT_CMD} | tr '\n' ' '`
	fi


	while test -n "${KNOWN_LANGS}"; do
		STR=`echo ${KNOWN_LANGS} | cut -d' ' -f1-10`
		KNOWN_LANGS=`echo ${KNOWN_LANGS} | cut -d' ' -f11-`

		if [ $TITLE -eq 1 ]; then
			TITLE=0
			echo "Available languages (ISO code): ${STR}"
		else
			echo "                                ${STR}"
		fi

		test "${STR}" = "${KNOWN_LANGS}" && KNOWN_LANGS=""
	done

	return
}


display_rootkits() {

	#
	# This function is used to simply output all the rootkit
	# names which rkhunter will check for.
	#

	#
	# We have to look for the sort command because
	# it won't have been set yet.
	#

	SORT_CMD=`find_cmd sort`

	if [ -n "${SORT_CMD}" ]; then
		KNOWN_ROOTKITS=`echo " ${KNOWN_ROOTKITS}" | tr ',' '\n' | ${SORT_CMD} | tr '\n' ','`
	fi

	KNOWN_ROOTKITS=`echo "${KNOWN_ROOTKITS}" | sed -e 's/,$//' | sed -e 's/^,*//'`


	echo "Rootkits checked for:"

	while test -n "${KNOWN_ROOTKITS}"; do
		STR=`echo ${KNOWN_ROOTKITS} | cut -d',' -f1-6`
		KNOWN_ROOTKITS=`echo ${KNOWN_ROOTKITS} | cut -d',' -f7-`

		if [ "${STR}" = "${KNOWN_ROOTKITS}" -o -z "${KNOWN_ROOTKITS}" ]; then
			KNOWN_ROOTKITS=""
		else
			STR="${STR},"
		fi

		echo "    ${STR}"
	done

	return
}


help() {

	#
	# This function outputs the help menu.
	#

	echo ""
	echo "Usage: rkhunter (--check | --cronjob | --update | --propupd |"
	echo "                 --versioncheck | --version | --help) [option]..."
	echo ""

	echo "Current options are:"
	echo "         --append-log                  Append to the logfile, do not overwrite"
	echo "         --bindir <bindir>...          Use specified command directory"
	echo "                                       command directories"
	echo "     -c, --check                       Check the local system"
	echo "  --cs2, --color-set2                  Use second color set for output"
	echo "         --configfile <file>           Use specified configuration file"
	echo "         --cronjob                     Run as a cronjob"
	echo "                                       (implies -c, --sk and --nocolors options)"
	echo "         --dbdir <dir>                 Use specified database directory"
	echo "         --debug                       Debug mode"
	echo "                                       (Do not use unless asked to do so)"
	echo "         --disable <test>[,<test>...]  Disable specific tests"
	echo "                                       (Default is to disable no tests)"
	echo "         --display-logfile             Display the logfile at the end"
	echo "         --enable  <test>[,<test>...]  Enable specific tests"
	echo "                                       (Default is to enable all tests)"
	echo "         --hash                        Specify the hash function to use"
	echo "     -h, --help                        Display this help menu, then exit"
	echo " --lang, --language <language>         Specify the language (ISO code) to use"
	echo "                                       (Default is English)"
	echo "         --list [tests | languages |   List the available test names or"
	echo "                 rootkits]             languages, or checked for rootkits."
	echo "     -l, --logfile [logfile]           Write to a logfile"
	echo "                                       (default is $DFLT_LOGFILE)"
	echo "         --noappend-log                Do not append to the logfile, overwrite it"
	echo "         --nocolors                    Use black and white output"
	echo "         --nolog                       Do not write to a logfile"
	echo "--nomow, --no-mail-on-warning          Do not send a message if warnings occur"
	echo "   --ns, --nosummary                   Do not show the summary of check results"
	echo " --novl, --no-verbose-logging          No verbose logging"
	echo "         --propupd                     Update the file properties database"
	echo "     -q, --quiet                       Quiet mode (no output at all)"
	echo "  --rwo, --report-warnings-only        Show only warnings"
	echo "     -r, --rootdir <rootdir>           Use <rootdir> instead of '/'"
	echo "   --sk, --skip-keypress               Don't wait for a keypress after each test"
	echo "         --summary                     Show the summary of system check results"
	echo "                                       (This is the default)"
	echo "         --syslog [facility.priority]  Log check start and finish times to syslog"
	echo "                                       (Default level is $SYSLOG_DFLT_PRIO)"
	echo "         --tmpdir <tempdir>            Use specified temporary directory"
	echo "         --update                      Check for updates to database files"
	echo "   --vl, --verbose-logging             Use verbose logging (on by default)"
	echo "     -V, --version                     Display the version number, then exit"
	echo "         --versioncheck                Check for latest version of program"
	echo "  -x/-X                                Do/Do not automatically detect if X is in use"
	echo ""

	return
}


######################################################################
#
# Initialisation
#
######################################################################


#
# First we initialise variables used throughout the program.
#

PROGRAM_NAME="Rootkit Hunter"
PROGRAM_version="1.2.9"
PROGRAM_copyright_owner="Michael Boelen"
PROGRAM_copyright="Copyright (c) 2003-2006, ${PROGRAM_copyright_owner}"
PROGRAM_blurb="
Currently under active development by the ${PROGRAM_NAME} project team.
To report bugs, updates, patches, comments and questions please go to:
http://rkhunter.sourceforge.net

${PROGRAM_NAME} comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it under the
terms of the GNU General Public License. See the LICENSE file for details.
"
PROGRAM_license="
${PROGRAM_NAME} ${PROGRAM_version}, ${PROGRAM_copyright}
${PROGRAM_blurb}
"

# Set to run as a cronjob.
CRONJOB=0
CHECK=0

# Set to display the logfile at the end.
CATLOGFILE=0

NOLOG=0
LOGFILE=""
DFLT_LOGFILE="/var/log/rkhunter.log"

# Set to have the logfile appended to rather than overwritten.
APPEND_LOG=0
APPEND_OPT=0

# Set to have rkhunter start/finish messages, and warnings,
# logged to syslog. The priority/severity can be set on the
# command-line or in the configuration file.
USE_SYSLOG=""
SYSLOG_DFLT_PRIO="authpriv.notice"

DFLT_BINPATHS="/bin /usr/bin /sbin /usr/sbin /usr/local/bin /usr/local/sbin /usr/libexec /usr/local/libexec"

# By default do not send a mail-on-warning message.
NOMOW=0
MAILONWARNING=""

HASH_FUNC=""
PROP_DIR_LIST=""
PROP_FILE_LIST=""
PROP_FILE_LIST_COUNT=0
PROP_FILE_LIST_TOTAL=0

PRELINKED=0
PRELINK_CMD=""

UPDATE=0
PROP_UPDATE=0
VERSIONCHECK=0

# By default use coloured output.
COLORS=1
CLRSET2=0

# Set to automatically detect if X is in use, and
# hence use the second colour set.
AUTO_X_DTCT=0
AUTO_X_OPT=0

PREVIOUSTEXT=""

# Set to be quiet. No output, but the return code will be set.
QUIET=0

# Set to only show warnings.
SHOWWARNINGSONLY=0

# This will be set if the file properties check is to be performed.
HASH_CHECK_ENABLED=0
SKIP_HASH_MSG=0

# This will be set if the applications check is to be performed.
APPS_CHECK_ENABLED=0

# Users can reset this to a new root directory.
ROOTDIR=""

# Default 'id' command. Solaris will reset this.
ID_CMD="id"

# Set if we don't want to wait for a keypress after each test.
SKIP_KEY_PRESS=0

# Is the Gentoo operating system?
GENTOO=0

# These SSH options can only be set in the configuration file.
ALLOW_SSH_PROT_V1=0
ALLOW_SSH_ROOT_USER=0

# Set check counters to be used by the summary
ROOTKIT_COUNT=0
ROOTKIT_FAILED_COUNT=0
ROOTKIT_FAILED_NAMES=""

PROP_FAILED_COUNT=0
SUMMARY_PROP_REQCMDS=0

APPS_COUNT=0
APPS_TOTAL_COUNT=0
APPS_FAILED_COUNT=0

# Timers for the system check.
BEGINTIME=0
TOTAL_SCANTIME=""

# This will be set if a warning message is logged.
WARNING_COUNT=0

FOUNDFILE=0
FOUNDRCSIGNS=0

# Set if grsec is installed.
GRSECINSTALLED=0

# Default display column width
defaultcolumn=60

# Initialise default status.
STATUS=0

# Ksyms or kallsyms file used in some checks.
KSYMS_FILE=""

# Record for logging the command-line being used.
CMD_LINE="$0 $*"

# Create a spaced-separated PATH variable.
SPACEDPATH=`echo ${PATH} | tr ':' ' ' 2>/dev/null`

# List of commands used during RKH. If a command does not exist, then
# the code may use an alternative method.
CMDLIST="diff file find ifconfig ip ldd ls lsattr lsmod lsof mktemp netstat perl ps readlink sort stat strings uniq"

# Commands that are required to exist for RKH to run.
REQCMDS="awk cut date egrep grep head ls sed tail touch tr uname wc"

# List of commands used to download files from the web. This list is 
# used by the '--update' and '--versioncheck' options. Preferred commands
# are listed first.
WEBCMDLIST="wget curl elinks links lynx bget GET"

HOST_NAME=""

if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
	USE_PATCHED_SOFTWARE=1
else
	USE_PATCHED_SOFTWARE=0
fi

# This is the return code for the program actions - update, check, etc.
# Its value may either be 0 (no error) or 1 (an error occurred).
# The '--versioncheck' option may set the return code to 2 to
# indicate that an update is available.
# The '--update' option may set the return code to 2 to
# indicate that an update occurred.
RET_CODE=0

# Set the default language to English.
LANGUAGE=en

# A space-separated list of languages we recognise.
KNOWN_LANGS=en

# A space-separated list of test names we recognise.
KNOWN_TESTS="strings properties hashes scripts immutable attributes
	     deleted_files packet_cap_apps apps rootkits known_rkts
	     additional_rkts malware local_host network passwd
	     possible_rkts possible_rkt_files possible_rkt_strings
	     system_commands shared_libs shared_libs_path running_procs
	     hidden_procs trojan other_malware os_specific"

# A space-separated list of test 'group names'. This list allows test
# names to be grouped together. For example, 'system_commands' can include
# the specific tests of 'strings' and 'hashes'. Both test
# group names, and specific test names, can be used with the test
# enable/disable options. In this list group names are colon-separated
# from the specific test names.
#
GROUPED_TESTS="system_commands:properties:strings:hashes:scripts:shared_libs:shared_libs_path:immutable:attributes
	       properties:hashes:scripts:immutable:attributes
	       shared_libs:shared_libs_path
	       rootkits:known_rkts:additional_rkts:possible_rkts:possible_rkt_files:possible_rkt_strings:malware:running_procs:hidden_procs:deleted_files:trojan:other_malware:os_specific
	       additional_rkts:possible_rkts:possible_rkt_files:possible_rkt_strings
	       possible_rkts:possible_rkt_files:possible_rkt_strings
	       network:packet_cap_apps
	       malware:running_procs:hidden_procs:deleted_files
	       local_host:passwd:other_malware"

# A comma-separated list of rootkits we check for.
# NOTE: This is a COMMA separated list. Any single quotes need to be handled specially - i.e.
# put between double-quotes.
KNOWN_ROOTKITS='55808 Trojan - Variant A, AjaKit, aPa Kit, Apache Worm, Ambient (ark),
  Balaur, BeastKit, beX2, BOBKit, CiNIK Worm (Slapper.B variant), Danny-Boy'"'"'s Abuse Kit,
  Devil, Dica, Dreams, Duarawkz, Enye LKM, Flea Linux, FreeBSD,
  Fuck`it, GasKit, Heroin LKM, HjC Kit, ignoKit, ImperalsS-FBRK, Irix, Kitko,
  Knark, Li0n Worm, Lockit / LJK2, Mood-NT, MRK, Ni0, Ohhara,
  Optic Kit (Tux), Oz, Phalanx, Portacelo, R3dstorm Toolkit, RH-Sharpe'"'"'s,
  RSHA'"'"'s, Scalper Worm, Shutdown, SHV4, SHV5, Sin, SInAR, Slapper, Sneakin,
  Suckit, SunOS / NSDAP, SunOS Rootkit, Superkit, TBD (Telnet BackDoor),
  TeLeKiT, T0rn, Trojanit Kit, Tuxtendo, URK, VcKit, Volc, X-Org SunOS,
  zaRwT.KiT'

# The program defaults of which tests to perform will be set later.
ENABLE_TESTS=""
DISABLE_TESTS=""

# See if the command-line options --enable or --disable have been used.
ENDIS_OPT=0

# Space-filled line used for the display function.
BLANK_LINE="                                                              "

# Initially say that we are connected to a terminal.
NOTTY=0

# By default show the system check summary.
SHOW_SUMMARY=1
SHOW_SUMMARY_OPT=0

# By default log most things that are checked.
VERBOSE_LOGGING=1

# Record this now since we reset IFS a few times.
ORIGIFS=$IFS

# Set a default for the inetd configuration file.
INETD_CONF_PATH="/etc/inetd.conf"
INETDALLOWEDSVCS=""

# Set a default for the xinetd configuration file.
XINETD_CONF_PATH="/etc/xinetd.conf"
XINETDALLOWEDSVCS=""


######################################################################
#
# Command-line option processing
#
######################################################################


#
# Display the help menu if no options were given.
#

if [ $# -eq 0 ]; then
	help
	exit 0
fi


#
# Check the command-line options. If set, these will override the
# configuration file options.
#

while [ $# -ge 1 ]; do
	case "$1" in
	--append-log | --appendlog)
		APPEND_LOG=1
		APPEND_OPT=1
		;;
	--bindir)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			BINPATHS="$1"
			;;
		esac
		;;
	-c | --check | --checkall)
		CHECK=1
		;;
	--configfile)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			CONFIGFILE="$1"
			;;
		esac
		;;
	--cronjob)
		CHECK=1
		CRONJOB=1
		COLORS=0
		SKIP_KEY_PRESS=1
		;;
	--cs2 | --colorset2 | --color-set2)
		CLRSET2=1
		;;
	--dbdir)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			DB_PATH="$1"
			;;
		esac
		;;
	--debug)
		SKIP_KEY_PRESS=1
		;;
	--display-logfile | --displaylogfile | --display-log | --displaylog)
		CATLOGFILE=1
		;;
	--disable)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			CHECK=1
			ENDIS_OPT=1
			DISABLE_TESTS=$1
			;;
		esac
		;;
	--enable)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			CHECK=1
			ENDIS_OPT=1
			ENABLE_TESTS=$1
			;;
		esac
		;;
	--hash)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			HASH_FUNC="$1"
			;;
		esac
		;;
	-h | --help)
		help
		exit 0
		;;
	-l | --log | --logfile | --createlogfile | --createlog | --create-log | --create-logfile)
		LOGFILE="${DFLT_LOGFILE}"

		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			LOGFILE="$1"
			;;
		esac
		;;
	--lang | --language)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			LANGUAGE="$1"
			;;
		esac
		;;
	--list)
		case "$2" in
		test|tests|check|checks)
			display_tests
			;;
		lang|langs|language|languages)
			display_languages
			;;
		rootkit|rootkits)
			display_rootkits
			;;
		"")
			display_tests
			echo ""
			display_languages
			echo ""
			display_rootkits
			;;
		*)
			echo "Invalid --list option specified: $2"
			;;
		esac
		exit 0
		;;
	--noappend-log | --no-append-log | --noappendlog)
		APPEND_LOG=0
		APPEND_OPT=1
		;;
	--nocolors | --no-colors | --nocolor | --no-color)
		COLORS=0
		;;
	--nolog | --no-log)
		LOGFILE="/dev/null"
		;;
	--nomow | --no-mow | --no-mailonwarning | --no-mail-on-warning)
		NOMOW=1
		;;
	--novl | --noverboselogging | --no-verbose-logging)
		VERBOSE_LOGGING=0
		;;
	--ns | --nosummary | --no-summary)
		SHOW_SUMMARY=0
		SHOW_SUMMARY_OPT=1
		;;
	--propupd | --prop-update | --propupdate | --properties-update | --hashupd)
		PROP_UPDATE=1
		;;
	-q | --quiet)
		QUIET=1
		;;
	--rwo | --swo | --report-warnings-only | --show-warnings-only)
		QUIET=1
		SHOWWARNINGSONLY=1
		;;
	-r | --rootdir)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			ROOTDIR="$1"
			;;
		esac
		;;
	-sk | --sk | --skip-keypress | --skipkeypress)
		SKIP_KEY_PRESS=1
		;;
	--summary)
		SHOW_SUMMARY=1
		SHOW_SUMMARY_OPT=1
		;;
	--syslog)
		USE_SYSLOG="${SYSLOG_DFLT_PRIO}"

		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			USE_SYSLOG="$1"
			;;
		esac
		;;
	--tmpdir)
		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			TMPDIR="$1"
			;;
		esac
		;;
	--update)
		UPDATE=1
		;;
	--vl | --verboselogging | --verbose-logging)
		VERBOSE_LOGGING=1
		;;
	-V | --version)
		echo "${PROGRAM_NAME} ${PROGRAM_version}"
		echo "${PROGRAM_blurb}"
		exit 0
		;;
	--versioncheck)
		VERSIONCHECK=1
		;;
	-x)
		AUTO_X_OPT=1
		AUTO_X_DTCT=1
		;;
	-X)
		AUTO_X_OPT=1
		AUTO_X_DTCT=0
		;;
	*)
		echo "Invalid option specified: $1"
		exit 1
		;;
	esac

	shift
done


#
# We check that we are root. If we are not, then only the
# help and version command-line options are valid.
#

if [ "${OPERATING_SYSTEM}" = "SunOS" ]; then
	test -x "/usr/xpg4/bin/id" && ID_CMD="/usr/xpg4/bin/id"
fi

if [ "`${ID_CMD} -u 2>/dev/null`" != "0" ]; then
	echo "You must be the root user to run this program."
	exit 1
fi


#
# Before going too much further we need to ensure that some basic
# commands are present on the system. We cannot do this using
# the BINDIR option because that requires processing the configuration
# file, which in turn requires the commands we want to check on. As
# such we use the default command directory list. We do not assign
# these commands to variables, but will do for other commands which we
# look for later on.
#

check_required_commands "${SPACEDPATH} ${DFLT_BINPATHS}"


######################################################################
#
# Configuration file processing
#
######################################################################


#
# Now we check for the configuration file, and then check the various
# options within it.
#

if [ -z "${CONFIGFILE}" ]; then
	if [ -f /etc/rkhunter.conf ]; then
		CONFIGFILE="/etc/rkhunter.conf"
	else
		CONFIGFILE="/usr/local/etc/rkhunter.conf"
	fi
fi

if [ ! -f "${CONFIGFILE}" ]; then
	echo "Unable to find configuration file: ${CONFIGFILE}"
	exit 1
elif [ ! -r "${CONFIGFILE}" ]; then
	echo "Configuration file is not readable: ${CONFIGFILE}"
	exit 1
fi


get_configfile_options


######################################################################
#
# Option processing
#
######################################################################


#
# Next we check some of the options to make sure we can proceed. We
# also set up some final variables based on the combination of options
# we have been given.
#
# First, if the logfile has been disabled, then we cannot let the
# program run when certain options are used. If we did, the user
# would see no output and might assume that all was well.
#

if [ "${LOGFILE}" = "/dev/null" ]; then
	NOLOG=1

	if [ $SHOWWARNINGSONLY -eq 1 ]; then
		echo "The logfile has been disabled - unable to report warnings."
		exit 1
	elif [ $CATLOGFILE -eq 1 ]; then
		echo "The logfile has been disabled - unable to display the log file."
		exit 1
	fi
fi


#
# Set up the colors to be used.
#

if [ $COLORS -eq 1 ]; then
	NORMAL="[0;39m"		# Foreground colour to default

	if [ $CLRSET2 -eq 0 ]; then
		RED="[1;31m"		# Bright red
		GREEN="[1;32m"	# Bright green
		YELLOW="[1;33m"	# Bright yellow
		WHITE="[1;37m"	# White
	else
		RED="[1;31m"		# Bright red
		GREEN="[0;32m"	# Green
		YELLOW="[0;35m"	# Purple
		WHITE="[0;30m"	# Black
	fi
fi


if [ $CHECK -eq 1 ]; then
	#
	# Check if we have a ksyms or kallsyms file.
	#

	if [ -f "${ROOTDIR}/proc/ksyms" ]; then
		KSYMS_FILE="${ROOTDIR}/proc/ksyms"
	elif [ -f "${ROOTDIR}/proc/kallsyms" ]; then
		KSYMS_FILE="${ROOTDIR}/proc/kallsyms"
	fi


	check_test apps && APPS_CHECK_ENABLED=1
fi


if [ $CHECK -eq 1 -o $PROP_UPDATE -eq 1 ]; then
	if [ -h "${DB_PATH}/rkhunter.dat" ]; then
		echo "The rkhunter.dat file is a symbolic link: ${DB_PATH}/rkhunter.dat"
		echo "This is a security problem. The link points to another file, and that file may be modified by rkhunter."
		exit 1
	fi


	#
	# Set up the file properties checks directories and file names.
	#

	set_file_prop_dirs_files
fi


if [ $PROP_UPDATE -eq 1 -a $PRELINKED -eq 1 ]; then
	#
	# For a hash update on a prelinked system, we must
	# have a valid hash function to use.
	#

	RKHTMPVAR=`echo "${HASH_FUNC}" | cut -d' ' -f1`

	if [ -z "`echo ${RKHTMPVAR} | egrep -i 'sha1|md5'`" ]; then
		echo "This system uses prelinking, but the hash function (${HASH_FUNC}) does not look like SHA1 or MD5."
		exit 1
	fi
fi


#
# For the update and versioncheck options, we need to make sure
# we have a command capable of downloading files from the web.
# The first command found is used.
#

if [ $UPDATE -eq 1 -o $VERSIONCHECK -eq 1 ]; then
	FOUND=0

	for CMD in ${WEBCMDLIST}; do
		#
		# Ignore perl commands if perl is not present, or if
		# certain modules are not present.
		#

		if [ "${CMD}" = "GET" ]; then
			test -z "${PERL_CMD}" && continue

			MOD_INSTALLED=`${PERL_CMD} ${SCRIPT_PATH}/check_modules.pl LWP URI HTTP::Status HTTP::Date Getopt::Long 2>&1 | grep 'NOT'`

			test -n "${MOD_INSTALLED}" && continue
		elif [ "${CMD}" = "bget" ]; then
			test -z "${PERL_CMD}" && continue

			MOD_INSTALLED=`${PERL_CMD} ${SCRIPT_PATH}/check_modules.pl Socket Carp 2>&1 | grep 'NOT'`

			test -n "${MOD_INSTALLED}" && continue
		fi


		RKHTMPVAR=`echo ${CMD} | tr '[a-z]' '[A-Z]'`

		eval ${RKHTMPVAR}_CMD=`find_cmd ${CMD}`

		if [ -n "`eval echo \"\\$${RKHTMPVAR}_CMD\"`" ]; then
			FOUND=1
			break
		fi
	done

	if [ $FOUND -eq 0 ]; then
		echo "The '--update' and '--versioncheck' options require a command able to"
		echo "download files from the web. No such command can be found on the system."
		echo "Examples of commands that could be used are: ${WEBCMDLIST}"
		exit 1
	fi
fi


#
# If no option is given for the program to action, then say so and exit.
#

if [ $CHECK -eq 0 -a $VERSIONCHECK -eq 0 -a $UPDATE -eq 0 -a $PROP_UPDATE -eq 0 ]; then
	echo "You must enter an option for the program to perform."
	echo "Type in 'rkhunter --help' to see the available options,"
	echo "or read the rkhunter man page."
	exit 1
fi


#
# See if we have GRSEC installed.
#

if [ "${OPERATING_SYSTEM}" = "Linux" -a -n "`uname -a | grep 'grsec'`" ]; then
	GRSECINSTALLED=1
fi


#
# Before writing anything to the screen or log file, we need to
# set some variables.
#
# First we set whether we should be displaying anything on the
# screen or not.
#
if [ $CRONJOB -eq 1 -o $QUIET -eq 1 -o ! -t 1 ]; then
	NOTTY=1
fi

#
# Next we get the message types and results from the language file,
# and set them to variables. We have to look in the English file since
# that is the definitive one. We then look for the corresponding keyword
# in the actual language file. This allows the language files to work
# even if we add or remove any of the TYPE or RESULT keywords.
#
IFS="
"

for LINE in `egrep '^MSG_(TYPE|RESULT)_' ${DB_PATH}/i18n/en 2>/dev/null`; do
	TYPE=`echo "${LINE}" | cut -d: -f1`

	if [ "${LANGUAGE}" != "en" ]; then
		RKHTMPVAR=`grep "^${TYPE}:" ${DB_PATH}/i18n/${LANGUAGE} 2>/dev/null`
		test -n "${RKHTMPVAR}" && LINE=$RKHTMPVAR
	fi

	RKHTMPVAR=`echo "${LINE}" | cut -d: -f2-`

	eval $TYPE=\"${RKHTMPVAR}\"
done

IFS=$ORIGIFS


#
# Sort out the logfile before we write to it. If we have no log file,
# then record this. The 'logtext' function will still be called, but
# will return straight away.
#

if [ $NOLOG -eq 0 ]; then
	if [ $APPEND_LOG -eq 0 ]; then
		mv -f ${LOGFILE} ${LOGFILE}.old >/dev/null 2>&1
		touch ${LOGFILE} >/dev/null 2>&1
		chmod 600 ${LOGFILE} >/dev/null 2>&1
	else
		echo "" >>${LOGFILE}
		echo "" >>${LOGFILE}
	fi
fi


#
# Record the hostname. This will be used at several points
# throughout the program. A specific test will specify if
# a hostname has been found or not, so we don't need to
# do anything special here.
#

HOST_NAME=`hostname 2>/dev/null`
test -z "${HOST_NAME}" && HOST_NAME=`uname -n 2>/dev/null`
test -z "${HOST_NAME}" && HOST_NAME="${HOSTNAME}"
HOST_NAME=`echo ${HOST_NAME} | cut -d'.' -f1`


######################################################################
#
# Initial logging
#
######################################################################


#
# Write out various information messages to the logfile.
#

display --to SCREEN --type PLAIN VERSIONLINE "${PROGRAM_NAME}" "${PROGRAM_version}"

if [ -n "${HOST_NAME}" ]; then
	display --to LOG --type PLAIN VERSIONLINE2 "${PROGRAM_NAME}" "${PROGRAM_version}" ${HOST_NAME}
else
	display --to LOG --type PLAIN VERSIONLINE3 "${PROGRAM_NAME}" "${PROGRAM_version}"
fi

display --to LOG --type INFO --nl RKH_STARTDATE "`date`"

display --to LOG --type PLAIN --nl CONFIG_CHECK_START

display --to LOG --type INFO OPSYS "${OPERATING_SYSTEM}"

display --to LOG --type INFO CONFIG_CMDLINE "${CMD_LINE}"

display --to LOG --type INFO CONFIG_ENVSHELL ${SHELL} ${MYSHELL}

display --to LOG --type INFO CONFIG_CONFIGFILE "${CONFIGFILE}"

display --to LOG --type INFO CONFIG_INSTALLDIR "${INSTALLDIR}"

display --to LOG --type INFO CONFIG_LANGUAGE "${LANGUAGE}"

display --to LOG --type INFO CONFIG_DBDIR "${DB_PATH}"

display --to LOG --type INFO CONFIG_SCRIPTDIR "${SCRIPT_PATH}"

display --to LOG --type INFO CONFIG_BINDIR "${BINPATHS}"

if [ -z "${ROOTDIR}" ]; then
	display --to LOG --type INFO CONFIG_ROOTDIR "/"
else
	display --to LOG --type INFO CONFIG_ROOTDIR "${ROOTDIR}"
fi

display --to LOG --type INFO CONFIG_TMPDIR "${TMPDIR}"

if [ $NOMOW -eq 1 ]; then
	display --to LOG --type INFO CONFIG_MOW_DISABLED
else
	if [ -z "${MAILONWARNING}" ]; then
		display --to LOG --type INFO CONFIG_NO_MAIL_ON_WARN
	else
		display --to LOG --type INFO CONFIG_MAIL_ON_WARN "${MAILONWARNING}" "${MAIL_CMD}"
	fi
fi

test $ALLOW_SSH_ROOT_USER -eq 1 && display --to LOG --type INFO CONFIG_SSH_ROOT
test $ALLOW_SSH_PROT_V1 -eq 1 && display --to LOG --type INFO CONFIG_SSH_PROTV1

test $AUTO_X_DTCT -eq 1 && display --to LOG --type INFO CONFIG_X_AUTO
test $CLRSET2 -eq 1 && display --to LOG --type INFO CONFIG_CLRSET2

for CMD in ${CMDLIST}; do
	RKHTMPVAR=`echo ${CMD} | tr '[a-z]' '[A-Z]'`
	RKHTMPVAR=`eval echo "\\$${RKHTMPVAR}_CMD"`
	if [ -n "${RKHTMPVAR}" ]; then
		display --to LOG --type INFO FOUND_CMD "${CMD}" "${RKHTMPVAR}"
	else
		display --to LOG --type INFO NOT_FOUND_CMD "${CMD}"
	fi
done

for CMD in ${WEBCMDLIST}; do
	RKHTMPVAR=`echo ${CMD} | tr '[a-z]' '[A-Z]'`
	RKHTMPVAR=`eval echo "\\$${RKHTMPVAR}_CMD"`
	if [ -n "${RKHTMPVAR}" ]; then
		display --to LOG --type INFO FOUND_CMD "${CMD}" "${RKHTMPVAR}"
	fi
done

if [ $PROP_UPDATE -eq 1 -o $HASH_CHECK_ENABLED -eq 1 ]; then
	if [ $PRELINKED -eq 1 ]; then
		RKHTMPVAR="${PRELINK_CMD}"
		test -n "${RUNCON_CMD}" && RKHTMPVAR=`echo "${RKHTMPVAR}" | cut -d' ' -f5`

		display --to LOG --type INFO FOUND_CMD 'prelink' "${RKHTMPVAR}"

		if [ -n "${RUNCON_CMD}" ]; then
			display --to LOG --type INFO FOUND_CMD 'runcon' "${RKHTMPVAR}"
		else
			display --to LOG --type INFO NOT_FOUND_CMD 'runcon'
		fi

		RKHTMPVAR=`echo "${HASH_FUNC}" | cut -d' ' -f1`
		if [ -z "`echo ${RKHTMPVAR} | egrep -i 'sha1|md5'`" ]; then
			SKIP_HASH_MSG=2
		elif [ -n "`echo ${RKHTMPVAR} | grep -i 'sha1'`" ]; then
			display --to LOG --type INFO SYS_PRELINK_FUNC 'SHA1' "${HASH_FUNC}"
		else
			display --to LOG --type INFO SYS_PRELINK_FUNC 'MD5' "${HASH_FUNC}"
		fi
	else
		display --to LOG --type INFO SYS_NO_PRELINK

		if [ -n "`echo "${HASH_FUNC}" | grep '/filehashsha1\.pl$'`" ]; then
			display --to LOG --type INFO HASH_FUNC_PERL 'SHA1'
		elif [ -n "`echo "${HASH_FUNC}" | grep '/filehashmd5\.pl$'`" ]; then
			display --to LOG --type INFO HASH_FUNC_PERL 'MD5'
		elif [ -n "${HASH_FUNC}" ]; then
			display --to LOG --type INFO HASH_FUNC "${HASH_FUNC}"
		else
			display --to LOG --type INFO HASH_NO_FUNC
		fi
	fi
fi

test $GRSECINSTALLED -eq 1 && display --to LOG --type INFO GRSECINSTALLED

if [ $CHECK -eq 1 ]; then
	display --to LOG --type INFO ENABLED_TESTS "${ENABLE_TESTS}"
	display --to LOG --type INFO DISABLED_TESTS "${DISABLE_TESTS}"

	if [ -n "${KSYMS_FILE}" ]; then
		display --to LOG --type INFO KSYMS_FOUND "${KSYMS_FILE}"
	else
		display --to LOG --type INFO KSYMS_MISSING
	fi

	test $SHOW_SUMMARY -eq 0 && display --to LOG --type INFO CONFIG_NO_SHOW_SUMMARY

	test $VERBOSE_LOGGING -eq 0 && display --to LOG --type INFO CONFIG_NO_VL


	#
	# To use syslog we must have the logger command present.
	#

	if [ -n "${USE_SYSLOG}" ]; then
		if [ "${USE_SYSLOG}" = "none" ]; then
			USE_SYSLOG=""
			display --to LOG --type INFO SYSLOG_DISABLED
		else
			LOGGER_CMD=`find_cmd logger`

			if [ -n "${LOGGER_CMD}" ]; then
				display --to LOG --type INFO SYSLOG_ENABLED "${USE_SYSLOG}"
			else
				USE_SYSLOG=""
				display --to LOG --type INFO SYSLOG_NO_LOGGER
			fi
		fi
	fi


	#
	# If the user wants to run the file properties checks, and the
	# rkhunter.dat file exists, then check the O/S info. If the
	# rkhunter.dat file does not exist, then this will be logged
	# later on.
	#

	if [ $HASH_CHECK_ENABLED -eq 1 ]; then
		if [ -f "${DB_PATH}/rkhunter.dat" -a -s "${DB_PATH}/rkhunter.dat" ]; then
			#
			# We perform a simple check of some of the stored
			# O/S information, and compare it to the current
			# info. Basically we are just seeing if the system
			# has changed at all because it could affect the
			# file properties checks.
			#

			rkh_dat_get_os_info

			check_os_info
		fi
	fi
fi


######################################################################
#
# Start of program actions and checks
#
######################################################################


#
# We can now start to run the actions the user has requested on
# the command-line. We run the update type commands first before
# doing any full system check.
#


#
# The user wants to update the O/S and the file properties data.
#

test $PROP_UPDATE -eq 1 && do_prop_update


#
# The user wants to update the supplied RKH *.dat files.
#

test $UPDATE -eq 1 && do_update


#
# The user wants to check for the latest program version.
#

test $VERSIONCHECK -eq 1 && do_versioncheck


#
# The user wants to check the local system for anomalies.
#

test $CHECK -eq 1 && do_system_check

display --to LOG --type INFO --nl RKH_ENDDATE "`date`"


#
# If the user asked to see the logfile, then show it.
#

test $CATLOGFILE -eq 1 && cat ${LOGFILE}


exit $RET_CODE
